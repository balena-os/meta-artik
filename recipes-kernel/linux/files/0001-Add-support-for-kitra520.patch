From 5b17642754dc3d16c144b3ee7733028fea9e7728 Mon Sep 17 00:00:00 2001
From: Florin Sarbu <florin@resin.io>
Date: Fri, 26 May 2017 12:44:34 +0200
Subject: [PATCH] Add support for kitra520

This patch is the "git am" friendly version of the patch:
https://github.com/rushup/Kitra520/raw/master/Kernel%20release/artik_os_1.1.0/kitra520-linux-artik-release-artik520-artik_os_1.1.0.patch

Instructions related to this patch are from https://github.com/rushup/Kitra520/wiki/Patch-kernel

Upstream-Status: Pending

Signed-off-by: Florin Sarbu <florin@resin.io>
---
 arch/arm/boot/dts/exynos3250-artik5.dts            |  122 +-
 arch/arm/configs/artik5_defconfig                  |   13 +-
 drivers/gpu/drm/panel/Kconfig                      |    6 +
 drivers/gpu/drm/panel/Makefile                     |    1 +
 drivers/gpu/drm/panel/panel-auo-x163qln01.c        |  556 +++
 drivers/input/touchscreen/Kconfig                  |   15 +
 drivers/input/touchscreen/Makefile                 |    1 +
 drivers/input/touchscreen/ft5x06.c                 | 3974 ++++++++++++++++++++
 drivers/media/platform/exynos/fimc-is-w1/Makefile  |    3 +-
 .../platform/exynos/fimc-is-w1/fimc-is-config.h    |   10 +-
 .../exynos/fimc-is-w1/fimc-is-device-csi.c         |   66 +-
 .../exynos/fimc-is-w1/fimc-is-device-sensor.c      |    8 +-
 .../media/platform/exynos/fimc-is-w1/fimc-is-dt.c  |   21 +-
 .../exynos/fimc-is-w1/fimc-is-video-sensor.c       |    2 +-
 .../exynos/fimc-is-w1/sensor/fimc-is-device-5ea.c  |    2 +-
 .../fimc-is-w1/sensor/fimc-is-device-ov5640.c      | 1368 +++++++
 .../fimc-is-w1/sensor/fimc-is-device-ov5640.h      |  995 +++++
 drivers/media/platform/exynos4-is/media-dev.c      |    1 +
 include/linux/input/ft5x06_ts.h                    |   79 +
 include/uapi/linux/v4l2-mediabus.h                 |    4 +-
 sound/soc/codecs/sgtl5000.c                        |  372 +-
 sound/soc/codecs/sgtl5000.h                        |    3 +
 sound/soc/samsung/Kconfig                          |    1 +
 sound/soc/samsung/artik_ak4953.c                   |    6 +-
 24 files changed, 7487 insertions(+), 142 deletions(-)
 create mode 100644 drivers/gpu/drm/panel/panel-auo-x163qln01.c
 create mode 100644 drivers/input/touchscreen/ft5x06.c
 create mode 100644 drivers/media/platform/exynos/fimc-is-w1/sensor/fimc-is-device-ov5640.c
 create mode 100644 drivers/media/platform/exynos/fimc-is-w1/sensor/fimc-is-device-ov5640.h
 create mode 100644 include/linux/input/ft5x06_ts.h

diff --git a/arch/arm/boot/dts/exynos3250-artik5.dts b/arch/arm/boot/dts/exynos3250-artik5.dts
index 69647f9..cd1075e 100644
--- a/arch/arm/boot/dts/exynos3250-artik5.dts
+++ b/arch/arm/boot/dts/exynos3250-artik5.dts
@@ -521,10 +521,14 @@
 		samsung,i2c-max-bus-freq = <400000>;
 		#size-cells = <0>;
 
-		gaudio_codec: ak4953@13 {
-			compatible = "akm,ak4953";
-			reg = <0x13>;
-			ak4953,pdn-gpio = <&gpc0 3 0x1>;
+		gaudio_codec: sgtl5000@0a {
+			compatible = "fsl,sgtl5000";
+			reg = <0x0a>;
+      VDDA-supply = <&vddext_18>;
+      VDDIO-supply = <&vddext_18>;
+      VDDD-supply = <&vddext_18>;
+      //ak4953,pdn-gpio = <&gpc0 3 0x1>;
+
 		};
 
 		bq24296_charger@6b {
@@ -551,6 +555,9 @@
 		clock-names = "mout_epll", "fout_epll",
 			      "mout_audio", "dout_audio",
 			      "dout_i2s", "sclk_i2s";
+    VDDA-supply = <&vddext_18>;
+    VDDIO-supply = <&vddext_18>;
+    VDDD-supply = <&vddext_18>;
 		status = "okay";
 	};
 
@@ -567,7 +574,41 @@
 		samsung,i2c-sda-delay = <100>;
 		samsung,i2c-max-bus-freq = <400000>;
 		#size-cells = <0>;
-		status = "okay";
+
+	    status = "okay";
+
+        touchscreen@38 {
+             compatible = "focaltech,5x06";
+             reg = <0x38>;
+             interrupt-parent = <&gpx0>;
+             interrupts = <6 0 0>;
+             pinctrl-names = "default";
+             pinctrl-0 = <&touch_irq>;
+             focaltech,name = "ft5336";
+             focaltech,family-id = <0x14>;
+             focaltech,reset-gpio = <&gpx0 4 0x1>;
+             focaltech,irq-gpio = <&gpx0 6 0x1>;
+             focaltech,display-coords = <0 0 320 320>;
+             focaltech,panel-coords = <0 0 320 320>;
+             focaltech,button-map= <139 102 158>;
+             focaltech,no-force-update;
+             focaltech,i2c-pull-up;
+             focaltech,group-id = <1>;
+             focaltech,hard-reset-delay-ms = <20>;
+             focaltech,soft-reset-delay-ms = <200>;
+             focaltech,num-max-touches = <5>;
+             #focaltech,fw-name = "ft_8926_qrd_fw.bin";
+             focaltech,fw-delay-aa-ms = <30>;
+             focaltech,fw-delay-55-ms = <30>;
+             #focaltech,fw-upgrade-id1 = <0x79>;
+             #focaltech,fw-upgrade-id2 = <0x08>;
+             focaltech,fw-delay-readid-ms = <10>;
+             focaltech,fw-delay-era-flsh-ms = <2000>;
+             focaltech,fw-auto-cal;
+             focaltech,ignore-id-check;
+        };
+
+
 	};
 
 	regulators {
@@ -590,42 +631,41 @@
 		};
 	};
 
-	i2c_gpio0: i2c@2d {
+	i2c_gpio0: i2c@3c {
 		compatible = "i2c-gpio";
 		gpios = <&gpm4 1 0 &gpm4 0 0>;
 		i2c-gpio,delay-us = <2>;    /* ~100kHz */
 		#address-cells = <1>;
 		#size-cells = <0>;
 		status = "okay";
-
-		s5k5ea@2d {
-			compatible = "samsung,exynos5-fimc-is-sensor-5ea";
-			reg = <0x2d>;
-		};
+		ov5642@2d {
+			compatible = "samsung,exynos5-fimc-is-sensor-ov5640";
+			reg = <0x3c>;
+        };
 	};
 
 	fimc_is@14000000 {
-		fixed_sensor_id = <14>;
+		fixed_sensor_id = <202>;
 		fimc_is_dvfs {
 			default_int = <134000>; /* L1 */
 			default_cam = <320000>; /* L0 */
 			default_mif = <400000>; /* L0 */
 			default_i2c = <0>;
 
-			rear_preview_int = <134000>; /* L1 */
-			rear_preview_cam = <320000>; /* L0 */
-			rear_preview_mif = <400000>; /* L0 */
-			rear_preview_i2c = <0>;
-
-			rear_capture_int = <134000>; /* L1 */
-			rear_capture_cam = <320000>; /* L0 */
-			rear_capture_mif = <400000>; /* L0 */
-			rear_capture_i2c = <0>;
-
-			rear_camcording_int = <134000>; /* L1 */
-			rear_camcording_cam = <320000>; /* L0 */
-			rear_camcording_mif = <400000>; /* L0 */
-			rear_camcording_i2c = <0>;
+//			rear_preview_int = <134000>; /* L1 */
+//			rear_preview_cam = <320000>; /* L0 */
+//			rear_preview_mif = <400000>; /* L0 */
+//			rear_preview_i2c = <0>;
+//
+//			rear_capture_int = <134000>; /* L1 */
+//			rear_capture_cam = <320000>; /* L0 */
+//			rear_capture_mif = <400000>; /* L0 */
+//			rear_capture_i2c = <0>;
+//
+//			rear_camcording_int = <134000>; /* L1 */
+//			rear_camcording_cam = <320000>; /* L0 */
+//			rear_camcording_mif = <400000>; /* L0 */
+//			rear_camcording_i2c = <0>;
 
 			max_int = <134000>; /* L1 */
 			max_cam = <320000>; /* L0 */
@@ -638,15 +678,17 @@
 		scenario = <2>;
 		gpio_reset = <&gpm3 2 0x1>;
 		gpios_cam_en = <&gpm0 2 0x1>;
+		gpios_comp_en = <&gpx2 6 0x1>;
 		id = <0>;
-		mclk_ch = <1>;
+		mclk_ch = <0>;
 		csi_ch = <0>;
 		flite_ch = <0>;
 		i2c_ch = <0>;
-		i2c_addr = <0x20>;
+		i2c_addr = <0x3c>;
 		is_bns = <0>;
 		status = "okay";
 	};
+
 };
 
 &pmic_irq {
@@ -733,7 +775,7 @@
 	};
 
 	panel@0 {
-		compatible = "sparkling,eh400wv";
+		compatible = "auo,x163qln";
 		reg = <0>;
 		vdd3-supply = <&vddext_28>;
 		vci-supply = <&vddext_18>;
@@ -745,20 +787,20 @@
 		init-delay = <100>;
 		flip-horizontal;
 		flip-vertical;
-		panel-width-mm = <52>;
-		panel-height-mm = <86>;
+		panel-width-mm = <30>;
+		panel-height-mm = <30>;
 
 		display-timings {
 			timing-0 {
-				clock-frequency = <24800400>;
-				hactive = <480>;
-				vactive = <800>;
-				hfront-porch = <16>;
-				hback-porch = <16>;
-				hsync-len = <2>;
-				vfront-porch = <28>;
-				vback-porch = <28>;
-				vsync-len = <2>;
+				clock-frequency = <80674>;
+				hactive = <320>;
+				vactive = <320>;
+				hfront-porch = <0>;
+				hback-porch = <164>;
+				hsync-len = <0>;
+				vfront-porch = <0>;
+				vback-porch = <100>;
+				vsync-len = <20>;
 			};
 		};
 
diff --git a/arch/arm/configs/artik5_defconfig b/arch/arm/configs/artik5_defconfig
index d5c7cf4..103b78b 100644
--- a/arch/arm/configs/artik5_defconfig
+++ b/arch/arm/configs/artik5_defconfig
@@ -308,6 +308,9 @@ CONFIG_REGULATOR_FIXED_VOLTAGE=y
 CONFIG_REGULATOR_S2MPS14=y
 CONFIG_MEDIA_SUPPORT=y
 CONFIG_MEDIA_CAMERA_SUPPORT=y
+#CONFIG_SOC_CAMERA=y
+#CONFIG_SOC_CAMERA_PLATFORM=y
+#CONFIG_SOC_CAMERA_OV5642=m
 CONFIG_VIDEOBUF2_ION=y
 CONFIG_V4L_PLATFORM_DRIVERS=y
 CONFIG_VIDEO_EXYNOS_GSCALER=y
@@ -321,7 +324,8 @@ CONFIG_DRM_EXYNOS=y
 CONFIG_DRM_EXYNOS_FIMD=y
 CONFIG_DRM_EXYNOS_DSI=y
 # CONFIG_DRM_EXYNOS_DP is not set
-CONFIG_DRM_PANEL_SPARKLING_EW400WV=y
+CONFIG_DRM_PANEL_SPARKLING_EW400WV=n
+CONFIG_DRM_PANEL_AUO_X163QLN=y
 CONFIG_ION=y
 CONFIG_ION_EXYNOS=y
 CONFIG_ION_EXYNOS_OF=y
@@ -338,11 +342,13 @@ CONFIG_LCD_MIPI_SHIRI=y
 CONFIG_LCD_CLASS_DEVICE=y
 CONFIG_FRAMEBUFFER_CONSOLE=y
 CONFIG_LOGO=y
+CONFIG_LOGO_KITRA_KANKAN=y
 CONFIG_SOUND=y
 CONFIG_SND=y
 CONFIG_SND_SOC=y
-CONFIG_SND_SOC_SAMSUNG=m
-CONFIG_SND_SOC_SAMSUNG_ARTIK_AK4953=m
+CONFIG_SND_SOC_SAMSUNG=y
+CONFIG_SND_SOC_SAMSUNG_ARTIK_AK4953=y
+CONFIG_SND_SOC_SGTL5000=y
 CONFIG_UHID=y
 CONFIG_USB_PHY=y
 CONFIG_SAMSUNG_USB2PHY=y
@@ -472,6 +478,7 @@ CONFIG_BLK_DEV_IO_TRACE=y
 CONFIG_FUNCTION_PROFILER=y
 # CONFIG_ARM_UNWIND is not set
 CONFIG_DEBUG_USER=y
+CONFIG_DYNAMIC_DEBUG=y
 CONFIG_SECURITY=y
 CONFIG_SECURITY_SMACK=y
 CONFIG_SECURITY_SMACK_PERMISSIVE_MODE=y
diff --git a/drivers/gpu/drm/panel/Kconfig b/drivers/gpu/drm/panel/Kconfig
index 631a90b..5271cc0 100644
--- a/drivers/gpu/drm/panel/Kconfig
+++ b/drivers/gpu/drm/panel/Kconfig
@@ -59,6 +59,12 @@ config DRM_PANEL_SPARKLING_EW400WV
 	select DRM_MIPI_DSI
 	select VIDEOMODE_HELPERS
 
+config DRM_PANEL_AUO_X163QLN
+	tristate "MIPI-DSI X163QLN TFT LCD Panel"
+	depends on OF
+	select DRM_MIPI_DSI
+	select VIDEOMODE_HELPERS
+
 config DRM_PANEL_SHARP_LQ101R1SX01
 	tristate "Sharp LQ101R1SX01 panel"
 	depends on OF
diff --git a/drivers/gpu/drm/panel/Makefile b/drivers/gpu/drm/panel/Makefile
index 250106f..34fe241 100644
--- a/drivers/gpu/drm/panel/Makefile
+++ b/drivers/gpu/drm/panel/Makefile
@@ -7,3 +7,4 @@ obj-$(CONFIG_DRM_PANEL_SAMSUNG_S6E8FA0) += panel-samsung-s6e8fa0.o
 obj-$(CONFIG_DRM_PANEL_SPARKLING_EW400WV) += panel-sparkling-eh400wv.o
 obj-$(CONFIG_DRM_PANEL_SHARP_LQ101R1SX01) += panel-sharp-lq101r1sx01.o
 obj-$(CONFIG_DRM_PANEL_SHARP_LS043T1LE01) += panel-sharp-ls043t1le01.o
+obj-$(CONFIG_DRM_PANEL_AUO_X163QLN) += panel-auo-x163qln01.o
diff --git a/drivers/gpu/drm/panel/panel-auo-x163qln01.c b/drivers/gpu/drm/panel/panel-auo-x163qln01.c
new file mode 100644
index 0000000..19628d6
--- /dev/null
+++ b/drivers/gpu/drm/panel/panel-auo-x163qln01.c
@@ -0,0 +1,556 @@
+/*
+ * MIPI-DSI based AUO x163qln01 TFT LCD 1.63 inch panel driver.
+ *
+ * Copyright (c) 2016 Kalpa srl
+ *
+ * Chanho Park <danilo.sia@kalpa.it>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+
+#include <drm/drmP.h>
+#include <drm/drm_mipi_dsi.h>
+#include <drm/drm_panel.h>
+
+#include <linux/of_gpio.h>
+#include <linux/regulator/consumer.h>
+
+#include <video/mipi_display.h>
+#include <video/of_videomode.h>
+#include <video/videomode.h>
+#include <linux/backlight.h>
+
+struct x163qln {
+	struct device *dev;
+	struct drm_panel panel;
+
+	struct regulator_bulk_data supplies[2];
+	int reset_gpio;
+	int psr_te_gpio;
+	u32 power_on_delay;
+	u32 reset_delay;
+	u32 init_delay;
+	bool flip_horizontal;
+	bool flip_vertical;
+	struct videomode vm;
+	u32 width_mm;
+	u32 height_mm;
+	bool is_power_on;
+
+	u8 id[3];
+	/* This field is tested by functions directly accessing DSI bus before
+	 * transfer, transfer is skipped if it is set. In case of transfer
+	 * failure or unexpected response the field is set to error value.
+	 * Such construct allows to eliminate many checks in higher level
+	 * functions.
+	 */
+	int error;
+};
+
+static inline struct x163qln *panel_to_x163qln(struct drm_panel *panel)
+{
+	return container_of(panel, struct x163qln, panel);
+}
+
+static int x163qln_clear_error(struct x163qln *ctx)
+{
+	int ret = ctx->error;
+
+	ctx->error = 0;
+	return ret;
+}
+
+static void x163qln_dcs_turn_on_peripheral(struct x163qln *ctx)
+{
+	ssize_t ret;
+	struct mipi_dsi_device *dsi = to_mipi_dsi_device(ctx->dev);
+
+	if (ctx->error < 0)
+		return;
+
+	ret = 	mipi_dsi_turn_on_peripheral(dsi);
+	if (ret < 0) {
+		dev_err(ctx->dev, "error %zd turning on  dcs seq\n", ret);
+		ctx->error = ret;
+	}
+}
+
+
+static void x163qln_dcs_display_on(struct x163qln *ctx)
+{
+	ssize_t ret;
+	struct mipi_dsi_device *dsi = to_mipi_dsi_device(ctx->dev);
+
+	if (ctx->error < 0)
+		return;
+
+	ret = 	mipi_dsi_dcs_set_display_on(dsi);
+	if (ret < 0) {
+		dev_err(ctx->dev, "error %zd turning on  dcs seq\n", ret);
+		ctx->error = ret;
+	}
+}
+
+
+static void x163qln_dcs_display_off(struct x163qln *ctx)
+{
+	ssize_t ret;
+	struct mipi_dsi_device *dsi = to_mipi_dsi_device(ctx->dev);
+
+	if (ctx->error < 0)
+		return;
+
+	ret = 	mipi_dsi_dcs_set_display_off(dsi);
+	if (ret < 0) {
+		dev_err(ctx->dev, "error %zd turning on  dcs seq\n", ret);
+		ctx->error = ret;
+	}
+}
+
+static void x163qln_dcs_exit_sleep_mode(struct x163qln *ctx)
+{
+	ssize_t ret;
+	struct mipi_dsi_device *dsi = to_mipi_dsi_device(ctx->dev);
+
+	if (ctx->error < 0)
+		return;
+
+	ret = 	mipi_dsi_dcs_exit_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(ctx->dev, "error %zd turning on  dcs seq\n", ret);
+		ctx->error = ret;
+	}
+}
+
+static void x163qln_dcs_enter_sleep_mode(struct x163qln *ctx)
+{
+	ssize_t ret;
+	struct mipi_dsi_device *dsi = to_mipi_dsi_device(ctx->dev);
+
+	if (ctx->error < 0)
+		return;
+
+	ret = 	mipi_dsi_dcs_enter_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(ctx->dev, "error %zd turning on  dcs seq\n", ret);
+		ctx->error = ret;
+	}
+}
+
+
+static void x163qln_dcs_write(struct x163qln *ctx, const void *data,
+		size_t len)
+{
+	struct mipi_dsi_device *dsi = to_mipi_dsi_device(ctx->dev);
+	ssize_t ret;
+
+	if (ctx->error < 0)
+		return;
+
+	ret = mipi_dsi_dcs_write_buffer(dsi, data, len);
+	if (ret < 0) {
+		dev_err(ctx->dev, "error %zd writing dcs seq: %*ph\n", ret,
+			(int)len, data);
+		ctx->error = ret;
+	}
+}
+
+#define x163qln_dcs_write_seq(ctx, seq...) \
+({\
+	const u8 d[] = { seq };\
+	BUILD_BUG_ON_MSG(ARRAY_SIZE(d) > 64, "DCS sequence too big for stack");\
+	x163qln_dcs_write(ctx, d, ARRAY_SIZE(d));\
+})
+
+#define x163qln_dcs_write_seq_static(ctx, seq...) \
+({\
+	static const u8 d[] = { seq };\
+	x163qln_dcs_write(ctx, d, ARRAY_SIZE(d));\
+})
+
+static void x163qln_apply_power_cond(struct x163qln *ctx)
+{
+	dev_err(ctx->dev, "x163qln_apply_power_cond");
+	x163qln_dcs_write_seq_static(ctx, 0xF0, 0x55, 0xAA, 0x52, 0x08, 0x00);
+	x163qln_dcs_write_seq_static(ctx,	0xBD, 0x01, 0x90, 0x14, 0x14, 0x00);
+	x163qln_dcs_write_seq_static(ctx,	0xBE, 0x01, 0x90, 0x14, 0x14, 0x01);
+	x163qln_dcs_write_seq_static(ctx,	0xBF, 0x01, 0x90, 0x14, 0x14, 0x00);
+	x163qln_dcs_write_seq_static(ctx,	0xBB, 0x07, 0x07, 0x07);
+	x163qln_dcs_write_seq_static(ctx,	0xC7, 0x40);
+	x163qln_dcs_write_seq_static(ctx, 0xF0, 0x55, 0xAA, 0x52, 0x08, 0x02);
+	x163qln_dcs_write_seq_static(ctx, 0xFE, 0x08, 0x50);
+	x163qln_dcs_write_seq_static(ctx, 0xC3, 0xF2, 0x85, 0x04);
+	x163qln_dcs_write_seq_static(ctx, 0xCA, 0x04);
+	x163qln_dcs_write_seq_static(ctx, 0xF0, 0x55, 0xAA, 0x52, 0x08, 0x01);
+	x163qln_dcs_write_seq_static(ctx, 0xB0, 0x03, 0x03, 0x03);
+	x163qln_dcs_write_seq_static(ctx, 0xB1, 0x05, 0x05, 0x05);
+	x163qln_dcs_write_seq_static(ctx, 0xB2, 0x01, 0x01, 0x01);
+	x163qln_dcs_write_seq_static(ctx, 0xB4, 0x07, 0x07, 0x07);
+	x163qln_dcs_write_seq_static(ctx, 0xB5, 0x05, 0x05, 0x05);
+	x163qln_dcs_write_seq_static(ctx, 0xB6, 0x53, 0x53, 0x53);
+	x163qln_dcs_write_seq_static(ctx, 0xB7, 0x33, 0x33, 0x33);
+	x163qln_dcs_write_seq_static(ctx, 0xB8, 0x23, 0x23, 0x23);
+	x163qln_dcs_write_seq_static(ctx, 0xB9, 0x03, 0x03, 0x03);
+	x163qln_dcs_write_seq_static(ctx, 0xBA, 0x13, 0x13, 0x13);
+	x163qln_dcs_write_seq_static(ctx, 0xBE, 0x22, 0x30, 0x70);
+	x163qln_dcs_write_seq_static(ctx, 0xCF, 0xFF, 0xD4, 0x95, 0xEF, 0x4F, 0x00, 0x04);
+
+
+	x163qln_dcs_write_seq_static(ctx, 0x35, 0x01);
+	x163qln_dcs_write_seq_static(ctx, 0x36, 0x00);
+	x163qln_dcs_write_seq_static(ctx, 0xC0, 0x20);
+	x163qln_dcs_write_seq_static(ctx, 0xC2, 0x17, 0x17, 0x17, 0x17, 0x17, 0x0B);
+	ctx->error =0;
+
+	x163qln_dcs_turn_on_peripheral(ctx);
+	x163qln_dcs_exit_sleep_mode(ctx);
+	msleep(300);
+	x163qln_dcs_display_on(ctx);
+
+}
+
+static void x163qln_gamma_setting(struct x163qln *ctx)
+{
+
+}
+
+static void x163qln_apply_display_parameter(struct x163qln *ctx)
+{
+
+}
+
+static void x163qln_set_maximum_return_packet_size(struct x163qln *ctx,
+						   u16 size)
+{
+	struct mipi_dsi_device *dsi = to_mipi_dsi_device(ctx->dev);
+	int ret;
+
+	if (ctx->error < 0)
+		return;
+
+	ret = mipi_dsi_set_maximum_return_packet_size(dsi, size);
+	if (ret < 0) {
+		dev_err(ctx->dev,
+			"error %d setting maximum return packet size to %d\n",
+			ret, size);
+		ctx->error = ret;
+	}
+}
+
+static int x163qln_dcs_read(struct x163qln *ctx, u8 cmd, void *data, size_t len)
+{
+	struct mipi_dsi_device *dsi = to_mipi_dsi_device(ctx->dev);
+	int ret;
+
+	if (ctx->error < 0)
+		return ctx->error;
+
+	ret = mipi_dsi_dcs_read(dsi, cmd, data, len);
+	if (ret < 0) {
+		dev_err(ctx->dev, "error %d reading dcs seq(%#x)\n", ret, cmd);
+		ctx->error = ret;
+	}
+
+	return ret;
+}
+
+static void x163qln_read_mtp_id(struct x163qln *ctx)
+{
+	int ret;
+	int id_len = ARRAY_SIZE(ctx->id);
+
+	ret = x163qln_dcs_read(ctx, 0x04, ctx->id, id_len);
+	if (ret < id_len || ctx->error < 0) {
+		dev_err(ctx->dev, "read id failed\n");
+		ctx->error = -EIO;
+		return;
+	}
+}
+
+static void x163qln_panel_init(struct x163qln *ctx)
+{
+	x163qln_apply_power_cond(ctx);
+/*
+	x163qln_set_maximum_return_packet_size(ctx, 3);
+
+	x163qln_read_mtp_id(ctx);
+	if (ctx->error != 0)
+		return;
+*/
+	x163qln_apply_display_parameter(ctx);
+}
+
+static int x163qln_power_on(struct x163qln *ctx)
+{
+	int ret;
+
+	if (ctx->is_power_on)
+		return 0;
+
+	ret = regulator_bulk_enable(ARRAY_SIZE(ctx->supplies), ctx->supplies);
+	if (ret < 0)
+		return ret;
+
+	dev_err(ctx->dev, "%s %d \n",__FUNCTION__, ret);
+
+	msleep(ctx->power_on_delay);
+
+	gpio_direction_output(ctx->reset_gpio, 0);
+	usleep_range(5000, 6000);
+	gpio_set_value(ctx->reset_gpio, 1);
+
+	msleep(ctx->reset_delay);
+
+	ctx->is_power_on = true;
+
+	return 0;
+}
+
+static int x163qln_power_off(struct x163qln *ctx)
+{
+	if (!ctx->is_power_on)
+		return 0;
+	gpio_set_value(ctx->reset_gpio, 0);
+	usleep_range(5000, 6000);
+	regulator_bulk_disable(ARRAY_SIZE(ctx->supplies), ctx->supplies);
+	ctx->is_power_on = false;
+
+	return 0;
+}
+
+static int x163qln_disable(struct drm_panel *panel)
+{
+	struct x163qln *ctx = panel_to_x163qln(panel);
+	x163qln_dcs_display_off(ctx);
+	x163qln_dcs_enter_sleep_mode(ctx);
+	msleep(120);
+
+	return 0;
+}
+
+static int x163qln_unprepare(struct drm_panel *panel)
+{
+	struct x163qln *ctx = panel_to_x163qln(panel);
+	int ret;
+
+	ret = x163qln_power_off(ctx);
+	if (ret)
+		return ret;
+
+	x163qln_clear_error(ctx);
+
+	return 0;
+}
+
+static int x163qln_prepare(struct drm_panel *panel)
+{
+	struct x163qln *ctx = panel_to_x163qln(panel);
+	int ret;
+
+	ret = x163qln_power_on(ctx);
+	if (ret < 0)
+		return ret;
+
+	x163qln_panel_init(ctx);
+	ret = ctx->error;
+
+	if (ret < 0)
+		x163qln_unprepare(panel);
+
+	dev_err(ctx->dev, "%s %d\n", __FUNCTION__, ret);
+	return ret;
+}
+
+static int x163qln_enable(struct drm_panel *panel)
+{
+	struct x163qln *ctx = panel_to_x163qln(panel);
+
+	x163qln_dcs_write_seq_static(ctx, MIPI_DCS_SET_DISPLAY_ON);
+	if (ctx->error != 0)
+		return ctx->error;
+
+	x163qln_dcs_write_seq_static(ctx, MIPI_DCS_WRITE_MEMORY_START);
+	if (ctx->error != 0)
+		return ctx->error;
+
+	dev_err(ctx->dev, "%s\n", __FUNCTION__);
+	return 0;
+}
+
+static int x163qln_get_modes(struct drm_panel *panel)
+{
+	struct drm_connector *connector = panel->connector;
+	struct x163qln *ctx = panel_to_x163qln(panel);
+	struct drm_display_mode *mode;
+	dev_err(ctx->dev, "%s\n", __FUNCTION__);
+
+	mode = drm_mode_create(connector->dev);
+	if (!mode) {
+		DRM_ERROR("failed to create a new display mode\n");
+		return 0;
+	}
+
+	drm_display_mode_from_videomode(&ctx->vm, mode);
+	mode->width_mm = ctx->width_mm;
+	mode->height_mm = ctx->height_mm;
+	connector->display_info.width_mm = mode->width_mm;
+	connector->display_info.height_mm = mode->height_mm;
+
+	mode->type = DRM_MODE_TYPE_DRIVER | DRM_MODE_TYPE_PREFERRED;
+	drm_mode_probed_add(connector, mode);
+	dev_err(ctx->dev, "%s\n", __FUNCTION__);
+
+	return 1;
+}
+
+static const struct drm_panel_funcs x163qln_drm_funcs = {
+	.disable = x163qln_disable,
+	.unprepare = x163qln_unprepare,
+	.prepare = x163qln_prepare,
+	.enable = x163qln_enable,
+	.get_modes = x163qln_get_modes,
+};
+
+static int x163qln_parse_dt(struct x163qln *ctx)
+{
+	struct device *dev = ctx->dev;
+	struct device_node *np = dev->of_node;
+	int ret;
+
+	ret = of_get_videomode(np, &ctx->vm, 0);
+	if (ret < 0)
+		return ret;
+
+	of_property_read_u32(np, "power-on-delay", &ctx->power_on_delay);
+	of_property_read_u32(np, "reset-delay", &ctx->reset_delay);
+	of_property_read_u32(np, "init-delay", &ctx->init_delay);
+	of_property_read_u32(np, "panel-width-mm", &ctx->width_mm);
+	of_property_read_u32(np, "panel-height-mm", &ctx->height_mm);
+
+	ctx->flip_horizontal = of_property_read_bool(np, "flip-horizontal");
+	ctx->flip_vertical = of_property_read_bool(np, "flip-vertical");
+
+	return 0;
+}
+
+static int x163qln_probe(struct mipi_dsi_device *dsi)
+{
+	struct device *dev = &dsi->dev;
+	struct x163qln *ctx;
+	int ret;
+
+	ctx = devm_kzalloc(dev, sizeof(struct x163qln), GFP_KERNEL);
+	if (!ctx)
+		return -ENOMEM;
+
+	mipi_dsi_set_drvdata(dsi, ctx);
+
+	ctx->dev = dev;
+
+	ctx->is_power_on = false;
+	dsi->lanes = 1;
+	dsi->format = MIPI_DSI_FMT_RGB888;
+	/*
+    dsi->mode_flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_BURST
+		| MIPI_DSI_MODE_VIDEO_HFP | MIPI_DSI_MODE_VIDEO_HBP
+		| MIPI_DSI_MODE_VIDEO_HSA | MIPI_DSI_MODE_VSYNC_FLUSH
+		| MIPI_DSI_MODE_VIDEO_AUTO_VERT;
+*/
+    dsi->mode_flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_BURST
+                      | MIPI_DSI_MODE_VIDEO_HFP | MIPI_DSI_MODE_VIDEO_HBP
+                      | MIPI_DSI_MODE_VIDEO_HSA | MIPI_DSI_MODE_VSYNC_FLUSH
+                      | MIPI_DSI_MODE_VIDEO_AUTO_VERT;
+
+	ret = x163qln_parse_dt(ctx);
+	if (ret < 0)
+		return ret;
+
+	ctx->supplies[0].supply = "vdd3";
+	ctx->supplies[1].supply = "vci";
+	ret = devm_regulator_bulk_get(dev, ARRAY_SIZE(ctx->supplies),
+				      ctx->supplies);
+	if (ret < 0)
+		dev_warn(dev, "failed to get regulators: %d\n", ret);
+
+	ctx->reset_gpio = of_get_named_gpio(dev->of_node, "reset-gpio", 0);
+	if (ctx->reset_gpio < 0) {
+		dev_err(dev, "cannot get reset-gpios %d\n",
+			ctx->reset_gpio);
+		return ctx->reset_gpio;
+	}
+
+	ret = devm_gpio_request(dev, ctx->reset_gpio, "reset-gpio");
+	if (ret) {
+		dev_err(dev, "failed to request reset-gpio\n");
+		return ret;
+	}
+
+	ctx->psr_te_gpio = of_get_named_gpio(dev->of_node, "psr-te-gpio", 0);
+	if (ctx->psr_te_gpio < 0) {
+		dev_err(dev, "cannot get psr te gpios %d\n",
+			ctx->psr_te_gpio);
+		return ctx->psr_te_gpio;
+	}
+
+	ret = devm_gpio_request(dev, ctx->psr_te_gpio, "psr-te-gpio");
+	if (ret) {
+		dev_err(dev, "failed to request psr te gpio\n");
+		return ret;
+	}
+
+	drm_panel_init(&ctx->panel);
+	ctx->panel.dev = dev;
+	ctx->panel.funcs = &x163qln_drm_funcs;
+
+	ret = drm_panel_add(&ctx->panel);
+	if (ret < 0)
+		return ret;
+
+	ret = mipi_dsi_attach(dsi);
+	if (ret < 0)
+		drm_panel_remove(&ctx->panel);
+
+	return ret;
+}
+
+static int x163qln_remove(struct mipi_dsi_device *dsi)
+{
+	struct x163qln *ctx = mipi_dsi_get_drvdata(dsi);
+
+	mipi_dsi_detach(dsi);
+	drm_panel_remove(&ctx->panel);
+	x163qln_power_off(ctx);
+
+	return 0;
+}
+
+static void x163qln_shutdown(struct mipi_dsi_device *dsi)
+{
+	struct x163qln *ctx = mipi_dsi_get_drvdata(dsi);
+
+	x163qln_power_off(ctx);
+}
+
+static const struct of_device_id x163qln_of_match[] = {
+	{ .compatible = "auo,x163qln" },
+	{ }
+};
+
+MODULE_DEVICE_TABLE(of, x163qln_of_match);
+
+static struct mipi_dsi_driver x163qln_driver = {
+	.probe = x163qln_probe,
+	.remove = x163qln_remove,
+	.shutdown = x163qln_shutdown,
+	.driver = {
+		.name = "panel-auo-x163qln",
+		.of_match_table = x163qln_of_match,
+	},
+};
+module_mipi_dsi_driver(x163qln_driver);
+
+MODULE_AUTHOR("Danilo Sia <danilo.sia@kalpa.it>");
+MODULE_DESCRIPTION("MIPI-DSI based x163qln TFT LCD Panel Driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/input/touchscreen/Kconfig b/drivers/input/touchscreen/Kconfig
index ce5d433..ac225c3 100644
--- a/drivers/input/touchscreen/Kconfig
+++ b/drivers/input/touchscreen/Kconfig
@@ -473,6 +473,21 @@ config TOUCHSCREEN_EDT_FT5X06
 	  To compile this driver as a module, choose M here: the
 	  module will be called edt-ft5x06.
 
+config TOUCHSCREEN_KITRA_FT5X06
+	tristate "KITRA FocalTech FT5x06 I2C Touchscreen support"
+	depends on I2C
+	help
+	  Say Y here if you have a Polytouch touchscreen based
+	  on the FocalTech FT5x06 family of controllers connected to
+	  your system.
+
+	  If unsure, say N.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called ft5x06.
+
+
+
 config TOUCHSCREEN_MIGOR
 	tristate "Renesas MIGO-R touchscreen"
 	depends on SH_MIGOR && I2C
diff --git a/drivers/input/touchscreen/Makefile b/drivers/input/touchscreen/Makefile
index da16ca2..2765cab 100644
--- a/drivers/input/touchscreen/Makefile
+++ b/drivers/input/touchscreen/Makefile
@@ -24,6 +24,7 @@ obj-$(CONFIG_TOUCHSCREEN_DA9034)	+= da9034-ts.o
 obj-$(CONFIG_TOUCHSCREEN_DA9052)	+= da9052_tsi.o
 obj-$(CONFIG_TOUCHSCREEN_DYNAPRO)	+= dynapro.o
 obj-$(CONFIG_TOUCHSCREEN_EDT_FT5X06)	+= edt-ft5x06.o
+obj-$(CONFIG_TOUCHSCREEN_KITRA_FT5X06)	+= ft5x06.o
 obj-$(CONFIG_TOUCHSCREEN_HAMPSHIRE)	+= hampshire.o
 obj-$(CONFIG_TOUCHSCREEN_GUNZE)		+= gunze.o
 obj-$(CONFIG_TOUCHSCREEN_EETI)		+= eeti_ts.o
diff --git a/drivers/input/touchscreen/ft5x06.c b/drivers/input/touchscreen/ft5x06.c
new file mode 100644
index 0000000..2702e9d
--- /dev/null
+++ b/drivers/input/touchscreen/ft5x06.c
@@ -0,0 +1,3974 @@
+/*
+ *
+ * FocalTech ft5x06 TouchScreen driver.
+ *
+ * Copyright (c) 2010  Focal tech Ltd.
+ * Copyright (c) 2012-2014, The Linux Foundation. All rights reserved.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/i2c.h>
+#include <linux/input.h>
+#include <linux/input/mt.h>
+#include <linux/slab.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/gpio.h>
+#include <linux/of_gpio.h>
+#include <linux/regulator/consumer.h>
+#include <linux/firmware.h>
+#include <linux/debugfs.h>
+#include <linux/mutex.h>
+#include <linux/wait.h>
+#include <linux/time.h>
+#include <linux/workqueue.h>
+#include <linux/input/ft5x06_ts.h>
+
+#if defined(CONFIG_FB)
+#include <linux/notifier.h>
+#include <linux/fb.h>
+
+#elif defined(CONFIG_HAS_EARLYSUSPEND)
+#include <linux/earlysuspend.h>
+/* Early-suspend level */
+#define FT_SUSPEND_LEVEL 1
+#endif
+
+#ifdef CONFIG_TOUCHPANEL_PROXIMITY_SENSOR
+#include <linux/input-polldev.h>
+#include <linux/wakelock.h>
+#endif
+
+#define FT_DRIVER_VERSION	0x02
+
+#define FT_META_REGS		3
+#define FT_ONE_TCH_LEN		6
+#define FT_TCH_LEN(x)		(FT_META_REGS + FT_ONE_TCH_LEN * x)
+
+#define CFG_MAX_TOUCH_POINTS	10
+#define FT_PRESS		0x7F
+#define FT_MAX_ID		0x0F
+#define FT_TOUCH_X_H_POS	3
+#define FT_TOUCH_X_L_POS	4
+#define FT_TOUCH_Y_H_POS	5
+#define FT_TOUCH_Y_L_POS	6
+#define FT_TD_STATUS		2
+#define FT_TOUCH_EVENT_POS	3
+#define FT_TOUCH_ID_POS		5
+#define FT_TOUCH_DOWN		0
+#define FT_TOUCH_CONTACT	2
+
+#define POINT_READ_BUF	(3 + FT_ONE_TCH_LEN * CFG_MAX_TOUCH_POINTS)
+
+/*register address*/
+#define FT_REG_DEV_MODE		0x00
+#define FT_DEV_MODE_REG_CAL	0x02
+#define FT_REG_ID		0xA3
+#define FT_REG_PMODE		0xA5
+#define FT_REG_FW_VER		0xA6
+#define FT_REG_FW_VENDOR_ID	0xA8
+#define FT_REG_POINT_RATE	0x88
+#define FT_REG_THGROUP		0x80
+#define FT_REG_ECC		0xCC
+#define FT_REG_RESET_FW		0x07
+#define FT_REG_FW_MIN_VER	0xB2
+#define FT_REG_FW_SUB_MIN_VER	0xB3
+
+/* power register bits*/
+#define FT_PMODE_ACTIVE		0x00
+#define FT_PMODE_MONITOR	0x01
+#define FT_PMODE_STANDBY	0x02
+#define FT_PMODE_HIBERNATE	0x03
+#define FT_FACTORYMODE_VALUE	0x40
+#define FT_WORKMODE_VALUE	0x00
+#define FT_RST_CMD_REG1		0xFC
+#define FT_RST_CMD_REG2		0xBC
+#define FT_READ_ID_REG		0x90
+#define FT_ERASE_APP_REG	0x61
+#define FT_ERASE_PANEL_REG	0x63
+#define FT_FW_START_REG		0xBF
+
+#define FT_STATUS_NUM_TP_MASK	0x0F
+
+#define FT_VTG_MIN_UV		2600000
+#define FT_VTG_MAX_UV		3300000
+#define FT_I2C_VTG_MIN_UV	1800000
+#define FT_I2C_VTG_MAX_UV	1800000
+
+#define FT_COORDS_ARR_SIZE	4
+#define MAX_BUTTONS		4
+
+#define FT_8BIT_SHIFT		8
+#define FT_4BIT_SHIFT		4
+#define FT_FW_NAME_MAX_LEN	50
+
+#define FT5X16_ID		0x0A
+#define FT5X06_ID		0x55
+#define FT6X06_ID		0x06
+#define FT6X36_ID		0x36
+
+#define FT_UPGRADE_AA		0xAA
+#define FT_UPGRADE_55		0x55
+
+#define FT_FW_MIN_SIZE		8
+#define FT_FW_MAX_SIZE		(54 * 1024)
+
+/* Firmware file is not supporting minor and sub minor so use 0 */
+#define FT_FW_FILE_MAJ_VER(x)	((x)->data[(x)->size - 2])
+#define FT_FW_FILE_MIN_VER(x)	0
+#define FT_FW_FILE_SUB_MIN_VER(x) 0
+#define FT_FW_FILE_VENDOR_ID(x)	((x)->data[(x)->size - 1])
+
+#define FT_FW_FILE_MAJ_VER_FT6X36(x)	((x)->data[0x10a])
+#define FT_FW_FILE_VENDOR_ID_FT6X36(x)	((x)->data[0x108])
+
+/**
+* Application data verification will be run before upgrade flow.
+* Firmware image stores some flags with negative and positive value
+* in corresponding addresses, we need pick them out do some check to
+* make sure the application data is valid.
+*/
+#define FT_FW_CHECK(x, ts_data) \
+	(ts_data->family_id == FT6X36_ID ? \
+	(((x)->data[0x104] ^ (x)->data[0x105]) == 0xFF \
+	&& ((x)->data[0x106] ^ (x)->data[0x107]) == 0xFF) : \
+	(((x)->data[(x)->size - 8] ^ (x)->data[(x)->size - 6]) == 0xFF \
+	&& ((x)->data[(x)->size - 7] ^ (x)->data[(x)->size - 5]) == 0xFF \
+	&& ((x)->data[(x)->size - 3] ^ (x)->data[(x)->size - 4]) == 0xFF))
+
+#define FT_MAX_TRIES		5
+#define FT_RETRY_DLY		20
+
+#define FT_MAX_WR_BUF		10
+#define FT_MAX_RD_BUF		2
+#define FT_FW_PKT_LEN		128
+#define FT_FW_PKT_META_LEN	6
+#define FT_FW_PKT_DLY_MS	20
+#define FT_FW_LAST_PKT		0x6ffa
+#define FT_EARSE_DLY_MS		100
+#define FT_55_AA_DLY_NS		5000
+
+#define FT_UPGRADE_LOOP		30
+#define FT_CAL_START		0x04
+#define FT_CAL_FIN		0x00
+#define FT_CAL_STORE		0x05
+#define FT_CAL_RETRY		100
+#define FT_REG_CAL		0x00
+#define FT_CAL_MASK		0x70
+
+#define FT_INFO_MAX_LEN		512
+
+#define FT_BLOADER_SIZE_OFF	12
+#define FT_BLOADER_NEW_SIZE	30
+#define FT_DATA_LEN_OFF_OLD_FW	8
+#define FT_DATA_LEN_OFF_NEW_FW	14
+#define FT_FINISHING_PKT_LEN_OLD_FW	6
+#define FT_FINISHING_PKT_LEN_NEW_FW	12
+#define FT_MAGIC_BLOADER_Z7	0x7bfa
+#define FT_MAGIC_BLOADER_LZ4	0x6ffa
+#define FT_MAGIC_BLOADER_GZF_30	0x7ff4
+#define FT_MAGIC_BLOADER_GZF	0x7bf4
+
+#define PINCTRL_STATE_ACTIVE	"pmx_ts_active"
+#define PINCTRL_STATE_SUSPEND	"pmx_ts_suspend"
+#define PINCTRL_STATE_RELEASE	"pmx_ts_release"
+
+enum {
+	FT_BLOADER_VERSION_LZ4 = 0,
+	FT_BLOADER_VERSION_Z7 = 1,
+	FT_BLOADER_VERSION_GZF = 2,
+};
+
+enum {
+	FT_FT5336_FAMILY_ID_0x11 = 0x11,
+	FT_FT5336_FAMILY_ID_0x12 = 0x12,
+	FT_FT5336_FAMILY_ID_0x13 = 0x13,
+	FT_FT5336_FAMILY_ID_0x14 = 0x14,
+};
+
+struct Upgrade_Info {
+	u8 CHIP_ID;
+	u8 fts_NAME[20];
+	u8 TPD_MAX_POINTS;
+	u8 AUTO_CLB;
+	u16 delay_aa;		/*delay of write FT_UPGRADE_AA */
+	u16 delay_55;		/*delay of write FT_UPGRADE_55 */
+	u8 upgrade_id_1;	/*upgrade id 1 */
+	u8 upgrade_id_2;	/*upgrade id 2 */
+	u16 delay_readid;	/*delay of read id */
+	u16 delay_earse_flash; /*delay of earse flash*/
+};
+
+struct Upgrade_Info fts_updateinfo[] =
+{
+    {0x55,"FT5x06",TPD_MAX_POINTS_5,AUTO_CLB_NEED,50, 30, 0x79, 0x03, 10, 2000},
+    {0x08,"FT5606",TPD_MAX_POINTS_5,AUTO_CLB_NEED,50, 10, 0x79, 0x06, 100, 2000},
+	{0x0a,"FT5x16",TPD_MAX_POINTS_5,AUTO_CLB_NEED,50, 30, 0x79, 0x07, 10, 1500},
+	{0x06,"FT6x06",TPD_MAX_POINTS_2,AUTO_CLB_NONEED,100, 30, 0x79, 0x08, 10, 2000},
+	{0x36,"FT6x36",TPD_MAX_POINTS_2,AUTO_CLB_NONEED,10, 10, 0x79, 0x18, 10, 2000},
+	{0x55,"FT5x06i",TPD_MAX_POINTS_5,AUTO_CLB_NEED,50, 30, 0x79, 0x03, 10, 2000},
+	{0x14,"FT5336",TPD_MAX_POINTS_5,AUTO_CLB_NONEED,30, 30, 0x79, 0x11, 10, 2000},
+	{0x13,"FT3316",TPD_MAX_POINTS_5,AUTO_CLB_NONEED,30, 30, 0x79, 0x11, 10, 2000},
+	{0x12,"FT5436i",TPD_MAX_POINTS_5,AUTO_CLB_NONEED,30, 30, 0x79, 0x11, 10, 2000},
+	{0x11,"FT5336i",TPD_MAX_POINTS_5,AUTO_CLB_NONEED,30, 30, 0x79, 0x11, 10, 2000},
+	{0x54,"FT5x46",TPD_MAX_POINTS_5,AUTO_CLB_NONEED,2, 2, 0x54, 0x2c, 10, 2000},
+};
+
+//#define FTS_DBG
+#ifdef FTS_DBG
+#define DBG(fmt, args...) 				printk("[FTS]" fmt, ## args)
+#else
+#define DBG(fmt, args...) 				do{}while(0)
+#endif
+
+struct Upgrade_Info fts_updateinfo_curr;
+
+struct i2c_client *fts_i2c_client = NULL;
+
+//#define FTS_GESTRUE
+
+#ifdef FTS_GESTRUE
+#define  KEY_GESTURE_U		KEY_U
+#define  KEY_GESTURE_UP		KEY_UP
+#define  KEY_GESTURE_DOWN		KEY_DOWN
+#define  KEY_GESTURE_LEFT		KEY_LEFT 
+#define  KEY_GESTURE_RIGHT		KEY_RIGHT
+#define  KEY_GESTURE_O		KEY_O
+#define  KEY_GESTURE_E		KEY_E
+#define  KEY_GESTURE_M		KEY_M 
+#define  KEY_GESTURE_L		KEY_L
+#define  KEY_GESTURE_W		KEY_W
+#define  KEY_GESTURE_S		KEY_S 
+#define  KEY_GESTURE_V		KEY_V
+#define  KEY_GESTURE_Z		KEY_Z
+
+#define GESTURE_LEFT		0x20
+#define GESTURE_RIGHT		0x21
+#define GESTURE_UP		    0x22
+#define GESTURE_DOWN		0x23
+#define GESTURE_DOUBLECLICK	0x24
+#define GESTURE_O		    0x30
+#define GESTURE_W		    0x31
+#define GESTURE_M		    0x32
+#define GESTURE_E		    0x33
+#define GESTURE_L		    0x44
+#define GESTURE_S		    0x46
+#define GESTURE_V		    0x54
+#define GESTURE_Z		    0x41
+
+#define FTS_GESTRUE_POINTS 255
+#define FTS_GESTRUE_POINTS_ONETIME  62
+#define FTS_GESTRUE_POINTS_HEADER 8
+#define FTS_GESTURE_OUTPUT_ADRESS 0xD3
+#define FTS_GESTURE_OUTPUT_UNIT_LENGTH 4
+
+short pointnum = 0;
+unsigned short coordinate_x[150] = {0};
+unsigned short coordinate_y[150] = {0};
+#endif
+
+#define FT_STORE_TS_INFO(buf, id, name, max_tch, group_id, fw_vkey_support, \
+			fw_name, fw_maj, fw_min, fw_sub_min) \
+			snprintf(buf, FT_INFO_MAX_LEN, \
+				"controller\t= focaltech\n" \
+				"model\t\t= 0x%x\n" \
+				"name\t\t= %s\n" \
+				"max_touches\t= %d\n" \
+				"drv_ver\t\t= 0x%x\n" \
+				"group_id\t= 0x%x\n" \
+				"fw_vkey_support\t= %s\n" \
+				"fw_name\t\t= %s\n" \
+				"fw_ver\t\t= %d.%d.%d\n", id, name, \
+				max_tch, FT_DRIVER_VERSION, group_id, \
+				fw_vkey_support, fw_name, fw_maj, fw_min, \
+				fw_sub_min)
+
+#define FT_DEBUG_DIR_NAME	"ts_debug"
+
+struct ts_event {
+	u16 au16_x[TPD_MAX_POINTS_10];	/*x coordinate */
+	u16 au16_y[TPD_MAX_POINTS_10];	/*y coordinate */
+	u8 au8_touch_event[TPD_MAX_POINTS_10];	/*touch event:
+					0 -- down; 1-- up; 2 -- contact */
+	u8 au8_finger_id[TPD_MAX_POINTS_10];	/*touch ID */
+	u16 pressure;
+	u8 touch_point;
+	u8 point_num;
+};
+
+struct ft5x06_ts_data {
+	struct i2c_client *client;
+	struct input_dev *input_dev;
+	struct ts_event event;
+	const struct ft5x06_ts_platform_data *pdata;
+	struct work_struct 	touch_event_work;
+	struct workqueue_struct *ts_workqueue;
+	struct regulator *vdd;
+	struct regulator *vcc_i2c;
+	char fw_name[FT_FW_NAME_MAX_LEN];
+	bool loading_fw;
+	u8 family_id;
+	struct dentry *dir;
+	u16 addr;
+	bool suspended;
+	char *ts_info;
+	u8 *tch_data;
+	u32 tch_data_len;
+	u8 fw_ver[3];
+	u8 fw_vendor_id;
+	#ifdef CONFIG_TOUCHPANEL_PROXIMITY_SENSOR
+	struct input_dev  *input_prox_dev;
+	struct input_polled_dev *input_poll_dev;
+	#endif
+#if defined(CONFIG_FB)
+	struct notifier_block fb_notif;
+#elif defined(CONFIG_HAS_EARLYSUSPEND)
+	struct early_suspend early_suspend;
+#endif
+	struct pinctrl *ts_pinctrl;
+	struct pinctrl_state *pinctrl_state_active;
+	struct pinctrl_state *pinctrl_state_suspend;
+	struct pinctrl_state *pinctrl_state_release;
+};
+
+static struct ft5x06_ts_data *fts_wq_data;
+
+static DEFINE_MUTEX(i2c_rw_access);
+
+#ifdef CONFIG_TOUCHPANEL_PROXIMITY_SENSOR
+#define PROXIMITY_INPUT_DEV_NAME 	"proximity"
+
+#define SENSOR_PROX_TP_USE_WAKELOCK
+static struct i2c_client * i2c_prox_client = NULL;
+#ifdef SENSOR_PROX_TP_USE_WAKELOCK
+static struct wake_lock sensor_prox_tp_wake_lock;
+#endif
+static DEFINE_MUTEX(tp_prox_sensor_mutex);
+
+static int tp_prox_sensor_opened;
+static char tp_prox_sensor_data = 0; // 0 near 1 far
+static char tp_prox_sensor_data_changed = 0;
+static char tp_prox_pre_sensor_data = 1;
+
+static int is_suspend = 0;
+static int is_need_report_pointer = 1;
+
+static void tp_prox_sensor_enable(int enable);
+#endif
+
+static int ft5x06_i2c_read(struct i2c_client *client, char *writebuf,
+			   int writelen, char *readbuf, int readlen)
+{
+	int ret;
+
+	mutex_lock(&i2c_rw_access);
+	
+	if (writelen > 0) {
+		struct i2c_msg msgs[] = {
+			{
+				 .addr = client->addr,
+				 .flags = 0,
+				 .len = writelen,
+				 .buf = writebuf,
+			 },
+			{
+				 .addr = client->addr,
+				 .flags = I2C_M_RD,
+				 .len = readlen,
+				 .buf = readbuf,
+			 },
+		};
+		ret = i2c_transfer(client->adapter, msgs, 2);
+		if (ret < 0)
+			dev_err(&client->dev, "%s: i2c read error.\n",
+				__func__);
+	} else {
+		struct i2c_msg msgs[] = {
+			{
+				 .addr = client->addr,
+				 .flags = I2C_M_RD,
+				 .len = readlen,
+				 .buf = readbuf,
+			 },
+		};
+		ret = i2c_transfer(client->adapter, msgs, 1);
+		if (ret < 0)
+			dev_err(&client->dev, "%s:i2c read error.\n", __func__);
+	}
+
+	mutex_unlock(&i2c_rw_access);
+	
+	return ret;
+}
+
+static int ft5x06_i2c_write(struct i2c_client *client, char *writebuf,
+			    int writelen)
+{
+	int ret;
+
+	mutex_lock(&i2c_rw_access);
+	
+	struct i2c_msg msgs[] = {
+		{
+			 .addr = client->addr,
+			 .flags = 0,
+			 .len = writelen,
+			 .buf = writebuf,
+		 },
+	};
+	ret = i2c_transfer(client->adapter, msgs, 1);
+	if (ret < 0)
+		dev_err(&client->dev, "%s: i2c write error.\n", __func__);
+
+	mutex_unlock(&i2c_rw_access);
+	
+	return ret;
+}
+
+static int ft5x0x_write_reg(struct i2c_client *client, u8 addr, const u8 val)
+{
+	u8 buf[2] = {0};
+
+	buf[0] = addr;
+	buf[1] = val;
+
+	return ft5x06_i2c_write(client, buf, sizeof(buf));
+}
+
+static int ft5x0x_read_reg(struct i2c_client *client, u8 addr, u8 *val)
+{
+	return ft5x06_i2c_read(client, &addr, 1, val, 1);
+}
+
+static void ft5x06_update_fw_vendor_id(struct ft5x06_ts_data *data)
+{
+	struct i2c_client *client = data->client;
+	u8 reg_addr;
+	int err;
+
+	reg_addr = FT_REG_FW_VENDOR_ID;
+	err = ft5x06_i2c_read(client, &reg_addr, 1, &data->fw_vendor_id, 1);
+	if (err < 0)
+		dev_err(&client->dev, "fw vendor id read failed");
+}
+
+static void ft5x06_update_fw_ver(struct ft5x06_ts_data *data)
+{
+	struct i2c_client *client = data->client;
+	u8 reg_addr;
+	int err;
+
+	reg_addr = FT_REG_FW_VER;
+	err = ft5x06_i2c_read(client, &reg_addr, 1, &data->fw_ver[0], 1);
+	if (err < 0)
+		dev_err(&client->dev, "fw major version read failed");
+
+	reg_addr = FT_REG_FW_MIN_VER;
+	err = ft5x06_i2c_read(client, &reg_addr, 1, &data->fw_ver[1], 1);
+	if (err < 0)
+		dev_err(&client->dev, "fw minor version read failed");
+
+	reg_addr = FT_REG_FW_SUB_MIN_VER;
+	err = ft5x06_i2c_read(client, &reg_addr, 1, &data->fw_ver[2], 1);
+	if (err < 0)
+		dev_err(&client->dev, "fw sub minor version read failed");
+
+	dev_info(&client->dev, "Firmware version = %d.%d.%d\n",
+		data->fw_ver[0], data->fw_ver[1], data->fw_ver[2]);
+}
+
+#ifdef CONFIG_TOUCHPANEL_PROXIMITY_SENSOR
+static void tp_prox_sensor_enable(int enable)
+{
+	u8 state;
+	int ret = -1;
+
+    if(i2c_prox_client==NULL)
+    	return;
+
+
+	ft5x0x_read_reg(i2c_prox_client, 0xB0, &state);
+	DBG("[proxi_fts]read: 0xb0's value is 0x%02X\n", state);
+	if (enable){
+		state |= 0x01;
+	}else{
+		state &= 0x00;	
+	}
+	ret = ft5x0x_write_reg(i2c_prox_client, 0xB0, &state);
+	if(ret < 0)
+	{
+		DBG("[proxi_fts]write psensor switch command failed\n");
+	}
+	return;
+}
+
+static ssize_t tp_prox_enable_show(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	return snprintf(buf, 4, "%d\n", tp_prox_sensor_opened);
+}
+
+static ssize_t tp_prox_enable_store(struct device *dev,
+					struct device_attribute *attr,
+					const char *buf, size_t count)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct fts_data *prox = i2c_get_clientdata(client);
+	struct input_dev *input_dev = prox->input_prox_dev;
+	unsigned long data;
+	int error;
+
+	error = kstrtoul(buf, 10, &data);
+	if (error)
+		return error;
+	DBG("%s, data=%ld\n",__func__,data);
+	mutex_lock(&input_dev->mutex);
+	disable_irq(client->irq);
+
+	mutex_lock(&tp_prox_sensor_mutex);
+	tp_prox_sensor_enable((int)data);
+	if(data){
+		#ifdef SENSOR_PROX_TP_USE_WAKELOCK
+		wake_lock(&sensor_prox_tp_wake_lock);
+		#endif
+		tp_prox_sensor_opened = 1;
+		tp_prox_sensor_data = 1;
+		tp_prox_sensor_data_changed = 1;
+	}else{
+		tp_prox_sensor_opened = 0;
+		#ifdef SENSOR_PROX_TP_USE_WAKELOCK
+		wake_unlock(&sensor_prox_tp_wake_lock);
+		#endif
+	}
+	mutex_unlock(&tp_prox_sensor_mutex);
+
+	enable_irq(client->irq);
+	mutex_unlock(&input_dev->mutex);
+
+	return count;
+}
+
+static DEVICE_ATTR(enable, S_IRUGO|S_IWUSR|S_IWGRP|S_IWOTH,
+			tp_prox_enable_show, tp_prox_enable_store);
+
+/* Returns currently selected poll interval (in ms) */
+static ssize_t tp_prox_get_poll_delay(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct fts_data *ps = i2c_get_clientdata(client);
+
+	return sprintf(buf, "%d\n", ps->input_poll_dev->poll_interval);
+}
+
+/* Allow users to select a new poll interval (in ms) */
+static ssize_t tp_prox_set_poll_delay(struct device *dev,
+					struct device_attribute *attr,
+					const char *buf, size_t count)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct fts_data *ps = i2c_get_clientdata(client);
+	struct input_dev *input_dev = ps->input_prox_dev;
+	unsigned int interval;
+	int error;
+
+	error = kstrtouint(buf, 10, &interval);
+	if (error < 0)
+		return error;
+
+	/* Lock the device to prevent races with open/close (and itself) */
+	mutex_lock(&input_dev->mutex);
+
+	disable_irq(client->irq);
+
+	/*
+	 * Set current interval to the greater of the minimum interval or
+	 * the requested interval
+	 */
+	ps->input_poll_dev->poll_interval = max((int)interval,(int)ps->input_poll_dev->poll_interval_min);
+
+	enable_irq(client->irq);
+	mutex_unlock(&input_dev->mutex);
+
+	return count;
+}
+
+static DEVICE_ATTR(poll_delay, S_IRUGO|S_IWUSR|S_IWGRP|S_IWOTH,
+			tp_prox_get_poll_delay, tp_prox_set_poll_delay);
+
+static struct attribute *tp_prox_attributes[] = {
+	&dev_attr_enable.attr,
+	&dev_attr_poll_delay.attr,
+	NULL
+};
+
+static struct attribute_group tp_prox_attribute_group = {
+	.attrs = tp_prox_attributes
+};
+
+static void __devinit tp_prox_init_input_device(struct fts_data *prox,
+					      struct input_dev *input_dev)
+{
+	__set_bit(EV_ABS, input_dev->evbit);
+	input_set_abs_params(input_dev, ABS_DISTANCE, 0, 1, 0, 0);
+
+	input_dev->name = PROXIMITY_INPUT_DEV_NAME;
+	input_dev->id.bustype = BUS_I2C;
+	input_dev->dev.parent = &prox->client->dev;
+}
+
+static void tp_prox_poll(struct input_polled_dev *dev)
+{
+	struct fts_data *prox = dev->private;
+
+	if (tp_prox_sensor_data_changed){
+		mutex_lock(&tp_prox_sensor_mutex);
+		tp_prox_sensor_data_changed = 0;
+		mutex_unlock(&tp_prox_sensor_mutex);
+		DBG("%s poll tp_prox_sensor_data=%d\n",__func__,tp_prox_sensor_data);
+		input_report_abs(prox->input_prox_dev, ABS_DISTANCE, tp_prox_sensor_data);
+		input_sync(prox->input_prox_dev);
+	}
+}
+
+static int __devinit tp_prox_setup_polled_device(struct fts_data *ps)
+{
+	int err;
+	struct input_polled_dev *poll_dev;
+
+	poll_dev = input_allocate_polled_device();
+	if (!poll_dev) {
+		DBG("Failed to allocate polled device\n");
+		return -ENOMEM;
+	}
+
+	ps->input_poll_dev = poll_dev;
+	ps->input_prox_dev = poll_dev->input;
+
+	poll_dev->private = ps;
+	poll_dev->poll = tp_prox_poll;
+	//poll_dev->open = tp_prox_polled_input_open;
+	//poll_dev->close = tp_prox_polled_input_close;
+	poll_dev->poll_interval = 100;
+	poll_dev->poll_interval_min= 0;
+
+	tp_prox_init_input_device(ps, poll_dev->input);
+	err = input_register_polled_device(poll_dev);
+	DBG("%s, err=%d, poll-interval=%d\n",__func__,err,poll_dev->poll_interval);
+	if (err) {
+		DBG("Unable to register polled device, err=%d\n", err);
+		input_free_polled_device(poll_dev);
+		return -ENOMEM;
+	}
+
+	return 0;
+}
+
+static void tp_prox_teardown_polled_device(struct fts_data *ps)
+{
+	input_unregister_polled_device(ps->input_poll_dev);
+	input_free_polled_device(ps->input_poll_dev);
+}
+#endif
+
+#ifdef FTS_GESTRUE
+static void check_gesture(int gesture_id)
+{
+    printk("fts gesture_id==0x%x\n ",gesture_id);
+
+                switch(gesture_id)
+                {
+                        case GESTURE_LEFT:
+                                input_report_key(tpd->dev, KEY_GESTURE_LEFT, 1);
+                                input_sync(tpd->dev);
+                                input_report_key(tpd->dev, KEY_GESTURE_LEFT, 0);
+                                input_sync(tpd->dev);
+                                break;
+                        case GESTURE_RIGHT:
+                                input_report_key(tpd->dev, KEY_GESTURE_RIGHT, 1);
+                                input_sync(tpd->dev);
+                                input_report_key(tpd->dev, KEY_GESTURE_RIGHT, 0);
+                                input_sync(tpd->dev);
+                		    break;
+                        case GESTURE_UP:
+                                input_report_key(tpd->dev, KEY_GESTURE_UP, 1);
+                                input_sync(tpd->dev);
+                                input_report_key(tpd->dev, KEY_GESTURE_UP, 0);
+                                input_sync(tpd->dev);                                  
+                                break;
+                        case GESTURE_DOWN:
+                                input_report_key(tpd->dev, KEY_GESTURE_DOWN, 1);
+                                input_sync(tpd->dev);
+                                input_report_key(tpd->dev, KEY_GESTURE_DOWN, 0);
+                                input_sync(tpd->dev);
+                                break;
+                        case GESTURE_DOUBLECLICK:
+                                input_report_key(tpd->dev, KEY_GESTURE_U, 1);
+                                input_sync(tpd->dev);
+                                input_report_key(tpd->dev, KEY_GESTURE_U, 0);
+                                input_sync(tpd->dev);
+                                break;
+                        case GESTURE_O:
+                                input_report_key(tpd->dev, KEY_GESTURE_O, 1);
+                                input_sync(tpd->dev);
+                                input_report_key(tpd->dev, KEY_GESTURE_O, 0);
+                                input_sync(tpd->dev);
+                                break;
+                        case GESTURE_W:
+                                input_report_key(tpd->dev, KEY_GESTURE_W, 1);
+                                input_sync(tpd->dev);
+                                input_report_key(tpd->dev, KEY_GESTURE_W, 0);
+                                input_sync(tpd->dev);
+                                break;
+                        case GESTURE_M:
+                                input_report_key(tpd->dev, KEY_GESTURE_M, 1);
+                                input_sync(tpd->dev);
+                                input_report_key(tpd->dev, KEY_GESTURE_M, 0);
+                                input_sync(tpd->dev);
+                                break;
+                        case GESTURE_E:
+                                input_report_key(tpd->dev, KEY_GESTURE_E, 1);
+                                input_sync(tpd->dev);
+                                input_report_key(tpd->dev, KEY_GESTURE_E, 0);
+                                input_sync(tpd->dev);
+                                break;
+                        case GESTURE_L:
+                                input_report_key(tpd->dev, KEY_GESTURE_L, 1);
+                                input_sync(tpd->dev);
+                                input_report_key(tpd->dev, KEY_GESTURE_L, 0);
+                                input_sync(tpd->dev);
+                                break;
+                        case GESTURE_S:
+                                input_report_key(tpd->dev, KEY_GESTURE_S, 1);
+                                input_sync(tpd->dev);
+                                input_report_key(tpd->dev, KEY_GESTURE_S, 0);
+                                input_sync(tpd->dev);
+                                break;
+                        case GESTURE_V:
+                                input_report_key(tpd->dev, KEY_GESTURE_V, 1);
+                                input_sync(tpd->dev);
+                                input_report_key(tpd->dev, KEY_GESTURE_V, 0);
+                                input_sync(tpd->dev);
+                                break;
+                        case GESTURE_Z:
+                                input_report_key(tpd->dev, KEY_GESTURE_Z, 1);
+                                input_sync(tpd->dev);
+                                input_report_key(tpd->dev, KEY_GESTURE_Z, 0);
+                                input_sync(tpd->dev);
+                                break;
+                        default:
+                                break;
+                }
+
+}
+
+static int fts_read_Gestruedata(void)
+{
+    unsigned char buf[FTS_GESTRUE_POINTS * 3] = { 0 };
+    int ret = -1;
+    int i = 0;
+    buf[0] = 0xd3;
+    int gestrue_id = 0;
+
+    pointnum = 0;
+
+    ret = ft5x06_i2c_read(i2c_client, buf, 1, buf, FTS_GESTRUE_POINTS_HEADER);
+                printk( "tpd read FTS_GESTRUE_POINTS_HEADER.\n");
+
+    if (ret < 0)
+    {
+        printk( "%s read touchdata failed.\n", __func__);
+        return ret;
+    }
+
+	 gestrue_id = buf[0];
+	 pointnum = (short)(buf[1]) & 0xff;
+	 buf[0] = 0xd3;
+
+	 if((pointnum * 4 + 8)<255)
+	 {
+	    	 ret = ft5x06_i2c_read(i2c_client, buf, 1, buf, (pointnum * 4 + 8));
+	 }
+	 else
+	 {
+	        ret = ft5x06_i2c_read(i2c_client, buf, 1, buf, 255);
+	        ret = ft5x06_i2c_read(i2c_client, buf, 0, buf+255, (pointnum * 4 + 8) -255);
+	 }
+	 if (ret < 0)
+	 {
+	       printk( "%s read touchdata failed.\n", __func__);
+	       return ret;
+	 }
+	 check_gesture(gestrue_id);
+	 for(i = 0;i < pointnum;i++)
+	 {
+	    	coordinate_x[i] =  (((s16) buf[0 + (4 * i)]) & 0x0F) <<
+	        	8 | (((s16) buf[1 + (4 * i)])& 0xFF);
+	    	coordinate_y[i] = (((s16) buf[2 + (4 * i)]) & 0x0F) <<
+	        	8 | (((s16) buf[3 + (4 * i)]) & 0xFF);
+	 }
+	 return -1;
+}
+#endif
+static irqreturn_t ft5x06_ts_interrupt(int irq, void *dev_id)
+{
+	struct ft5x06_ts_data *fts_ts = dev_id;
+
+	if (!fts_ts) {
+		pr_err("%s: Invalid fts_ts\n", __func__);
+		return IRQ_HANDLED;
+	}
+
+	queue_work(fts_ts->ts_workqueue, &fts_ts->touch_event_work);
+
+	return IRQ_HANDLED;
+}
+
+static int fts_read_Touchdata(struct ft5x06_ts_data *data)
+{
+	struct ts_event *event = &data->event;
+	u8 buf[POINT_READ_BUF] = { 0 };
+	int ret = -1;
+	int i = 0;
+	u8 pointid = FT_MAX_ID;
+
+	u8 state;
+
+	#ifdef CONFIG_TOUCHPANEL_PROXIMITY_SENSOR
+	u8 proximity_status;
+	#endif
+
+	#ifdef CONFIG_TOUCHPANEL_PROXIMITY_SENSOR
+	if (tp_prox_sensor_opened == 1)
+	{
+		ft5x0x_read_reg(data->client, 0xB0, &state);
+		DBG("proxi_fts 0xB0 state value is 0x%02X\n", state);
+		if(!(state&0x01))
+		{
+			tp_prox_sensor_enable(1);
+		}
+		ft5x0x_read_reg(data->client, 0x01, &proximity_status);
+		DBG("proxi_fts value is 0x%02X\n", proximity_status);
+		tp_prox_pre_sensor_data = tp_prox_sensor_data;
+		if (proximity_status == 0xC0)  //near
+		{
+			tp_prox_sensor_data = 0;	
+		}
+		else if(proximity_status == 0xE0)  //far
+		{
+			tp_prox_sensor_data = 1;
+		}
+		 DBG( "%s tp_pre_sensor_data=%d,tp_prox_sensor_data=%d\n", __func__,tp_pre_sensor_data,tp_prox_sensor_data);
+	 	if( tp_prox_pre_sensor_data != tp_prox_sensor_data)
+	 	{  
+		    DBG( "%s ensor data changed\n", __func__);
+			mutex_lock(&tp_prox_sensor_mutex);
+	        tp_prox_sensor_data_changed = 1;
+	        mutex_unlock(&tp_prox_sensor_mutex);
+			return 1;
+	 	}
+		if(is_need_report_pointer == 0)
+		{
+			DBG( ":%s:  we don not report pointer when sleep in call\n", __func__);
+			return 1;
+		}
+		
+	}  
+	#endif
+
+	#ifdef FTS_GESTRUE
+	ft5x0x_read_reg(data->client, 0xB0, &state);
+       printk("tpd fts_read_Gestruedata state=%d\n",state);
+       if(state ==1)
+       {
+          fts_read_Gestruedata();
+	   return 1;
+      }
+      #endif
+	
+	ret = ft5x06_i2c_read(data->client, buf, 1, buf, POINT_READ_BUF);
+	if (ret < 0) {
+		dev_err(&data->client->dev, "%s read touchdata failed.\n",
+			__func__);
+		return ret;
+	}
+	memset(event, 0, sizeof(struct ts_event));
+
+	event->touch_point = 0;
+	for (i = 0; i < CFG_MAX_TOUCH_POINTS; i++) {
+		pointid = (buf[FT_TOUCH_ID_POS + FT_ONE_TCH_LEN * i]) >> 4;
+		if (pointid >= FT_MAX_ID)
+			break;
+		else
+			event->touch_point++;
+		event->au16_x[i] =
+		    (s16) (buf[FT_TOUCH_X_H_POS + FT_ONE_TCH_LEN * i] & 0x0F) <<
+		    8 | (s16) buf[FT_TOUCH_X_L_POS + FT_ONE_TCH_LEN * i];
+		event->au16_y[i] =
+		    (s16) (buf[FT_TOUCH_Y_H_POS + FT_ONE_TCH_LEN * i] & 0x0F) <<
+		    8 | (s16) buf[FT_TOUCH_Y_L_POS + FT_ONE_TCH_LEN * i];
+		event->au8_touch_event[i] =
+		    buf[FT_TOUCH_EVENT_POS + FT_ONE_TCH_LEN * i] >> 6;
+		event->au8_finger_id[i] =
+		    (buf[FT_TOUCH_ID_POS + FT_ONE_TCH_LEN * i]) >> 4;
+	}
+
+	event->pressure = FT_PRESS;
+
+	return 0;
+}
+
+static void fts_report_value(struct ft5x06_ts_data *data)
+{
+	struct ts_event *event = &data->event;
+	int i;
+	int uppoint = 0;
+
+	/*protocol B*/	
+	for (i = 0; i < event->touch_point; i++)
+	{
+		input_mt_slot(data->input_dev, event->au8_finger_id[i]);
+		
+		if (event->au8_touch_event[i]== 0 || event->au8_touch_event[i] == 2)
+		{
+			input_mt_report_slot_state(data->input_dev, MT_TOOL_FINGER,
+				true);
+			input_report_abs(data->input_dev, ABS_MT_TOUCH_MAJOR,
+					event->pressure);
+			input_report_abs(data->input_dev, ABS_MT_POSITION_X,
+					event->au16_x[i]);
+			input_report_abs(data->input_dev, ABS_MT_POSITION_Y,
+					event->au16_y[i]);
+		}
+		else
+		{
+			uppoint++;
+			input_mt_report_slot_state(data->input_dev, MT_TOOL_FINGER,
+				false);
+		}
+	}
+	if(event->touch_point == uppoint)
+		input_report_key(data->input_dev, BTN_TOUCH, 0);
+	else
+		input_report_key(data->input_dev, BTN_TOUCH, event->touch_point > 0);
+	input_sync(data->input_dev);
+
+
+}
+
+static void fts_touch_irq_work(struct work_struct *work)
+{
+	int ret = -1;
+	
+	ret = fts_read_Touchdata(fts_wq_data);
+	if (ret == 0)
+		fts_report_value(fts_wq_data);
+	
+	//enable_irq(fts_wq_data->client->irq);
+}
+
+static int ft5x06_gpio_configure(struct ft5x06_ts_data *data, bool on)
+{
+	int err = 0;
+
+	if (on) {
+		if (gpio_is_valid(data->pdata->irq_gpio)) {
+			err = gpio_request(data->pdata->irq_gpio,
+						"ft5x06_irq_gpio");
+			if (err) {
+				dev_err(&data->client->dev,
+					"irq gpio request failed");
+				goto err_irq_gpio_req;
+			}
+
+			err = gpio_direction_input(data->pdata->irq_gpio);
+			if (err) {
+				dev_err(&data->client->dev,
+					"set_direction for irq gpio failed\n");
+				goto err_irq_gpio_dir;
+			}
+		}
+
+		if (gpio_is_valid(data->pdata->reset_gpio)) {
+			err = gpio_request(data->pdata->reset_gpio,
+						"ft5x06_reset_gpio");
+			if (err) {
+				dev_err(&data->client->dev,
+					"reset gpio request failed");
+				goto err_irq_gpio_dir;
+			}
+
+			err = gpio_direction_output(data->pdata->reset_gpio, 0);
+			if (err) {
+				dev_err(&data->client->dev,
+				"set_direction for reset gpio failed\n");
+				goto err_reset_gpio_dir;
+			}
+			msleep(data->pdata->hard_rst_dly);
+			gpio_set_value_cansleep(data->pdata->reset_gpio, 1);
+		}
+
+		return 0;
+	} else {
+		if (gpio_is_valid(data->pdata->irq_gpio))
+			gpio_free(data->pdata->irq_gpio);
+		if (gpio_is_valid(data->pdata->reset_gpio)) {
+			/*
+			 * This is intended to save leakage current
+			 * only. Even if the call(gpio_direction_input)
+			 * fails, only leakage current will be more but
+			 * functionality will not be affected.
+			 */
+			err = gpio_direction_input(data->pdata->reset_gpio);
+			if (err) {
+				dev_err(&data->client->dev,
+					"unable to set direction for gpio "
+					"[%d]\n", data->pdata->irq_gpio);
+			}
+			gpio_free(data->pdata->reset_gpio);
+		}
+
+		return 0;
+	}
+
+err_reset_gpio_dir:
+	if (gpio_is_valid(data->pdata->reset_gpio))
+		gpio_free(data->pdata->reset_gpio);
+err_irq_gpio_dir:
+	if (gpio_is_valid(data->pdata->irq_gpio))
+		gpio_free(data->pdata->irq_gpio);
+err_irq_gpio_req:
+	return err;
+}
+
+static int ft5x06_power_on(struct ft5x06_ts_data *data, bool on)
+{
+	int rc;
+    return 0;
+
+	if (!on)
+		goto power_off;
+
+	rc = regulator_enable(data->vdd);
+	if (rc) {
+		dev_err(&data->client->dev,
+			"Regulator vdd enable failed rc=%d\n", rc);
+		return rc;
+	}
+
+	rc = regulator_enable(data->vcc_i2c);
+	if (rc) {
+		dev_err(&data->client->dev,
+			"Regulator vcc_i2c enable failed rc=%d\n", rc);
+		regulator_disable(data->vdd);
+	}
+
+	return rc;
+
+power_off:
+	rc = regulator_disable(data->vdd);
+	if (rc) {
+		dev_err(&data->client->dev,
+			"Regulator vdd disable failed rc=%d\n", rc);
+		return rc;
+	}
+
+	rc = regulator_disable(data->vcc_i2c);
+	if (rc) {
+		dev_err(&data->client->dev,
+			"Regulator vcc_i2c disable failed rc=%d\n", rc);
+		rc = regulator_enable(data->vdd);
+		if (rc) {
+			dev_err(&data->client->dev,
+				"Regulator vdd enable failed rc=%d\n", rc);
+		}
+	}
+
+	return rc;
+}
+
+static int ft5x06_power_init(struct ft5x06_ts_data *data, bool on)
+{
+	int rc;
+    return 0;
+	if (!on)
+		goto pwr_deinit;
+
+	data->vdd = regulator_get(&data->client->dev, "vdd");
+	if (IS_ERR(data->vdd)) {
+		rc = PTR_ERR(data->vdd);
+		dev_err(&data->client->dev,
+			"Regulator get failed vdd rc=%d\n", rc);
+		return rc;
+	}
+
+	if (regulator_count_voltages(data->vdd) > 0) {
+		rc = regulator_set_voltage(data->vdd, FT_VTG_MIN_UV,
+					   FT_VTG_MAX_UV);
+		if (rc) {
+			dev_err(&data->client->dev,
+				"Regulator set_vtg failed vdd rc=%d\n", rc);
+			goto reg_vdd_put;
+		}
+	}
+
+	data->vcc_i2c = regulator_get(&data->client->dev, "vcc_i2c");
+	if (IS_ERR(data->vcc_i2c)) {
+		rc = PTR_ERR(data->vcc_i2c);
+		dev_err(&data->client->dev,
+			"Regulator get failed vcc_i2c rc=%d\n", rc);
+		goto reg_vdd_set_vtg;
+	}
+
+	if (regulator_count_voltages(data->vcc_i2c) > 0) {
+		rc = regulator_set_voltage(data->vcc_i2c, FT_I2C_VTG_MIN_UV,
+					   FT_I2C_VTG_MAX_UV);
+		if (rc) {
+			dev_err(&data->client->dev,
+			"Regulator set_vtg failed vcc_i2c rc=%d\n", rc);
+			goto reg_vcc_i2c_put;
+		}
+	}
+
+	return 0;
+
+reg_vcc_i2c_put:
+	regulator_put(data->vcc_i2c);
+reg_vdd_set_vtg:
+	if (regulator_count_voltages(data->vdd) > 0)
+		regulator_set_voltage(data->vdd, 0, FT_VTG_MAX_UV);
+reg_vdd_put:
+	regulator_put(data->vdd);
+	return rc;
+
+pwr_deinit:
+	if (regulator_count_voltages(data->vdd) > 0)
+		regulator_set_voltage(data->vdd, 0, FT_VTG_MAX_UV);
+
+	regulator_put(data->vdd);
+
+	if (regulator_count_voltages(data->vcc_i2c) > 0)
+		regulator_set_voltage(data->vcc_i2c, 0, FT_I2C_VTG_MAX_UV);
+
+	regulator_put(data->vcc_i2c);
+	return 0;
+}
+
+static int ft5x06_ts_pinctrl_init(struct ft5x06_ts_data *ft5x06_data)
+{
+	int retval;
+
+	/* Get pinctrl if target uses pinctrl */
+	ft5x06_data->ts_pinctrl = devm_pinctrl_get(&(ft5x06_data->client->dev));
+	if (IS_ERR_OR_NULL(ft5x06_data->ts_pinctrl)) {
+		retval = PTR_ERR(ft5x06_data->ts_pinctrl);
+		dev_dbg(&ft5x06_data->client->dev,
+			"Target does not use pinctrl %d\n", retval);
+		goto err_pinctrl_get;
+	}
+
+	ft5x06_data->pinctrl_state_active
+		= pinctrl_lookup_state(ft5x06_data->ts_pinctrl,
+				PINCTRL_STATE_ACTIVE);
+	if (IS_ERR_OR_NULL(ft5x06_data->pinctrl_state_active)) {
+		retval = PTR_ERR(ft5x06_data->pinctrl_state_active);
+		dev_err(&ft5x06_data->client->dev,
+			"Can not lookup %s pinstate %d\n",
+			PINCTRL_STATE_ACTIVE, retval);
+		goto err_pinctrl_lookup;
+	}
+
+	ft5x06_data->pinctrl_state_suspend
+		= pinctrl_lookup_state(ft5x06_data->ts_pinctrl,
+			PINCTRL_STATE_SUSPEND);
+	if (IS_ERR_OR_NULL(ft5x06_data->pinctrl_state_suspend)) {
+		retval = PTR_ERR(ft5x06_data->pinctrl_state_suspend);
+		dev_err(&ft5x06_data->client->dev,
+			"Can not lookup %s pinstate %d\n",
+			PINCTRL_STATE_SUSPEND, retval);
+		goto err_pinctrl_lookup;
+	}
+
+	ft5x06_data->pinctrl_state_release
+		= pinctrl_lookup_state(ft5x06_data->ts_pinctrl,
+			PINCTRL_STATE_RELEASE);
+	if (IS_ERR_OR_NULL(ft5x06_data->pinctrl_state_release)) {
+		retval = PTR_ERR(ft5x06_data->pinctrl_state_release);
+		dev_dbg(&ft5x06_data->client->dev,
+			"Can not lookup %s pinstate %d\n",
+			PINCTRL_STATE_RELEASE, retval);
+	}
+
+	return 0;
+
+err_pinctrl_lookup:
+	devm_pinctrl_put(ft5x06_data->ts_pinctrl);
+err_pinctrl_get:
+	ft5x06_data->ts_pinctrl = NULL;
+	return retval;
+}
+
+#ifdef CONFIG_PM
+static int ft5x06_ts_suspend(struct device *dev)
+{
+	struct ft5x06_ts_data *data = dev_get_drvdata(dev);
+	char txbuf[2], i;
+	int err;
+
+	#ifdef CONFIG_TOUCHPANEL_PROXIMITY_SENSOR
+	if(tp_prox_sensor_opened){
+		DBG("tp can not sleep in call\n");
+		is_need_report_pointer = 0;
+		return;
+	}
+	#endif
+
+	#ifdef FTS_GESTRUE
+                ft5x0x_write_reg(fts_i2c_client, 0xd0, 0x01);
+		  if (fts_updateinfo_curr.CHIP_ID==0x54)
+		  {
+		  	ft5x0x_write_reg(i2c_client, 0xd1, 0xff);
+			ft5x0x_write_reg(i2c_client, 0xd2, 0xff);
+			ft5x0x_write_reg(i2c_client, 0xd5, 0xff);
+			ft5x0x_write_reg(i2c_client, 0xd6, 0xff);
+			ft5x0x_write_reg(i2c_client, 0xd7, 0xff);
+			ft5x0x_write_reg(i2c_client, 0xd8, 0xff);
+		  }
+
+	data->suspended = true;
+	
+        return;
+	#endif
+	
+	if (data->loading_fw) {
+		dev_info(dev, "Firmware loading in process...\n");
+		return 0;
+	}
+
+	if (data->suspended) {
+		dev_info(dev, "Already in suspend state\n");
+		return 0;
+	}
+
+	disable_irq(data->client->irq);
+
+	/* release all touches */
+	for (i = 0; i < data->pdata->num_max_touches; i++) {
+		input_mt_slot(data->input_dev, i);
+		input_mt_report_slot_state(data->input_dev, MT_TOOL_FINGER, 0);
+	}
+	input_mt_report_pointer_emulation(data->input_dev, false);
+	input_sync(data->input_dev);
+
+	if (gpio_is_valid(data->pdata->reset_gpio)) {
+		txbuf[0] = FT_REG_PMODE;
+		txbuf[1] = FT_PMODE_HIBERNATE;
+		ft5x06_i2c_write(data->client, txbuf, sizeof(txbuf));
+	}
+
+	if (data->pdata->power_on) {
+		err = data->pdata->power_on(false);
+		if (err) {
+			dev_err(dev, "power off failed");
+			goto pwr_off_fail;
+		}
+	} else {
+		err = ft5x06_power_on(data, false);
+		if (err) {
+			dev_err(dev, "power off failed");
+			goto pwr_off_fail;
+		}
+	}
+
+	if (data->ts_pinctrl) {
+		err = pinctrl_select_state(data->ts_pinctrl,
+					data->pinctrl_state_suspend);
+		if (err < 0)
+			dev_err(dev, "Cannot get suspend pinctrl state\n");
+	}
+
+	err = ft5x06_gpio_configure(data, false);
+	if (err < 0) {
+		dev_err(&data->client->dev,
+			"failed to put gpios in suspend state\n");
+		goto gpio_configure_fail;
+	}
+
+	data->suspended = true;
+
+	#ifdef CONFIG_TOUCHPANEL_PROXIMITY_SENSOR
+	is_suspend = 1;
+	#endif
+	
+	return 0;
+
+gpio_configure_fail:
+	if (data->ts_pinctrl) {
+		err = pinctrl_select_state(data->ts_pinctrl,
+					data->pinctrl_state_active);
+		if (err < 0)
+			dev_err(dev, "Cannot get active pinctrl state\n");
+	}
+	if (data->pdata->power_on) {
+		err = data->pdata->power_on(true);
+		if (err)
+			dev_err(dev, "power on failed");
+	} else {
+		err = ft5x06_power_on(data, true);
+		if (err)
+			dev_err(dev, "power on failed");
+	}
+pwr_off_fail:
+	if (gpio_is_valid(data->pdata->reset_gpio)) {
+		gpio_set_value_cansleep(data->pdata->reset_gpio, 0);
+		msleep(data->pdata->hard_rst_dly);
+		gpio_set_value_cansleep(data->pdata->reset_gpio, 1);
+	}
+	enable_irq(data->client->irq);
+	return err;
+}
+
+static int ft5x06_ts_resume(struct device *dev)
+{
+	struct ft5x06_ts_data *data = dev_get_drvdata(dev);
+	int err;
+
+	if (!data->suspended) {
+		dev_dbg(dev, "Already in awake state\n");
+		return 0;
+	}
+
+	#ifdef CONFIG_TOUCHPANEL_PROXIMITY_SENSOR
+	is_need_report_pointer = 1;
+	if((tp_prox_sensor_opened) && (is_suspend == 0)){
+		DBG("%s tp no need to wake up in call\n",__func__);
+		return;
+	}
+	#endif
+	
+	if (data->pdata->power_on) {
+		err = data->pdata->power_on(true);
+		if (err) {
+			dev_err(dev, "power on failed");
+			return err;
+		}
+	} else {
+		err = ft5x06_power_on(data, true);
+		if (err) {
+			dev_err(dev, "power on failed");
+			return err;
+		}
+	}
+
+	if (data->ts_pinctrl) {
+		err = pinctrl_select_state(data->ts_pinctrl,
+				data->pinctrl_state_active);
+		if (err < 0)
+			dev_err(dev, "Cannot get active pinctrl state\n");
+	}
+
+	err = ft5x06_gpio_configure(data, true);
+	if (err < 0) {
+		dev_err(&data->client->dev,
+			"failed to put gpios in resue state\n");
+		goto err_gpio_configuration;
+	}
+
+	if (gpio_is_valid(data->pdata->reset_gpio)) {
+		gpio_set_value_cansleep(data->pdata->reset_gpio, 0);
+		msleep(data->pdata->hard_rst_dly);
+		gpio_set_value_cansleep(data->pdata->reset_gpio, 1);
+	}
+
+	msleep(data->pdata->soft_rst_dly);
+
+	enable_irq(data->client->irq);
+
+	data->suspended = false;
+
+	#ifdef CONFIG_TOUCHPANEL_PROXIMITY_SENSOR
+	is_suspend = 0;
+	#endif
+
+	 #ifdef FTS_GESTRUE
+                   ft5x0x_write_reg(fts_i2c_client,0xD0,0x00);
+        #endif
+	
+	return 0;
+
+err_gpio_configuration:
+	if (data->ts_pinctrl) {
+		err = pinctrl_select_state(data->ts_pinctrl,
+					data->pinctrl_state_suspend);
+		if (err < 0)
+			dev_err(dev, "Cannot get suspend pinctrl state\n");
+	}
+	if (data->pdata->power_on) {
+		err = data->pdata->power_on(false);
+		if (err)
+			dev_err(dev, "power off failed");
+	} else {
+		err = ft5x06_power_on(data, false);
+		if (err)
+			dev_err(dev, "power off failed");
+	}
+	return err;
+}
+
+static const struct dev_pm_ops ft5x06_ts_pm_ops = {
+#if (!defined(CONFIG_FB) && !defined(CONFIG_HAS_EARLYSUSPEND))
+	.suspend = ft5x06_ts_suspend,
+	.resume = ft5x06_ts_resume,
+#endif
+};
+
+#else
+static int ft5x06_ts_suspend(struct device *dev)
+{
+	return 0;
+}
+
+static int ft5x06_ts_resume(struct device *dev)
+{
+	return 0;
+}
+
+#endif
+
+#if defined(CONFIG_FB)
+static int fb_notifier_callback(struct notifier_block *self,
+				 unsigned long event, void *data)
+{
+	struct fb_event *evdata = data;
+	int *blank;
+	struct ft5x06_ts_data *ft5x06_data =
+		container_of(self, struct ft5x06_ts_data, fb_notif);
+
+	if (evdata && evdata->data && event == FB_EVENT_BLANK &&
+			ft5x06_data && ft5x06_data->client) {
+		blank = evdata->data;
+		if (*blank == FB_BLANK_UNBLANK)
+			ft5x06_ts_resume(&ft5x06_data->client->dev);
+		else if (*blank == FB_BLANK_POWERDOWN)
+			ft5x06_ts_suspend(&ft5x06_data->client->dev);
+	}
+
+	return 0;
+}
+#elif defined(CONFIG_HAS_EARLYSUSPEND)
+static void ft5x06_ts_early_suspend(struct early_suspend *handler)
+{
+	struct ft5x06_ts_data *data = container_of(handler,
+						   struct ft5x06_ts_data,
+						   early_suspend);
+
+	ft5x06_ts_suspend(&data->client->dev);
+}
+
+static void ft5x06_ts_late_resume(struct early_suspend *handler)
+{
+	struct ft5x06_ts_data *data = container_of(handler,
+						   struct ft5x06_ts_data,
+						   early_suspend);
+
+	ft5x06_ts_resume(&data->client->dev);
+}
+#endif
+
+void focaltech_get_upgrade_array(struct i2c_client *i2c_client)
+{
+
+	u8 chip_id;
+	u32 i;
+	u8 temp = FT_REG_ID;
+
+	ft5x06_i2c_read(i2c_client,&temp,1,&chip_id,1);
+
+	printk("%s chip_id = %x\n", __func__, chip_id);
+
+	for(i=0;i<sizeof(fts_updateinfo)/sizeof(struct Upgrade_Info);i++)
+	{
+		if(chip_id==fts_updateinfo[i].CHIP_ID)
+		{
+			memcpy(&fts_updateinfo_curr, &fts_updateinfo[i], sizeof(struct Upgrade_Info));
+			break;
+		}
+	}
+
+	if(i >= sizeof(fts_updateinfo)/sizeof(struct Upgrade_Info))
+	{
+		memcpy(&fts_updateinfo_curr, &fts_updateinfo[0], sizeof(struct Upgrade_Info));
+	}
+}
+
+int fts_6x36_ctpm_fw_upgrade(struct i2c_client *client, u8 *pbt_buf,
+			  u32 dw_lenth)
+{
+	u8 reg_val[2] = {0};
+	u32 i = 0;
+	u32 packet_number;
+	u32 j;
+	u32 temp;
+	u32 lenght;
+	u32 fw_length;
+	u8 packet_buf[FT_FW_PKT_LEN + 6];
+	u8 auc_i2c_write_buf[10];
+	u8 bt_ecc;
+	int i_ret;
+
+
+	if(pbt_buf[0] != 0x02)
+	{
+		DBG("[FTS] FW first byte is not 0x02. so it is invalid \n");
+		return -1;
+	}
+
+	if(dw_lenth > 0x11f)
+	{
+		fw_length = ((u32)pbt_buf[0x100]<<8) + pbt_buf[0x101];
+		if(dw_lenth < fw_length)
+		{
+			DBG("[FTS] Fw length is invalid \n");
+			return -1;
+		}
+	}
+	else
+	{
+		DBG("[FTS] Fw length is invalid \n");
+		return -1;
+	}
+	
+	for (i = 0; i < FT_UPGRADE_LOOP; i++) {
+		/*********Step 1:Reset  CTPM *****/
+		/*write 0xaa to register 0xbc */
+		
+		ft5x0x_write_reg(client, 0xbc, FT_UPGRADE_AA);
+		msleep(fts_updateinfo_curr.delay_aa);
+
+		/*write 0x55 to register 0xbc */
+		ft5x0x_write_reg(client, 0xbc, FT_UPGRADE_55);
+
+		msleep(fts_updateinfo_curr.delay_55);
+
+		/*********Step 2:Enter upgrade mode *****/
+		auc_i2c_write_buf[0] = FT_UPGRADE_55;
+		ft5x06_i2c_write(client, auc_i2c_write_buf, 1);
+
+		auc_i2c_write_buf[0] = FT_UPGRADE_AA;
+		ft5x06_i2c_write(client, auc_i2c_write_buf, 1);
+		msleep(fts_updateinfo_curr.delay_readid);
+
+		/*********Step 3:check READ-ID***********************/		
+		auc_i2c_write_buf[0] = 0x90;
+		auc_i2c_write_buf[1] = auc_i2c_write_buf[2] = auc_i2c_write_buf[3] =
+			0x00;
+		reg_val[0] = 0x00;
+		reg_val[1] = 0x00;
+		ft5x06_i2c_read(client, auc_i2c_write_buf, 4, reg_val, 2);
+
+
+		if (reg_val[0] == fts_updateinfo_curr.upgrade_id_1
+			&& reg_val[1] == fts_updateinfo_curr.upgrade_id_2) {
+			DBG("[FTS] Step 3: GET CTPM ID OK,ID1 = 0x%x,ID2 = 0x%x\n",
+				reg_val[0], reg_val[1]);
+			break;
+		} else {
+			dev_err(&client->dev, "[FTS] Step 3: GET CTPM ID FAIL,ID1 = 0x%x,ID2 = 0x%x\n",
+				reg_val[0], reg_val[1]);
+		}
+	}
+	if (i >= FT_UPGRADE_LOOP)
+		return -EIO;
+
+	auc_i2c_write_buf[0] = 0x90;
+	auc_i2c_write_buf[1] = 0x00;
+	auc_i2c_write_buf[2] = 0x00;
+	auc_i2c_write_buf[3] = 0x00;
+	auc_i2c_write_buf[4] = 0x00;
+	ft5x06_i2c_write(client, auc_i2c_write_buf, 5);
+	
+	//auc_i2c_write_buf[0] = 0xcd;
+	//ft5x06_i2c_read(client, auc_i2c_write_buf, 1, reg_val, 1);
+
+
+	/*Step 4:erase app and panel paramenter area*/
+	DBG("Step 4:erase app and panel paramenter area\n");
+	auc_i2c_write_buf[0] = 0x61;
+	ft5x06_i2c_write(client, auc_i2c_write_buf, 1);	/*erase app area */
+	msleep(fts_updateinfo_curr.delay_earse_flash);
+
+	for(i = 0;i < 200;i++)
+	{
+		auc_i2c_write_buf[0] = 0x6a;
+		auc_i2c_write_buf[1] = 0x00;
+		auc_i2c_write_buf[2] = 0x00;
+		auc_i2c_write_buf[3] = 0x00;
+		reg_val[0] = 0x00;
+		reg_val[1] = 0x00;
+		ft5x06_i2c_read(client, auc_i2c_write_buf, 4, reg_val, 2);
+		if(0xb0 == reg_val[0] && 0x02 == reg_val[1])
+		{
+			DBG("[FTS] erase app finished \n");
+			break;
+		}
+		msleep(50);
+	}
+
+	/*********Step 5:write firmware(FW) to ctpm flash*********/
+	bt_ecc = 0;
+	DBG("Step 5:write firmware(FW) to ctpm flash\n");
+
+	dw_lenth = fw_length;
+	packet_number = (dw_lenth) / FT_FW_PKT_LEN;
+	packet_buf[0] = 0xbf;
+	packet_buf[1] = 0x00;
+
+	for (j = 0; j < packet_number; j++) {
+		temp = j * FT_FW_PKT_LEN;
+		packet_buf[2] = (u8) (temp >> 8);
+		packet_buf[3] = (u8) temp;
+		lenght = FT_FW_PKT_LEN;
+		packet_buf[4] = (u8) (lenght >> 8);
+		packet_buf[5] = (u8) lenght;
+
+		for (i = 0; i < FT_FW_PKT_LEN; i++) {
+			packet_buf[6 + i] = pbt_buf[j * FT_FW_PKT_LEN + i];
+			bt_ecc ^= packet_buf[6 + i];
+		}
+		
+		ft5x06_i2c_write(client, packet_buf, FT_FW_PKT_LEN + 6);
+		
+		for(i = 0;i < 30;i++)
+		{
+			auc_i2c_write_buf[0] = 0x6a;
+			auc_i2c_write_buf[1] = 0x00;
+			auc_i2c_write_buf[2] = 0x00;
+			auc_i2c_write_buf[3] = 0x00;
+			reg_val[0] = 0x00;
+			reg_val[1] = 0x00;
+			ft5x06_i2c_read(client, auc_i2c_write_buf, 4, reg_val, 2);
+			if(0xb0 == (reg_val[0] & 0xf0) && (0x03 + (j % 0x0ffd)) == (((reg_val[0] & 0x0f) << 8) |reg_val[1]))
+			{
+				DBG("[FTS] write a block data finished \n");
+				break;
+			}
+			msleep(1);
+		}
+	}
+
+	if ((dw_lenth) % FT_FW_PKT_LEN > 0) {
+		temp = packet_number * FT_FW_PKT_LEN;
+		packet_buf[2] = (u8) (temp >> 8);
+		packet_buf[3] = (u8) temp;
+		temp = (dw_lenth) % FT_FW_PKT_LEN;
+		packet_buf[4] = (u8) (temp >> 8);
+		packet_buf[5] = (u8) temp;
+
+		for (i = 0; i < temp; i++) {
+			packet_buf[6 + i] = pbt_buf[packet_number * FT_FW_PKT_LEN + i];
+			bt_ecc ^= packet_buf[6 + i];
+		}
+
+		ft5x06_i2c_write(client, packet_buf, temp + 6);
+
+		for(i = 0;i < 30;i++)
+		{
+			auc_i2c_write_buf[0] = 0x6a;
+			auc_i2c_write_buf[1] = 0x00;
+			auc_i2c_write_buf[2] = 0x00;
+			auc_i2c_write_buf[3] = 0x00;
+			reg_val[0] = 0x00;
+			reg_val[1] = 0x00;
+			ft5x06_i2c_read(client, auc_i2c_write_buf, 4, reg_val, 2);
+			if(0xb0 == (reg_val[0] & 0xf0) && (0x03 + (j % 0x0ffd)) == (((reg_val[0] & 0x0f) << 8) |reg_val[1]))
+			{
+				DBG("[FTS] write a block data finished \n");
+				break;
+			}
+			msleep(1);
+		}
+	}
+
+
+	/*********Step 6: read out checksum***********************/
+	/*send the opration head */
+	DBG("Step 6: read out checksum\n");
+	auc_i2c_write_buf[0] = 0xcc;
+	ft5x06_i2c_read(client, auc_i2c_write_buf, 1, reg_val, 1);
+	if (reg_val[0] != bt_ecc) {
+		dev_err(&client->dev, "[FTS]--ecc error! FW=%02x bt_ecc=%02x\n",
+					reg_val[0],
+					bt_ecc);
+		return -EIO;
+	}
+
+	/*********Step 7: reset the new FW***********************/
+	DBG("Step 7: reset the new FW\n");
+	auc_i2c_write_buf[0] = 0x07;
+	ft5x06_i2c_write(client, auc_i2c_write_buf, 1);
+	msleep(300);	/*make sure CTP startup normally */
+
+	return 0;
+}
+
+int fts_6x06_ctpm_fw_upgrade(struct i2c_client *client, u8 *pbt_buf, u32 dw_lenth)
+{
+	u8 reg_val[2] = {0};
+	u32 i = 0;
+	u32 packet_number;
+	u32 j;
+	u32 temp;
+	u32 lenght;
+	u8 packet_buf[FT_FW_PKT_LEN + 6];
+	u8 auc_i2c_write_buf[10];
+	u8 bt_ecc;
+	int i_ret;
+
+	
+	for (i = 0; i < FT_UPGRADE_LOOP; i++) {
+		/*********Step 1:Reset  CTPM *****/
+		/*write 0xaa to register 0xbc */
+		
+		ft5x0x_write_reg(client, 0xbc, FT_UPGRADE_AA);
+		msleep(fts_updateinfo_curr.delay_aa);
+
+		/*write 0x55 to register 0xbc */
+		ft5x0x_write_reg(client, 0xbc, FT_UPGRADE_55);
+
+		msleep(fts_updateinfo_curr.delay_55);
+
+		/*********Step 2:Enter upgrade mode *****/
+		auc_i2c_write_buf[0] = FT_UPGRADE_55;
+		auc_i2c_write_buf[1] = FT_UPGRADE_AA;
+		do {
+			i++;
+			i_ret = ft5x06_i2c_write(client, auc_i2c_write_buf, 2);
+			msleep(5);
+		} while (i_ret <= 0 && i < 5);
+
+
+		/*********Step 3:check READ-ID***********************/
+		msleep(fts_updateinfo_curr.delay_readid);
+		auc_i2c_write_buf[0] = 0x90;
+		auc_i2c_write_buf[1] = auc_i2c_write_buf[2] = auc_i2c_write_buf[3] =
+			0x00;
+		ft5x06_i2c_read(client, auc_i2c_write_buf, 4, reg_val, 2);
+
+
+		if (reg_val[0] == fts_updateinfo_curr.upgrade_id_1
+			&& reg_val[1] == fts_updateinfo_curr.upgrade_id_2) {
+			DBG("[FTS] Step 3: CTPM ID OK ,ID1 = 0x%x,ID2 = 0x%x\n",
+				reg_val[0], reg_val[1]);
+			break;
+		} else {
+			dev_err(&client->dev, "[FTS] Step 3: CTPM ID FAIL,ID1 = 0x%x,ID2 = 0x%x\n",
+				reg_val[0], reg_val[1]);
+		}
+	}
+	if (i > FT_UPGRADE_LOOP)
+		return -EIO;
+	auc_i2c_write_buf[0] = 0xcd;
+
+	ft5x06_i2c_read(client, auc_i2c_write_buf, 1, reg_val, 1);
+
+
+	/*Step 4:erase app and panel paramenter area*/
+	DBG("Step 4:erase app and panel paramenter area\n");
+	auc_i2c_write_buf[0] = 0x61;
+	ft5x06_i2c_write(client, auc_i2c_write_buf, 1);	/*erase app area */
+	msleep(fts_updateinfo_curr.delay_earse_flash);
+	/*erase panel parameter area */
+	auc_i2c_write_buf[0] = 0x63;
+	ft5x06_i2c_write(client, auc_i2c_write_buf, 1);
+	msleep(100);
+
+	/*********Step 5:write firmware(FW) to ctpm flash*********/
+	bt_ecc = 0;
+	DBG("Step 5:write firmware(FW) to ctpm flash\n");
+
+	dw_lenth = dw_lenth - 8;
+	packet_number = (dw_lenth) / FT_FW_PKT_LEN;
+	packet_buf[0] = 0xbf;
+	packet_buf[1] = 0x00;
+
+	for (j = 0; j < packet_number; j++) {
+		temp = j * FT_FW_PKT_LEN;
+		packet_buf[2] = (u8) (temp >> 8);
+		packet_buf[3] = (u8) temp;
+		lenght = FT_FW_PKT_LEN;
+		packet_buf[4] = (u8) (lenght >> 8);
+		packet_buf[5] = (u8) lenght;
+
+		for (i = 0; i < FT_FW_PKT_LEN; i++) {
+			packet_buf[6 + i] = pbt_buf[j * FT_FW_PKT_LEN + i];
+			bt_ecc ^= packet_buf[6 + i];
+		}
+		
+		ft5x06_i2c_write(client, packet_buf, FT_FW_PKT_LEN + 6);
+		msleep(FT_FW_PKT_LEN / 6 + 1);
+	}
+
+	if ((dw_lenth) % FT_FW_PKT_LEN > 0) {
+		temp = packet_number * FT_FW_PKT_LEN;
+		packet_buf[2] = (u8) (temp >> 8);
+		packet_buf[3] = (u8) temp;
+		temp = (dw_lenth) % FT_FW_PKT_LEN;
+		packet_buf[4] = (u8) (temp >> 8);
+		packet_buf[5] = (u8) temp;
+
+		for (i = 0; i < temp; i++) {
+			packet_buf[6 + i] = pbt_buf[packet_number * FT_FW_PKT_LEN + i];
+			bt_ecc ^= packet_buf[6 + i];
+		}
+
+		ft5x06_i2c_write(client, packet_buf, temp + 6);
+		msleep(20);
+	}
+
+
+	/*send the last six byte */
+	for (i = 0; i < 6; i++) {
+		temp = 0x6ffa + i;
+		packet_buf[2] = (u8) (temp >> 8);
+		packet_buf[3] = (u8) temp;
+		temp = 1;
+		packet_buf[4] = (u8) (temp >> 8);
+		packet_buf[5] = (u8) temp;
+		packet_buf[6] = pbt_buf[dw_lenth + i];
+		bt_ecc ^= packet_buf[6];
+		ft5x06_i2c_write(client, packet_buf, 7);
+		msleep(20);
+	}
+
+
+	/*********Step 6: read out checksum***********************/
+	/*send the opration head */
+	DBG("Step 6: read out checksum\n");
+	auc_i2c_write_buf[0] = 0xcc;
+	ft5x06_i2c_read(client, auc_i2c_write_buf, 1, reg_val, 1);
+	if (reg_val[0] != bt_ecc) {
+		dev_err(&client->dev, "[FTS]--ecc error! FW=%02x bt_ecc=%02x\n",
+					reg_val[0],
+					bt_ecc);
+		return -EIO;
+	}
+
+	/*********Step 7: reset the new FW***********************/
+	DBG("Step 7: reset the new FW\n");
+	auc_i2c_write_buf[0] = 0x07;
+	ft5x06_i2c_write(client, auc_i2c_write_buf, 1);
+	msleep(300);	/*make sure CTP startup normally */
+
+	return 0;
+}
+
+int fts_5x36_ctpm_fw_upgrade(struct i2c_client *client, u8 *pbt_buf, u32 dw_lenth)
+{
+	u8 reg_val[2] = {0};
+	u32 i = 0;
+	u8 is_5336_new_bootloader = 0;
+	u8 is_5336_fwsize_30 = 0;
+	u32  packet_number;
+	u32  j;
+	u32  temp;
+	u32  lenght;
+	u8 	packet_buf[FT_FW_PKT_LEN + 6];
+	u8  	auc_i2c_write_buf[10];
+	u8  	bt_ecc;
+#if 0
+    int	i_ret;
+	int	fw_filenth = sizeof(CTPM_FW);
+
+	if(CTPM_FW[fw_filenth-12] == 30)
+	{
+		is_5336_fwsize_30 = 1;
+	}
+	else 
+	{
+		is_5336_fwsize_30 = 0;
+	}
+
+	for (i = 0; i < FT_UPGRADE_LOOP; i++) {
+    	/*********Step 1:Reset  CTPM *****/
+    	/*write 0xaa to register 0xfc*/
+		/*write 0xaa to register 0xfc*/
+	   	ft5x0x_write_reg(client, 0xfc, FT_UPGRADE_AA);
+		msleep(fts_updateinfo_curr.delay_aa);
+		
+		 /*write 0x55 to register 0xfc*/
+		ft5x0x_write_reg(client, 0xfc, FT_UPGRADE_55);   
+		msleep(fts_updateinfo_curr.delay_55);   
+
+
+		/*********Step 2:Enter upgrade mode *****/
+		auc_i2c_write_buf[0] = FT_UPGRADE_55;
+		auc_i2c_write_buf[1] = FT_UPGRADE_AA;
+		
+	    i_ret = ft5x06_i2c_write(client, auc_i2c_write_buf, 2);
+	  
+	    /*********Step 3:check READ-ID***********************/   
+		msleep(fts_updateinfo_curr.delay_readid);
+	   	auc_i2c_write_buf[0] = 0x90; 
+		auc_i2c_write_buf[1] = auc_i2c_write_buf[2] = auc_i2c_write_buf[3] = 0x00;
+              ft5x06_i2c_read(client, auc_i2c_write_buf, 4, reg_val, 2);           
+              if (reg_val[0] == fts_updateinfo_curr.upgrade_id_1 
+                              && reg_val[1] == fts_updateinfo_curr.upgrade_id_2)
+              {
+                      dev_dbg(&client->dev, "[FTS] Step 3: CTPM ID OK,ID1 = 0x%x,ID2 = 0x%x\n",reg_val[0],reg_val[1]); 
+                      break; 
+              }
+              else
+              {
+                      dev_err(&client->dev, "[FTS] Step 3: CTPM ID FAILD,ID1 = 0x%x,ID2 = 0x%x\n",reg_val[0],reg_val[1]);
+                      continue;
+              }
+
+          }
+
+          if (i >= FT_UPGRADE_LOOP)
+                          return -EIO;
+		  
+         auc_i2c_write_buf[0] = 0xcd;
+         ft5x06_i2c_read(client, auc_i2c_write_buf, 1, reg_val, 1);
+
+	/*********20130705 mshl ********************/
+	if (reg_val[0] <= 4)
+	{
+		is_5336_new_bootloader = BL_VERSION_LZ4 ;
+	}
+	else if(reg_val[0] == 7)
+	{
+		is_5336_new_bootloader = BL_VERSION_Z7 ;
+	}
+	else if(reg_val[0] >= 0x0f)
+	{
+		is_5336_new_bootloader = BL_VERSION_GZF ;
+	}
+
+     /*********Step 4:erase app and panel paramenter area ********************/
+	if(is_5336_fwsize_30)
+	{
+		auc_i2c_write_buf[0] = 0x61;
+		ft5x06_i2c_write(client, auc_i2c_write_buf, 1); /*erase app area*/	
+   		 msleep(fts_updateinfo_curr.delay_earse_flash); 
+
+		 auc_i2c_write_buf[0] = 0x63;
+		ft5x06_i2c_write(client, auc_i2c_write_buf, 1); /*erase config area*/	
+   		 msleep(50);
+	}
+	else
+	{
+		auc_i2c_write_buf[0] = 0x61;
+		ft5x06_i2c_write(client, auc_i2c_write_buf, 1); /*erase app area*/	
+   		msleep(fts_updateinfo_curr.delay_earse_flash); 
+	}
+
+	/*********Step 5:write firmware(FW) to ctpm flash*********/
+	bt_ecc = 0;
+
+	if(is_5336_new_bootloader == BL_VERSION_LZ4 || is_5336_new_bootloader == BL_VERSION_Z7 )
+	{
+		dw_lenth = dw_lenth - 8;
+	}
+	else if(is_5336_new_bootloader == BL_VERSION_GZF) dw_lenth = dw_lenth - 14;
+	packet_number = (dw_lenth) / FT_FW_PKT_LEN;
+	packet_buf[0] = 0xbf;
+	packet_buf[1] = 0x00;
+	for (j=0;j<packet_number;j++)
+	{
+		temp = j * FT_FW_PKT_LEN;
+		packet_buf[2] = (u8)(temp>>8);
+		packet_buf[3] = (u8)temp;
+		lenght = FT_FW_PKT_LEN;
+		packet_buf[4] = (u8)(lenght>>8);
+		packet_buf[5] = (u8)lenght;
+
+		for (i=0;i<FT_FW_PKT_LEN;i++)
+		{
+		    packet_buf[6+i] = pbt_buf[j*FT_FW_PKT_LEN + i]; 
+		    bt_ecc ^= packet_buf[6+i];
+		}
+
+		ft5x06_i2c_write(client, packet_buf, FT_FW_PKT_LEN+6);
+		msleep(FT_FW_PKT_LEN/6 + 1);
+	}
+
+	if ((dw_lenth) % FT_FW_PKT_LEN > 0)
+	{
+		temp = packet_number * FT_FW_PKT_LEN;
+		packet_buf[2] = (u8)(temp>>8);
+		packet_buf[3] = (u8)temp;
+
+		temp = (dw_lenth) % FT_FW_PKT_LEN;
+		packet_buf[4] = (u8)(temp>>8);
+		packet_buf[5] = (u8)temp;
+
+		for (i=0;i<temp;i++)
+		{
+		    packet_buf[6+i] = pbt_buf[ packet_number*FT_FW_PKT_LEN + i]; 
+		    bt_ecc ^= packet_buf[6+i];
+		}
+  
+		ft5x06_i2c_write(client, packet_buf, temp+6);
+		msleep(20);
+	}
+        /*send the last six byte*/
+        if(is_5336_new_bootloader == BL_VERSION_LZ4 || is_5336_new_bootloader == BL_VERSION_Z7 )
+        {
+                for (i = 0; i<6; i++)
+                {
+                                if (is_5336_new_bootloader  == BL_VERSION_Z7 /*&& DEVICE_IC_TYPE==IC_FT5x36*/) 
+                                {
+                                                temp = 0x7bfa + i;
+                                }
+                                else if(is_5336_new_bootloader == BL_VERSION_LZ4)
+                                {
+                                                temp = 0x6ffa + i;
+                                }
+                                packet_buf[2] = (u8)(temp>>8);
+                                packet_buf[3] = (u8)temp;
+                                temp =1;
+                                packet_buf[4] = (u8)(temp>>8);
+                                packet_buf[5] = (u8)temp;
+                                packet_buf[6] = pbt_buf[ dw_lenth + i]; 
+                                bt_ecc ^= packet_buf[6];
+                                ft5x06_i2c_write(client, packet_buf, 7);
+                                msleep(10);
+                }
+        }
+        else if(is_5336_new_bootloader == BL_VERSION_GZF)
+        {
+		for (i = 0; i<12; i++)
+		{
+		        if (is_5336_fwsize_30 /*&& DEVICE_IC_TYPE==IC_FT5x36*/) 
+		        {
+		                        temp = 0x7ff4 + i;
+		        }
+		        else if (1/*DEVICE_IC_TYPE==IC_FT5x36*/) 
+		        {
+		                        temp = 0x7bf4 + i;
+		        }
+		        packet_buf[2] = (u8)(temp>>8);
+		        packet_buf[3] = (u8)temp;
+		        temp =1;
+		        packet_buf[4] = (u8)(temp>>8);
+		        packet_buf[5] = (u8)temp;
+		        packet_buf[6] = pbt_buf[ dw_lenth + i]; 
+		        bt_ecc ^= packet_buf[6];
+			ft5x06_i2c_write(client, packet_buf, 7);
+			msleep(10);
+		}
+	}
+
+	/*********Step 6: read out checksum***********************/
+	/*send the opration head*/
+	auc_i2c_write_buf[0] = 0xcc;
+	ft5x06_i2c_read(client, auc_i2c_write_buf, 1, reg_val, 1); 
+
+	if(reg_val[0] != bt_ecc)
+	{
+		dev_err(&client->dev, "[FTS]--ecc error! FW=%02x bt_ecc=%02x\n", reg_val[0], bt_ecc);
+	    	return -EIO;
+	}
+
+	/*********Step 7: reset the new FW***********************/
+	auc_i2c_write_buf[0] = 0x07;
+	ft5x06_i2c_write(client, auc_i2c_write_buf, 1);
+	msleep(300);  /*make sure CTP startup normally*/
+#endif
+	return 0;
+}
+
+int fts_5x06_ctpm_fw_upgrade(struct i2c_client *client, u8 *pbt_buf, u32 dw_lenth)
+{
+	u8 reg_val[2] = {0};
+	u32 i = 0;
+	u32 packet_number;
+	u32 j;
+	u32 temp;
+	u32 lenght;
+	u8 packet_buf[FT_FW_PKT_LEN + 6];
+	u8 auc_i2c_write_buf[10];
+	u8 bt_ecc;
+	int i_ret;
+	
+	for (i = 0; i < FT_UPGRADE_LOOP; i++) {
+		/*********Step 1:Reset  CTPM *****/
+		/*write 0xaa to register 0xfc */
+		ft5x0x_write_reg(client, 0xfc, FT_UPGRADE_AA);
+		msleep(fts_updateinfo_curr.delay_aa);
+
+		/*write 0x55 to register 0xfc */
+		ft5x0x_write_reg(client, 0xfc, FT_UPGRADE_55);
+		msleep(fts_updateinfo_curr.delay_55);
+		/*********Step 2:Enter upgrade mode *****/
+		auc_i2c_write_buf[0] = FT_UPGRADE_55;
+		auc_i2c_write_buf[1] = FT_UPGRADE_AA;
+		do {
+			i++;
+			i_ret = ft5x06_i2c_write(client, auc_i2c_write_buf, 2);
+			msleep(5);
+		} while (i_ret <= 0 && i < 5);
+
+
+		/*********Step 3:check READ-ID***********************/
+		msleep(fts_updateinfo_curr.delay_readid);
+		auc_i2c_write_buf[0] = 0x90;
+		auc_i2c_write_buf[1] = auc_i2c_write_buf[2] = auc_i2c_write_buf[3] =
+			0x00;
+		ft5x06_i2c_read(client, auc_i2c_write_buf, 4, reg_val, 2);
+
+
+		if (reg_val[0] == fts_updateinfo_curr.upgrade_id_1
+			&& reg_val[1] == fts_updateinfo_curr.upgrade_id_2) {
+			DBG("[FTS] Step 3: CTPM ID OK,ID1 = 0x%x,ID2 = 0x%x\n",
+				reg_val[0], reg_val[1]);
+			break;
+		} else {
+			dev_err(&client->dev, "[FTS] Step 3: CTPM ID FAIL,ID1 = 0x%x,ID2 = 0x%x\n",
+				reg_val[0], reg_val[1]);
+		}
+	}
+	if (i >= FT_UPGRADE_LOOP)
+		return -EIO;
+	/*Step 4:erase app and panel paramenter area*/
+	DBG("Step 4:erase app and panel paramenter area\n");
+	auc_i2c_write_buf[0] = 0x61;
+	ft5x06_i2c_write(client, auc_i2c_write_buf, 1);	/*erase app area */
+	msleep(fts_updateinfo_curr.delay_earse_flash);
+	/*erase panel parameter area */
+	auc_i2c_write_buf[0] = 0x63;
+	ft5x06_i2c_write(client, auc_i2c_write_buf, 1);
+	msleep(100);
+
+	/*********Step 5:write firmware(FW) to ctpm flash*********/
+	bt_ecc = 0;
+	DBG("Step 5:write firmware(FW) to ctpm flash\n");
+
+	dw_lenth = dw_lenth - 8;
+	packet_number = (dw_lenth) / FT_FW_PKT_LEN;
+	packet_buf[0] = 0xbf;
+	packet_buf[1] = 0x00;
+
+	for (j = 0; j < packet_number; j++) {
+		temp = j * FT_FW_PKT_LEN;
+		packet_buf[2] = (u8) (temp >> 8);
+		packet_buf[3] = (u8) temp;
+		lenght = FT_FW_PKT_LEN;
+		packet_buf[4] = (u8) (lenght >> 8);
+		packet_buf[5] = (u8) lenght;
+
+		for (i = 0; i < FT_FW_PKT_LEN; i++) {
+			packet_buf[6 + i] = pbt_buf[j * FT_FW_PKT_LEN + i];
+			bt_ecc ^= packet_buf[6 + i];
+		}
+		
+		ft5x06_i2c_write(client, packet_buf, FT_FW_PKT_LEN + 6);
+		msleep(FT_FW_PKT_LEN / 6 + 1);
+	}
+
+	if ((dw_lenth) % FT_FW_PKT_LEN > 0) {
+		temp = packet_number * FT_FW_PKT_LEN;
+		packet_buf[2] = (u8) (temp >> 8);
+		packet_buf[3] = (u8) temp;
+		temp = (dw_lenth) % FT_FW_PKT_LEN;
+		packet_buf[4] = (u8) (temp >> 8);
+		packet_buf[5] = (u8) temp;
+
+		for (i = 0; i < temp; i++) {
+			packet_buf[6 + i] = pbt_buf[packet_number * FT_FW_PKT_LEN + i];
+			bt_ecc ^= packet_buf[6 + i];
+		}
+
+		ft5x06_i2c_write(client, packet_buf, temp + 6);
+		msleep(20);
+	}
+
+
+	/*send the last six byte */
+	for (i = 0; i < 6; i++) {
+		temp = 0x6ffa + i;
+		packet_buf[2] = (u8) (temp >> 8);
+		packet_buf[3] = (u8) temp;
+		temp = 1;
+		packet_buf[4] = (u8) (temp >> 8);
+		packet_buf[5] = (u8) temp;
+		packet_buf[6] = pbt_buf[dw_lenth + i];
+		bt_ecc ^= packet_buf[6];
+		ft5x06_i2c_write(client, packet_buf, 7);
+		msleep(20);
+	}
+
+
+	/*********Step 6: read out checksum***********************/
+	/*send the opration head */
+	DBG("Step 6: read out checksum\n");
+	auc_i2c_write_buf[0] = 0xcc;
+	ft5x06_i2c_read(client, auc_i2c_write_buf, 1, reg_val, 1);
+	if (reg_val[0] != bt_ecc) {
+		dev_err(&client->dev, "[FTS]--ecc error! FW=%02x bt_ecc=%02x\n",
+					reg_val[0],
+					bt_ecc);
+		return -EIO;
+	}
+		
+	/*********Step 7: reset the new FW***********************/
+	DBG("Step 7: reset the new FW\n");
+	auc_i2c_write_buf[0] = 0x07;
+	ft5x06_i2c_write(client, auc_i2c_write_buf, 1);
+	msleep(300);	/*make sure CTP startup normally */
+	return 0;
+}
+
+int hid_to_i2c(struct i2c_client * client)
+{
+	u8 auc_i2c_write_buf[5] = {0};
+	int bRet = 0;
+
+	auc_i2c_write_buf[0] = 0xeb;
+	auc_i2c_write_buf[1] = 0xaa;
+	auc_i2c_write_buf[2] = 0x09;
+
+	ft5x06_i2c_write(client, auc_i2c_write_buf, 3);
+
+	msleep(10);
+
+	auc_i2c_write_buf[0] = auc_i2c_write_buf[1] = auc_i2c_write_buf[2] = 0;
+
+	ft5x06_i2c_read(client, auc_i2c_write_buf, 0, auc_i2c_write_buf, 3);
+
+	if(0xeb==auc_i2c_write_buf[0] && 0xaa==auc_i2c_write_buf[1] && 0x08==auc_i2c_write_buf[2])
+	{
+		bRet = 1;		
+	}
+	else bRet = 0;
+
+	return bRet;
+	
+}
+
+int  fts_5x46_ctpm_fw_upgrade(struct i2c_client * client, u8* pbt_buf, u32 dw_lenth)
+{
+	
+	u8 reg_val[4] = {0};
+	u32 i = 0;
+	u32 packet_number;
+	u32 j;
+	u32 temp;
+	u32 lenght;
+	u8 packet_buf[FT_FW_PKT_LEN + 6];
+	u8 auc_i2c_write_buf[10];
+	u8 bt_ecc;
+	int i_ret;
+
+	i_ret = hid_to_i2c(client);
+
+	if(i_ret == 0)
+	{
+		DBG("[FTS] hid change to i2c fail ! \n");
+	}
+
+	for (i = 0; i < FT_UPGRADE_LOOP; i++) {
+		/*********Step 1:Reset  CTPM *****/
+		/*write 0xaa to register 0xfc */
+		ft5x0x_write_reg(client, 0xfc, FT_UPGRADE_AA);
+		msleep(fts_updateinfo_curr.delay_aa);
+
+		//write 0x55 to register 0xfc 
+		ft5x0x_write_reg(client, 0xfc, FT_UPGRADE_55);
+		msleep(200);
+		/*********Step 2:Enter upgrade mode *****/
+		i_ret = hid_to_i2c(client);
+
+		if(i_ret == 0)
+		{
+			DBG("[FTS] hid change to i2c fail ! \n");
+		}
+		msleep(10);
+		auc_i2c_write_buf[0] = FT_UPGRADE_55;
+		auc_i2c_write_buf[1] = FT_UPGRADE_AA;
+		i_ret = ft5x06_i2c_write(client, auc_i2c_write_buf, 2);
+		if(i_ret < 0)
+		{
+			DBG("[FTS] failed writing  0x55 and 0xaa ! \n");
+			continue;
+		}
+
+		/*********Step 3:check READ-ID***********************/
+		msleep(1);
+		auc_i2c_write_buf[0] = 0x90;
+		auc_i2c_write_buf[1] = auc_i2c_write_buf[2] = auc_i2c_write_buf[3] =
+			0x00;
+		
+		reg_val[0] = reg_val[1] = 0x00;
+		
+		ft5x06_i2c_read(client, auc_i2c_write_buf, 4, reg_val, 2);
+
+		if (reg_val[0] == fts_updateinfo_curr.upgrade_id_1
+			&& reg_val[1] == fts_updateinfo_curr.upgrade_id_2) {
+			DBG("[FTS] Step 3: READ OK CTPM ID,ID1 = 0x%x,ID2 = 0x%x\n",
+				reg_val[0], reg_val[1]);
+			break;
+		} else {
+			dev_err(&client->dev, "[FTS] Step 3: CTPM ID,ID1 = 0x%x,ID2 = 0x%x\n",
+				reg_val[0], reg_val[1]);
+			
+			continue;
+		}
+	}
+	if (i >= FT_UPGRADE_LOOP )
+		return -EIO;
+
+	/*Step 4:erase app and panel paramenter area*/
+	DBG("Step 4:erase app and panel paramenter area\n");
+	auc_i2c_write_buf[0] = 0x61;
+	ft5x06_i2c_write(client, auc_i2c_write_buf, 1);	//erase app area 
+	msleep(1350);
+
+	for(i = 0;i < 15;i++)
+	{
+		auc_i2c_write_buf[0] = 0x6a;
+		reg_val[0] = reg_val[1] = 0x00;
+		ft5x06_i2c_read(client, auc_i2c_write_buf, 1, reg_val, 2);
+
+		if(0xF0==reg_val[0] && 0xAA==reg_val[1])
+		{
+			break;
+		}
+		msleep(50);
+		
+	}
+
+	auc_i2c_write_buf[0] = 0xB0;
+	auc_i2c_write_buf[1] = (u8) ((dw_lenth >> 16) & 0xFF);
+	auc_i2c_write_buf[2] = (u8) ((dw_lenth >> 8) & 0xFF);
+	auc_i2c_write_buf[3] = (u8) (dw_lenth & 0xFF);
+
+	ft5x06_i2c_write(client, auc_i2c_write_buf, 4);
+
+	/*********Step 5:write firmware(FW) to ctpm flash*********/
+	bt_ecc = 0;
+	DBG("Step 5:write firmware(FW) to ctpm flash\n");
+	temp = 0;
+	packet_number = (dw_lenth) / FT_FW_PKT_LEN;
+	packet_buf[0] = 0xbf;
+	packet_buf[1] = 0x00;
+
+	for (j = 0; j < packet_number; j++) {
+		temp = j * FT_FW_PKT_LEN;
+		packet_buf[2] = (u8) (temp >> 8);
+		packet_buf[3] = (u8) temp;
+		lenght = FT_FW_PKT_LEN;
+		packet_buf[4] = (u8) (lenght >> 8);
+		packet_buf[5] = (u8) lenght;
+
+		for (i = 0; i < FT_FW_PKT_LEN; i++) {
+			packet_buf[6 + i] = pbt_buf[j * FT_FW_PKT_LEN + i];
+			bt_ecc ^= packet_buf[6 + i];
+		}
+		ft5x06_i2c_write(client, packet_buf, FT_FW_PKT_LEN + 6);
+
+		for(i = 0;i < 30;i++)
+		{
+			auc_i2c_write_buf[0] = 0x6a;
+			reg_val[0] = reg_val[1] = 0x00;
+			ft5x06_i2c_read(client, auc_i2c_write_buf, 1, reg_val, 2);
+
+			if ((j + 0x1000) == (((reg_val[0]) << 8) | reg_val[1]))
+			{
+				break;
+			}
+			msleep(1);
+			
+		}
+	}
+
+	if ((dw_lenth) % FT_FW_PKT_LEN > 0) {
+		temp = packet_number * FT_FW_PKT_LEN;
+		packet_buf[2] = (u8) (temp >> 8);
+		packet_buf[3] = (u8) temp;
+		temp = (dw_lenth) % FT_FW_PKT_LEN;
+		packet_buf[4] = (u8) (temp >> 8);
+		packet_buf[5] = (u8) temp;
+
+		for (i = 0; i < temp; i++) {
+			packet_buf[6 + i] = pbt_buf[packet_number * FT_FW_PKT_LEN + i];
+			bt_ecc ^= packet_buf[6 + i];
+		}	
+		ft5x06_i2c_write(client, packet_buf, temp + 6);
+
+		for(i = 0;i < 30;i++)
+		{
+			auc_i2c_write_buf[0] = 0x6a;
+			reg_val[0] = reg_val[1] = 0x00;
+			ft5x06_i2c_read(client, auc_i2c_write_buf, 1, reg_val, 2);
+
+			if ((j + 0x1000) == (((reg_val[0]) << 8) | reg_val[1]))
+			{
+				break;
+			}
+			msleep(1);
+			
+		}
+	}
+
+	msleep(50);
+	
+	/*********Step 6: read out checksum***********************/
+	/*send the opration head */
+	DBG("Step 6: read out checksum\n");
+	auc_i2c_write_buf[0] = 0x64;
+	ft5x06_i2c_write(client, auc_i2c_write_buf, 1); 
+	msleep(300);
+
+	temp = 0;
+	auc_i2c_write_buf[0] = 0x65;
+	auc_i2c_write_buf[1] = (u8)(temp >> 16);
+	auc_i2c_write_buf[2] = (u8)(temp >> 8);
+	auc_i2c_write_buf[3] = (u8)(temp);
+	temp = dw_lenth;
+	auc_i2c_write_buf[4] = (u8)(temp >> 8);
+	auc_i2c_write_buf[5] = (u8)(temp);
+	i_ret = ft5x06_i2c_write(client, auc_i2c_write_buf, 6); 
+	msleep(dw_lenth/256);
+
+	for(i = 0;i < 100;i++)
+	{
+		auc_i2c_write_buf[0] = 0x6a;
+		reg_val[0] = reg_val[1] = 0x00;
+		ft5x06_i2c_read(client, auc_i2c_write_buf, 1, reg_val, 2);
+
+		if (0xF0==reg_val[0] && 0x55==reg_val[1])
+		{
+			break;
+		}
+		msleep(1);
+			
+	}
+	auc_i2c_write_buf[0] = 0x66;
+	ft5x06_i2c_read(client, auc_i2c_write_buf, 1, reg_val, 1);
+	if (reg_val[0] != bt_ecc) 
+	{
+		dev_err(&client->dev, "[FTS]--ecc error! FW=%02x bt_ecc=%02x\n",
+					reg_val[0],
+					bt_ecc);
+				
+		return -EIO;
+	}
+	printk(KERN_WARNING "checksum %X %X \n",reg_val[0],bt_ecc);	
+	/*********Step 7: reset the new FW***********************/
+	DBG("Step 7: reset the new FW\n");
+	auc_i2c_write_buf[0] = 0x07;
+	ft5x06_i2c_write(client, auc_i2c_write_buf, 1);
+	msleep(130);	//make sure CTP startup normally 
+
+	return 0;
+}
+
+/*create apk debug channel*/
+#define PROC_UPGRADE			0
+#define PROC_READ_REGISTER		1
+#define PROC_WRITE_REGISTER		2
+#define PROC_AUTOCLB			4
+#define PROC_UPGRADE_INFO		5
+#define PROC_WRITE_DATA			6
+#define PROC_READ_DATA			7
+
+
+#define PROC_NAME	"ft5x0x-debug"
+static unsigned char proc_operate_mode = PROC_UPGRADE;
+static struct proc_dir_entry *fts_proc_entry;
+/*interface of write proc*/
+static int fts_debug_write(struct file *filp, 
+	const char __user *buff, unsigned long len, void *data)
+{
+#if 0
+    struct i2c_client *client = (struct i2c_client *)fts_proc_entry->data;
+	unsigned char writebuf[2 * 1024];
+	int buflen = len;
+	int writelen = 0;
+	int ret = 0;
+	
+	if (copy_from_user(&writebuf, buff, buflen)) {
+		dev_err(&client->dev, "%s:copy from user error\n", __func__);
+		return -EFAULT;
+	}
+	proc_operate_mode = writebuf[0];
+
+	switch (proc_operate_mode) {
+	case PROC_UPGRADE:
+		{
+			char upgrade_file_path[128];
+			memset(upgrade_file_path, 0, sizeof(upgrade_file_path));
+			sprintf(upgrade_file_path, "%s", writebuf + 1);
+			upgrade_file_path[buflen-1] = '\0';
+			DBG("%s\n", upgrade_file_path);
+			disable_irq(client->irq);
+
+			ret = fts_ctpm_fw_upgrade_with_app_file(client, upgrade_file_path);
+
+			enable_irq(client->irq);
+			if (ret < 0) {
+				dev_err(&client->dev, "%s:upgrade failed.\n", __func__);
+				return ret;
+			}
+		}
+		break;
+	case PROC_READ_REGISTER:
+		writelen = 1;
+		ret = ft5x06_i2c_write(client, writebuf + 1, writelen);
+		if (ret < 0) {
+			dev_err(&client->dev, "%s:write iic error\n", __func__);
+			return ret;
+		}
+		break;
+	case PROC_WRITE_REGISTER:
+		writelen = 2;
+		ret = ft5x06_i2c_write(client, writebuf + 1, writelen);
+		if (ret < 0) {
+			dev_err(&client->dev, "%s:write iic error\n", __func__);
+			return ret;
+		}
+		break;
+	case PROC_AUTOCLB:
+		DBG("%s: autoclb\n", __func__);
+		ft5x06_auto_cal(client);
+		break;
+	case PROC_READ_DATA:
+	case PROC_WRITE_DATA:
+		writelen = len - 1;
+		ret = ft5x06_i2c_write(client, writebuf + 1, writelen);
+		if (ret < 0) {
+			dev_err(&client->dev, "%s:write iic error\n", __func__);
+			return ret;
+		}
+		break;
+	default:
+		break;
+	}
+	
+#endif
+	return len;
+}
+
+/*interface of read proc*/
+static int fts_debug_read( char *page, char **start,
+	off_t off, int count, int *eof, void *data )
+{
+#if 0
+    struct i2c_client *client = (struct i2c_client *)fts_proc_entry->data;
+	int ret = 0;
+	unsigned char buf[PAGE_SIZE];
+	int num_read_chars = 0;
+	int readlen = 0;
+	u8 regvalue = 0x00, regaddr = 0x00;
+	
+	switch (proc_operate_mode) {
+	case PROC_UPGRADE:
+		/*after calling ft5x0x_debug_write to upgrade*/
+		regaddr = 0xA6;
+		ret = ft5x0x_read_reg(client, regaddr, &regvalue);
+		if (ret < 0)
+			num_read_chars = sprintf(buf, "%s", "get fw version failed.\n");
+		else
+			num_read_chars = sprintf(buf, "current fw version:0x%02x\n", regvalue);
+		break;
+	case PROC_READ_REGISTER:
+		readlen = 1;
+		ret = ft5x06_i2c_read(client, NULL, 0, buf, readlen);
+		if (ret < 0) {
+			dev_err(&client->dev, "%s:read iic error\n", __func__);
+			return ret;
+		} 
+		num_read_chars = 1;
+		break;
+	case PROC_READ_DATA:
+		readlen = count;
+		ret = ft5x06_i2c_read(client, NULL, 0, buf, readlen);
+		if (ret < 0) {
+			dev_err(&client->dev, "%s:read iic error\n", __func__);
+			return ret;
+		}
+		
+		num_read_chars = readlen;
+		break;
+	case PROC_WRITE_DATA:
+		break;
+	default:
+		break;
+	}
+	
+	memcpy(page, buf, num_read_chars);
+	return num_read_chars;
+#else
+    return 0;
+#endif
+}
+
+int fts_create_apk_debug_channel(struct i2c_client * client)
+{
+#if 0
+	fts_proc_entry = create_proc_entry(PROC_NAME, 0777, NULL);
+	if (NULL == fts_proc_entry) {
+		dev_err(&client->dev, "Couldn't create proc entry!\n");
+		return -ENOMEM;
+	} else {
+		dev_info(&client->dev, "Create proc entry success!\n");
+		fts_proc_entry->data = client;
+		fts_proc_entry->write_proc = fts_debug_write;
+		fts_proc_entry->read_proc = fts_debug_read;
+	}
+#endif
+	return 0;
+}
+
+void fts_release_apk_debug_channel(void)
+{
+#if 0
+	if (fts_proc_entry)
+		remove_proc_entry(PROC_NAME, NULL);
+#endif
+}
+
+static int ft5x06_auto_cal(struct i2c_client *client)
+{
+	struct ft5x06_ts_data *data = i2c_get_clientdata(client);
+	u8 temp = 0, i;
+
+	/* set to factory mode */
+	msleep(2 * data->pdata->soft_rst_dly);
+	ft5x0x_write_reg(client, FT_REG_DEV_MODE, FT_FACTORYMODE_VALUE);
+	msleep(data->pdata->soft_rst_dly);
+
+	/* start calibration */
+	ft5x0x_write_reg(client, FT_DEV_MODE_REG_CAL, FT_CAL_START);
+	msleep(2 * data->pdata->soft_rst_dly);
+	for (i = 0; i < FT_CAL_RETRY; i++) {
+		ft5x0x_read_reg(client, FT_REG_CAL, &temp);
+		/*return to normal mode, calibration finish */
+		if (((temp & FT_CAL_MASK) >> FT_4BIT_SHIFT) == FT_CAL_FIN)
+			break;
+	}
+
+	/*calibration OK */
+	msleep(2 * data->pdata->soft_rst_dly);
+	ft5x0x_write_reg(client, FT_REG_DEV_MODE, FT_FACTORYMODE_VALUE);
+	msleep(data->pdata->soft_rst_dly);
+
+	/* store calibration data */
+	ft5x0x_write_reg(client, FT_DEV_MODE_REG_CAL, FT_CAL_STORE);
+	msleep(2 * data->pdata->soft_rst_dly);
+
+	/* set to normal mode */
+	ft5x0x_write_reg(client, FT_REG_DEV_MODE, FT_WORKMODE_VALUE);
+	msleep(2 * data->pdata->soft_rst_dly);
+
+	return 0;
+}
+
+static int ft5x06_fw_upgrade_start(struct i2c_client *client,
+			const u8 *data, u32 data_len)
+{
+#if 0
+	struct ft5x06_ts_data *ts_data = i2c_get_clientdata(client);
+	struct fw_upgrade_info info = ts_data->pdata->info;
+	u8 reset_reg;
+	u8 w_buf[FT_MAX_WR_BUF] = {0}, r_buf[FT_MAX_RD_BUF] = {0};
+	u8 pkt_buf[FT_FW_PKT_LEN + FT_FW_PKT_META_LEN];
+	int i, j, temp;
+	u32 pkt_num, pkt_len;
+	u8 is_5336_new_bootloader = false;
+	u8 is_5336_fwsize_30 = false;
+	u8 fw_ecc;
+
+	/* determine firmware size */
+	if (*(data + data_len - FT_BLOADER_SIZE_OFF) == FT_BLOADER_NEW_SIZE)
+		is_5336_fwsize_30 = true;
+	else
+		is_5336_fwsize_30 = false;
+
+	for (i = 0, j = 0; i < FT_UPGRADE_LOOP; i++) {
+		msleep(FT_EARSE_DLY_MS);
+		/* reset - write 0xaa and 0x55 to reset register */
+		if (ts_data->family_id == FT6X06_ID
+			|| ts_data->family_id == FT6X36_ID)
+			reset_reg = FT_RST_CMD_REG2;
+		else
+			reset_reg = FT_RST_CMD_REG1;
+
+		ft5x0x_write_reg(client, reset_reg, FT_UPGRADE_AA);
+		msleep(info.delay_aa);
+
+		ft5x0x_write_reg(client, reset_reg, FT_UPGRADE_55);
+		if (i <= (FT_UPGRADE_LOOP / 2))
+			msleep(info.delay_55 + i * 3);
+		else
+			msleep(info.delay_55 - (i - (FT_UPGRADE_LOOP / 2)) * 2);
+
+		/* Enter upgrade mode */
+		w_buf[0] = FT_UPGRADE_55;
+		ft5x06_i2c_write(client, w_buf, 1);
+		usleep(FT_55_AA_DLY_NS);
+		w_buf[0] = FT_UPGRADE_AA;
+		ft5x06_i2c_write(client, w_buf, 1);
+
+		/* check READ_ID */
+		msleep(info.delay_readid);
+		w_buf[0] = FT_READ_ID_REG;
+		w_buf[1] = 0x00;
+		w_buf[2] = 0x00;
+		w_buf[3] = 0x00;
+
+		ft5x06_i2c_read(client, w_buf, 4, r_buf, 2);
+
+		if (r_buf[0] != info.upgrade_id_1
+			|| r_buf[1] != info.upgrade_id_2) {
+			dev_err(&client->dev, "Upgrade ID mismatch(%d), IC=0x%x 0x%x, info=0x%x 0x%x\n",
+				i, r_buf[0], r_buf[1],
+				info.upgrade_id_1, info.upgrade_id_2);
+		} else
+			break;
+	}
+
+	if (i >= FT_UPGRADE_LOOP) {
+		dev_err(&client->dev, "Abort upgrade\n");
+		return -EIO;
+	}
+
+	w_buf[0] = 0xcd;
+	ft5x06_i2c_read(client, w_buf, 1, r_buf, 1);
+
+	if (r_buf[0] <= 4)
+		is_5336_new_bootloader = FT_BLOADER_VERSION_LZ4;
+	else if (r_buf[0] == 7)
+		is_5336_new_bootloader = FT_BLOADER_VERSION_Z7;
+	else if (r_buf[0] >= 0x0f &&
+		((ts_data->family_id == FT_FT5336_FAMILY_ID_0x11) ||
+		(ts_data->family_id == FT_FT5336_FAMILY_ID_0x12) ||
+		(ts_data->family_id == FT_FT5336_FAMILY_ID_0x13) ||
+		(ts_data->family_id == FT_FT5336_FAMILY_ID_0x14)))
+		is_5336_new_bootloader = FT_BLOADER_VERSION_GZF;
+	else
+		is_5336_new_bootloader = FT_BLOADER_VERSION_LZ4;
+
+	dev_dbg(&client->dev, "bootloader type=%d, r_buf=0x%x, family_id=0x%x\n",
+		is_5336_new_bootloader, r_buf[0], ts_data->family_id);
+	/* is_5336_new_bootloader = FT_BLOADER_VERSION_GZF; */
+
+	/* erase app and panel paramenter area */
+	w_buf[0] = FT_ERASE_APP_REG;
+	ft5x06_i2c_write(client, w_buf, 1);
+	msleep(info.delay_erase_flash);
+
+	if (is_5336_fwsize_30) {
+		w_buf[0] = FT_ERASE_PANEL_REG;
+		ft5x06_i2c_write(client, w_buf, 1);
+	}
+	msleep(FT_EARSE_DLY_MS);
+
+	/* program firmware */
+	if (is_5336_new_bootloader == FT_BLOADER_VERSION_LZ4
+		|| is_5336_new_bootloader == FT_BLOADER_VERSION_Z7)
+		data_len = data_len - FT_DATA_LEN_OFF_OLD_FW;
+	else
+		data_len = data_len - FT_DATA_LEN_OFF_NEW_FW;
+
+	pkt_num = (data_len) / FT_FW_PKT_LEN;
+	pkt_len = FT_FW_PKT_LEN;
+	pkt_buf[0] = FT_FW_START_REG;
+	pkt_buf[1] = 0x00;
+	fw_ecc = 0;
+
+	for (i = 0; i < pkt_num; i++) {
+		temp = i * FT_FW_PKT_LEN;
+		pkt_buf[2] = (u8) (temp >> FT_8BIT_SHIFT);
+		pkt_buf[3] = (u8) temp;
+		pkt_buf[4] = (u8) (pkt_len >> FT_8BIT_SHIFT);
+		pkt_buf[5] = (u8) pkt_len;
+
+		for (j = 0; j < FT_FW_PKT_LEN; j++) {
+			pkt_buf[6 + j] = data[i * FT_FW_PKT_LEN + j];
+			fw_ecc ^= pkt_buf[6 + j];
+		}
+
+		ft5x06_i2c_write(client, pkt_buf,
+				FT_FW_PKT_LEN + FT_FW_PKT_META_LEN);
+		msleep(FT_FW_PKT_DLY_MS);
+	}
+
+	/* send remaining bytes */
+	if ((data_len) % FT_FW_PKT_LEN > 0) {
+		temp = pkt_num * FT_FW_PKT_LEN;
+		pkt_buf[2] = (u8) (temp >> FT_8BIT_SHIFT);
+		pkt_buf[3] = (u8) temp;
+		temp = (data_len) % FT_FW_PKT_LEN;
+		pkt_buf[4] = (u8) (temp >> FT_8BIT_SHIFT);
+		pkt_buf[5] = (u8) temp;
+
+		for (i = 0; i < temp; i++) {
+			pkt_buf[6 + i] = data[pkt_num * FT_FW_PKT_LEN + i];
+			fw_ecc ^= pkt_buf[6 + i];
+		}
+
+		ft5x06_i2c_write(client, pkt_buf, temp + FT_FW_PKT_META_LEN);
+		msleep(FT_FW_PKT_DLY_MS);
+	}
+
+	/* send the finishing packet */
+	if (is_5336_new_bootloader == FT_BLOADER_VERSION_LZ4 ||
+		is_5336_new_bootloader == FT_BLOADER_VERSION_Z7) {
+		for (i = 0; i < FT_FINISHING_PKT_LEN_OLD_FW; i++) {
+			if (is_5336_new_bootloader  == FT_BLOADER_VERSION_Z7)
+				temp = FT_MAGIC_BLOADER_Z7 + i;
+			else if (is_5336_new_bootloader ==
+						FT_BLOADER_VERSION_LZ4)
+				temp = FT_MAGIC_BLOADER_LZ4 + i;
+			pkt_buf[2] = (u8)(temp >> 8);
+			pkt_buf[3] = (u8)temp;
+			temp = 1;
+			pkt_buf[4] = (u8)(temp >> 8);
+			pkt_buf[5] = (u8)temp;
+			pkt_buf[6] = data[data_len + i];
+			fw_ecc ^= pkt_buf[6];
+
+			ft5x06_i2c_write(client,
+				pkt_buf, temp + FT_FW_PKT_META_LEN);
+			msleep(FT_FW_PKT_DLY_MS);
+		}
+	} else if (is_5336_new_bootloader == FT_BLOADER_VERSION_GZF) {
+		for (i = 0; i < FT_FINISHING_PKT_LEN_NEW_FW; i++) {
+			if (is_5336_fwsize_30)
+				temp = FT_MAGIC_BLOADER_GZF_30 + i;
+			else
+				temp = FT_MAGIC_BLOADER_GZF + i;
+			pkt_buf[2] = (u8)(temp >> 8);
+			pkt_buf[3] = (u8)temp;
+			temp = 1;
+			pkt_buf[4] = (u8)(temp >> 8);
+			pkt_buf[5] = (u8)temp;
+			pkt_buf[6] = data[data_len + i];
+			fw_ecc ^= pkt_buf[6];
+
+			ft5x06_i2c_write(client,
+				pkt_buf, temp + FT_FW_PKT_META_LEN);
+			msleep(FT_FW_PKT_DLY_MS);
+
+		}
+	}
+
+	/* verify checksum */
+	w_buf[0] = FT_REG_ECC;
+	ft5x06_i2c_read(client, w_buf, 1, r_buf, 1);
+	if (r_buf[0] != fw_ecc) {
+		dev_err(&client->dev, "ECC error! dev_ecc=%02x fw_ecc=%02x\n",
+					r_buf[0], fw_ecc);
+		return -EIO;
+	}
+
+	/* reset */
+	w_buf[0] = FT_REG_RESET_FW;
+	ft5x06_i2c_write(client, w_buf, 1);
+	msleep(ts_data->pdata->soft_rst_dly);
+
+	dev_info(&client->dev, "Firmware upgrade successful\n");
+#endif
+	return 0;
+}
+
+static int ft5x06_fw_upgrade(struct device *dev, bool force)
+{
+#if 0
+	struct ft5x06_ts_data *data = dev_get_drvdata(dev);
+	const struct firmware *pbt_buf = NULL;
+	u8 fw_file_maj, fw_file_min, fw_file_sub_min, fw_file_vendor_id;
+	bool fw_upgrade = false;
+	int i_ret;
+	int fw_len = 0;
+    return 0;
+	if (data->suspended) {
+		dev_err(dev, "Device is in suspend state: Exit FW upgrade\n");
+		return -EBUSY;
+	}
+
+	i_ret= request_firmware(&pbt_buf, data->fw_name, dev);
+	if (i_ret < 0) {
+		dev_err(dev, "Request firmware failed - %s (%d)\n",
+						data->fw_name, i_ret);
+		return i_ret;
+	}
+
+	if (pbt_buf->size < FT_FW_MIN_SIZE || pbt_buf->size > FT_FW_MAX_SIZE) {
+		dev_err(dev, "Invalid firmware size (%zu)\n", pbt_buf->size);
+		rc = -EIO;
+		goto rel_fw;
+	}
+
+	fw_len = pbt_buf->size;
+
+	if ((fts_updateinfo_curr.CHIP_ID==0x11) ||(fts_updateinfo_curr.CHIP_ID==0x12) ||(fts_updateinfo_curr.CHIP_ID==0x13) ||(fts_updateinfo_curr.CHIP_ID==0x14)
+		||(fts_updateinfo_curr.CHIP_ID==0x55) ||(fts_updateinfo_curr.CHIP_ID==0x06) ||(fts_updateinfo_curr.CHIP_ID==0x0a) ||(fts_updateinfo_curr.CHIP_ID==0x08))
+	{
+		if (fw_len < 8 || fw_len > 32 * 1024) 
+		{
+			dev_err(&client->dev, "%s:FW length error\n", __func__);
+			return -EIO;
+		}
+
+		if ((CTPM_FW[fw_len - 8] ^ CTPM_FW[fw_len - 6]) == 0xFF
+		&& (CTPM_FW[fw_len - 7] ^ CTPM_FW[fw_len - 5]) == 0xFF
+		&& (CTPM_FW[fw_len - 3] ^ CTPM_FW[fw_len - 4]) == 0xFF) 
+		{
+			/*FW upgrade */
+			/*call the upgrade function */
+			if ((fts_updateinfo_curr.CHIP_ID==0x55) ||(fts_updateinfo_curr.CHIP_ID==0x08) ||(fts_updateinfo_curr.CHIP_ID==0x0a))
+			{
+				i_ret = fts_5x06_ctpm_fw_upgrade(client, pbt_buf->data, fw_len);
+			}
+			else if ((fts_updateinfo_curr.CHIP_ID==0x11) ||(fts_updateinfo_curr.CHIP_ID==0x12) ||(fts_updateinfo_curr.CHIP_ID==0x13) ||(fts_updateinfo_curr.CHIP_ID==0x14))
+			{
+				i_ret = fts_5x36_ctpm_fw_upgrade(client, pbt_buf->data, fw_len);
+			}
+			else if ((fts_updateinfo_curr.CHIP_ID==0x06))
+			{
+				i_ret = fts_6x06_ctpm_fw_upgrade(client, pbt_buf->data, fw_len);
+			}
+			if (i_ret != 0)
+				dev_err(&client->dev, "%s:upgrade failed. err.\n",
+						__func__);
+			else if(fts_updateinfo_curr.AUTO_CLB==AUTO_CLB_NEED)
+			{
+				//fts_ctpm_auto_clb(client);
+			}
+		} 
+		else 
+		{
+			dev_err(&client->dev, "%s:FW format error\n", __func__);
+			return -EBADFD;
+		}
+	}
+	else if ((fts_updateinfo_curr.CHIP_ID==0x36))
+	{
+		if (fw_len < 8 || fw_len > 32 * 1024) 
+		{
+			dev_err(&client->dev, "%s:FW length error\n", __func__);
+			return -EIO;
+		}
+		i_ret = fts_6x36_ctpm_fw_upgrade(client, pbt_buf->data, fw_len);
+		if (i_ret != 0)
+			dev_err(&client->dev, "%s:upgrade failed. err.\n",
+					__func__);
+	}
+	else if ((fts_updateinfo_curr.CHIP_ID==0x54))
+	{
+		if (fw_len < 8 || fw_len > 54 * 1024) 
+		{
+			dev_err(&client->dev, "%s:FW length error\n", __func__);
+			return -EIO;
+		}
+		i_ret = fts_5x46_ctpm_fw_upgrade(client, pbt_buf->data, fw_len);
+		if (i_ret != 0)
+			dev_err(&client->dev, "%s:upgrade failed. err.\n",
+					__func__);
+	}
+
+	/*
+	if (data->family_id == FT6X36_ID) {
+		fw_file_maj = FT_FW_FILE_MAJ_VER_FT6X36(fw);
+		fw_file_vendor_id = FT_FW_FILE_VENDOR_ID_FT6X36(fw);
+	} else {
+		fw_file_maj = FT_FW_FILE_MAJ_VER(fw);
+		fw_file_vendor_id = FT_FW_FILE_VENDOR_ID(fw);
+	}
+	fw_file_min = FT_FW_FILE_MIN_VER(fw);
+	fw_file_sub_min = FT_FW_FILE_SUB_MIN_VER(fw);
+
+	dev_info(dev, "Current firmware: %d.%d.%d", data->fw_ver[0],
+				data->fw_ver[1], data->fw_ver[2]);
+	dev_info(dev, "New firmware: %d.%d.%d", fw_file_maj,
+				fw_file_min, fw_file_sub_min);
+
+	if (force)
+		fw_upgrade = true;
+	else if ((data->fw_ver[0] < fw_file_maj) &&
+		data->fw_vendor_id == fw_file_vendor_id)
+		fw_upgrade = true;
+
+	if (!fw_upgrade) {
+		dev_info(dev, "Exiting fw upgrade...\n");
+		rc = -EFAULT;
+		goto rel_fw;
+	}
+
+	// start firmware upgrade 
+	if (FT_FW_CHECK(fw, data)) {
+		rc = ft5x06_fw_upgrade_start(data->client, fw->data, fw->size);
+		if (rc < 0)
+			dev_err(dev, "update failed (%d). try later...\n", rc);
+		else if (data->pdata->info.auto_cal)
+			ft5x06_auto_cal(data->client);
+	} else {
+		dev_err(dev, "FW format error\n");
+		rc = -EIO;
+	}
+	*/
+
+	ft5x06_update_fw_ver(data);
+
+	FT_STORE_TS_INFO(data->ts_info, data->family_id, data->pdata->name,
+			data->pdata->num_max_touches, data->pdata->group_id,
+			data->pdata->fw_vkey_support ? "yes" : "no",
+			data->pdata->fw_name, data->fw_ver[0],
+			data->fw_ver[1], data->fw_ver[2]);
+rel_fw:
+	release_firmware(pbt_buf);
+	return i_ret;
+#endif
+    return 0;
+}
+
+static ssize_t ft5x06_update_fw_show(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	struct ft5x06_ts_data *data = dev_get_drvdata(dev);
+	return snprintf(buf, 2, "%d\n", data->loading_fw);
+}
+
+static ssize_t ft5x06_update_fw_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t size)
+{
+	struct ft5x06_ts_data *data = dev_get_drvdata(dev);
+	unsigned long val;
+	int rc;
+
+	if (size > 2)
+		return -EINVAL;
+
+	rc = kstrtoul(buf, 10, &val);
+	if (rc != 0)
+		return rc;
+
+	if (data->suspended) {
+		dev_info(dev, "In suspend state, try again later...\n");
+		return size;
+	}
+
+	mutex_lock(&data->input_dev->mutex);
+	if (!data->loading_fw  && val) {
+		data->loading_fw = true;
+		ft5x06_fw_upgrade(dev, false);
+		data->loading_fw = false;
+	}
+	mutex_unlock(&data->input_dev->mutex);
+
+	return size;
+}
+
+static DEVICE_ATTR(update_fw, 0664, ft5x06_update_fw_show,
+				ft5x06_update_fw_store);
+
+static ssize_t ft5x06_force_update_fw_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t size)
+{
+	struct ft5x06_ts_data *data = dev_get_drvdata(dev);
+	unsigned long val;
+	int rc;
+
+	if (size > 2)
+		return -EINVAL;
+
+	rc = kstrtoul(buf, 10, &val);
+	if (rc != 0)
+		return rc;
+
+	mutex_lock(&data->input_dev->mutex);
+	if (!data->loading_fw  && val) {
+		data->loading_fw = true;
+		ft5x06_fw_upgrade(dev, true);
+		data->loading_fw = false;
+	}
+	mutex_unlock(&data->input_dev->mutex);
+
+	return size;
+}
+
+static DEVICE_ATTR(force_update_fw, 0664, ft5x06_update_fw_show,
+				ft5x06_force_update_fw_store);
+
+static ssize_t ft5x06_fw_name_show(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	struct ft5x06_ts_data *data = dev_get_drvdata(dev);
+	return snprintf(buf, FT_FW_NAME_MAX_LEN - 1, "%s\n", data->fw_name);
+}
+
+static ssize_t ft5x06_fw_name_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t size)
+{
+	struct ft5x06_ts_data *data = dev_get_drvdata(dev);
+
+	if (size > FT_FW_NAME_MAX_LEN - 1)
+		return -EINVAL;
+
+	strlcpy(data->fw_name, buf, size);
+	if (data->fw_name[size-1] == '\n')
+		data->fw_name[size-1] = 0;
+
+	return size;
+}
+
+static DEVICE_ATTR(fw_name, 0664, ft5x06_fw_name_show, ft5x06_fw_name_store);
+
+static bool ft5x06_debug_addr_is_valid(int addr)
+{
+	if (addr < 0 || addr > 0xFF) {
+		pr_err("FT reg address is invalid: 0x%x\n", addr);
+		return false;
+	}
+
+	return true;
+}
+
+static int ft5x06_debug_data_set(void *_data, u64 val)
+{
+	struct ft5x06_ts_data *data = _data;
+
+	mutex_lock(&data->input_dev->mutex);
+
+	if (ft5x06_debug_addr_is_valid(data->addr))
+		dev_info(&data->client->dev,
+			"Writing into FT registers not supported\n");
+
+	mutex_unlock(&data->input_dev->mutex);
+
+	return 0;
+}
+
+static int ft5x06_debug_data_get(void *_data, u64 *val)
+{
+	struct ft5x06_ts_data *data = _data;
+	int rc;
+	u8 reg;
+
+	mutex_lock(&data->input_dev->mutex);
+
+	if (ft5x06_debug_addr_is_valid(data->addr)) {
+		rc = ft5x0x_read_reg(data->client, data->addr, &reg);
+		if (rc < 0)
+			dev_err(&data->client->dev,
+				"FT read register 0x%x failed (%d)\n",
+				data->addr, rc);
+		else
+			*val = reg;
+	}
+
+	mutex_unlock(&data->input_dev->mutex);
+
+	return 0;
+}
+
+DEFINE_SIMPLE_ATTRIBUTE(debug_data_fops, ft5x06_debug_data_get,
+			ft5x06_debug_data_set, "0x%02llX\n");
+
+static int ft5x06_debug_addr_set(void *_data, u64 val)
+{
+	struct ft5x06_ts_data *data = _data;
+
+	if (ft5x06_debug_addr_is_valid(val)) {
+		mutex_lock(&data->input_dev->mutex);
+		data->addr = val;
+		mutex_unlock(&data->input_dev->mutex);
+	}
+
+	return 0;
+}
+
+static int ft5x06_debug_addr_get(void *_data, u64 *val)
+{
+	struct ft5x06_ts_data *data = _data;
+
+	mutex_lock(&data->input_dev->mutex);
+
+	if (ft5x06_debug_addr_is_valid(data->addr))
+		*val = data->addr;
+
+	mutex_unlock(&data->input_dev->mutex);
+
+	return 0;
+}
+
+DEFINE_SIMPLE_ATTRIBUTE(debug_addr_fops, ft5x06_debug_addr_get,
+			ft5x06_debug_addr_set, "0x%02llX\n");
+
+static int ft5x06_debug_suspend_set(void *_data, u64 val)
+{
+	struct ft5x06_ts_data *data = _data;
+
+	mutex_lock(&data->input_dev->mutex);
+
+	if (val)
+		ft5x06_ts_suspend(&data->client->dev);
+	else
+		ft5x06_ts_resume(&data->client->dev);
+
+	mutex_unlock(&data->input_dev->mutex);
+
+	return 0;
+}
+
+static int ft5x06_debug_suspend_get(void *_data, u64 *val)
+{
+	struct ft5x06_ts_data *data = _data;
+
+	mutex_lock(&data->input_dev->mutex);
+	*val = data->suspended;
+	mutex_unlock(&data->input_dev->mutex);
+
+	return 0;
+}
+
+DEFINE_SIMPLE_ATTRIBUTE(debug_suspend_fops, ft5x06_debug_suspend_get,
+			ft5x06_debug_suspend_set, "%lld\n");
+
+static int ft5x06_debug_dump_info(struct seq_file *m, void *v)
+{
+	struct ft5x06_ts_data *data = m->private;
+
+	seq_printf(m, "%s\n", data->ts_info);
+
+	return 0;
+}
+
+static int debugfs_dump_info_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, ft5x06_debug_dump_info, inode->i_private);
+}
+
+static const struct file_operations debug_dump_info_fops = {
+	.owner		= THIS_MODULE,
+	.open		= debugfs_dump_info_open,
+	.read		= seq_read,
+	.release	= single_release,
+};
+
+#ifdef CONFIG_OF
+static int ft5x06_get_dt_coords(struct device *dev, char *name,
+				struct ft5x06_ts_platform_data *pdata)
+{
+	u32 coords[FT_COORDS_ARR_SIZE];
+	struct property *prop;
+	struct device_node *np = dev->of_node;
+	int coords_size, rc;
+
+	prop = of_find_property(np, name, NULL);
+	if (!prop)
+		return -EINVAL;
+	if (!prop->value)
+		return -ENODATA;
+
+	coords_size = prop->length / sizeof(u32);
+	if (coords_size != FT_COORDS_ARR_SIZE) {
+		dev_err(dev, "invalid %s\n", name);
+		return -EINVAL;
+	}
+
+	rc = of_property_read_u32_array(np, name, coords, coords_size);
+	if (rc && (rc != -EINVAL)) {
+		dev_err(dev, "Unable to read %s\n", name);
+		return rc;
+	}
+
+	if (!strcmp(name, "focaltech,panel-coords")) {
+		pdata->panel_minx = coords[0];
+		pdata->panel_miny = coords[1];
+		pdata->panel_maxx = coords[2];
+		pdata->panel_maxy = coords[3];
+	} else if (!strcmp(name, "focaltech,display-coords")) {
+		pdata->x_min = coords[0];
+		pdata->y_min = coords[1];
+		pdata->x_max = coords[2];
+		pdata->y_max = coords[3];
+	} else {
+		dev_err(dev, "unsupported property %s\n", name);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int ft5x06_parse_dt(struct device *dev,
+			struct ft5x06_ts_platform_data *pdata)
+{
+	int rc;
+	struct device_node *np = dev->of_node;
+	struct property *prop;
+	u32 temp_val, num_buttons;
+	u32 button_map[MAX_BUTTONS];
+
+	pdata->name = "focaltech";
+	rc = of_property_read_string(np, "focaltech,name", &pdata->name);
+	if (rc && (rc != -EINVAL)) {
+		dev_err(dev, "Unable to read name\n");
+		return rc;
+	}
+
+	rc = ft5x06_get_dt_coords(dev, "focaltech,panel-coords", pdata);
+	if (rc && (rc != -EINVAL))
+		return rc;
+
+	rc = ft5x06_get_dt_coords(dev, "focaltech,display-coords", pdata);
+	if (rc)
+		return rc;
+
+	pdata->i2c_pull_up = of_property_read_bool(np,
+						"focaltech,i2c-pull-up");
+
+	pdata->no_force_update = of_property_read_bool(np,
+						"focaltech,no-force-update");
+	/* reset, irq gpio info */
+	pdata->reset_gpio = of_get_named_gpio_flags(np, "focaltech,reset-gpio",
+				0, &pdata->reset_gpio_flags);
+	if (pdata->reset_gpio < 0)
+		return pdata->reset_gpio;
+
+	pdata->irq_gpio = of_get_named_gpio_flags(np, "focaltech,irq-gpio",
+				0, &pdata->irq_gpio_flags);
+	if (pdata->irq_gpio < 0)
+		return pdata->irq_gpio;
+
+	pdata->fw_name = "ft_fw.bin";
+	rc = of_property_read_string(np, "focaltech,fw-name", &pdata->fw_name);
+	if (rc && (rc != -EINVAL)) {
+		dev_err(dev, "Unable to read fw name\n");
+		return rc;
+	}
+
+	rc = of_property_read_u32(np, "focaltech,group-id", &temp_val);
+	if (!rc)
+		pdata->group_id = temp_val;
+	else
+		return rc;
+
+	rc = of_property_read_u32(np, "focaltech,hard-reset-delay-ms",
+							&temp_val);
+	if (!rc)
+		pdata->hard_rst_dly = temp_val;
+	else
+		return rc;
+
+	rc = of_property_read_u32(np, "focaltech,soft-reset-delay-ms",
+							&temp_val);
+	if (!rc)
+		pdata->soft_rst_dly = temp_val;
+	else
+		return rc;
+
+	rc = of_property_read_u32(np, "focaltech,num-max-touches", &temp_val);
+	if (!rc)
+		pdata->num_max_touches = temp_val;
+	else
+		return rc;
+
+	rc = of_property_read_u32(np, "focaltech,fw-delay-aa-ms", &temp_val);
+	if (rc && (rc != -EINVAL)) {
+		dev_err(dev, "Unable to read fw delay aa\n");
+		return rc;
+	} else if (rc != -EINVAL)
+		pdata->info.delay_aa =  temp_val;
+
+	rc = of_property_read_u32(np, "focaltech,fw-delay-55-ms", &temp_val);
+	if (rc && (rc != -EINVAL)) {
+		dev_err(dev, "Unable to read fw delay 55\n");
+		return rc;
+	} else if (rc != -EINVAL)
+		pdata->info.delay_55 =  temp_val;
+
+	rc = of_property_read_u32(np, "focaltech,fw-upgrade-id1", &temp_val);
+	if (rc && (rc != -EINVAL)) {
+		dev_err(dev, "Unable to read fw upgrade id1\n");
+		return rc;
+	} else if (rc != -EINVAL)
+		pdata->info.upgrade_id_1 =  temp_val;
+
+	rc = of_property_read_u32(np, "focaltech,fw-upgrade-id2", &temp_val);
+	if (rc && (rc != -EINVAL)) {
+		dev_err(dev, "Unable to read fw upgrade id2\n");
+		return rc;
+	} else if (rc != -EINVAL)
+		pdata->info.upgrade_id_2 =  temp_val;
+
+	rc = of_property_read_u32(np, "focaltech,fw-delay-readid-ms",
+							&temp_val);
+	if (rc && (rc != -EINVAL)) {
+		dev_err(dev, "Unable to read fw delay read id\n");
+		return rc;
+	} else if (rc != -EINVAL)
+		pdata->info.delay_readid =  temp_val;
+
+	rc = of_property_read_u32(np, "focaltech,fw-delay-era-flsh-ms",
+							&temp_val);
+	if (rc && (rc != -EINVAL)) {
+		dev_err(dev, "Unable to read fw delay erase flash\n");
+		return rc;
+	} else if (rc != -EINVAL)
+		pdata->info.delay_erase_flash =  temp_val;
+
+	pdata->info.auto_cal = of_property_read_bool(np,
+					"focaltech,fw-auto-cal");
+
+	pdata->fw_vkey_support = of_property_read_bool(np,
+						"focaltech,fw-vkey-support");
+
+	pdata->ignore_id_check = of_property_read_bool(np,
+						"focaltech,ignore-id-check");
+
+	rc = of_property_read_u32(np, "focaltech,family-id", &temp_val);
+	if (!rc)
+		pdata->family_id = temp_val;
+	else
+		return rc;
+
+	prop = of_find_property(np, "focaltech,button-map", NULL);
+	if (prop) {
+		num_buttons = prop->length / sizeof(temp_val);
+		if (num_buttons > MAX_BUTTONS)
+			return -EINVAL;
+
+		rc = of_property_read_u32_array(np,
+			"focaltech,button-map", button_map,
+			num_buttons);
+		if (rc) {
+			dev_err(dev, "Unable to read key codes\n");
+			return rc;
+		}
+	}
+
+	return 0;
+}
+#else
+static int ft5x06_parse_dt(struct device *dev,
+			struct ft5x06_ts_platform_data *pdata)
+{
+	return -ENODEV;
+}
+#endif
+
+static int ft5x06_ts_probe(struct i2c_client *client,
+			   const struct i2c_device_id *id)
+{
+	struct ft5x06_ts_platform_data *pdata;
+	struct ft5x06_ts_data *data;
+	struct input_dev *input_dev;
+	struct dentry *temp;
+	u8 reg_value;
+	u8 reg_addr;
+	int err, len;
+
+	if (client->dev.of_node) {
+		pdata = devm_kzalloc(&client->dev,
+			sizeof(struct ft5x06_ts_platform_data), GFP_KERNEL);
+		if (!pdata) {
+			dev_err(&client->dev, "Failed to allocate memory\n");
+			return -ENOMEM;
+		}
+
+		err = ft5x06_parse_dt(&client->dev, pdata);
+		if (err) {
+			dev_err(&client->dev, "DT parsing failed\n");
+			return err;
+		}
+	} else
+		pdata = client->dev.platform_data;
+
+	if (!pdata) {
+		dev_err(&client->dev, "Invalid pdata\n");
+		return -EINVAL;
+	}
+
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
+		dev_err(&client->dev, "I2C not supported\n");
+		return -ENODEV;
+	}
+
+	data = devm_kzalloc(&client->dev,
+			sizeof(struct ft5x06_ts_data), GFP_KERNEL);
+	if (!data) {
+		dev_err(&client->dev, "Not enough memory\n");
+		return -ENOMEM;
+	}
+
+	if (pdata->fw_name) {
+		len = strlen(pdata->fw_name);
+		if (len > FT_FW_NAME_MAX_LEN - 1) {
+			dev_err(&client->dev, "Invalid firmware name\n");
+			return -EINVAL;
+		}
+
+		strlcpy(data->fw_name, pdata->fw_name, len + 1);
+	}
+
+	data->tch_data_len = FT_TCH_LEN(pdata->num_max_touches);
+	data->tch_data = devm_kzalloc(&client->dev,
+				data->tch_data_len, GFP_KERNEL);
+	if (!data->tch_data) {
+		dev_err(&client->dev, "Not enough memory\n");
+		return -ENOMEM;
+	}
+
+	input_dev = input_allocate_device();
+	if (!input_dev) {
+		dev_err(&client->dev, "failed to allocate input device\n");
+		return -ENOMEM;
+	}
+
+	data->input_dev = input_dev;
+	data->client = client;
+	data->pdata = pdata;
+
+	input_dev->name = "ft5x06_ts";
+	input_dev->id.bustype = BUS_I2C;
+	input_dev->dev.parent = &client->dev;
+
+	input_set_drvdata(input_dev, data);
+	i2c_set_clientdata(client, data);
+
+	__set_bit(EV_KEY, input_dev->evbit);
+	__set_bit(EV_ABS, input_dev->evbit);
+	__set_bit(BTN_TOUCH, input_dev->keybit);
+	__set_bit(INPUT_PROP_DIRECT, input_dev->propbit);
+
+	input_mt_init_slots(input_dev, pdata->num_max_touches, 0);
+	input_set_abs_params(input_dev, ABS_MT_POSITION_X, pdata->x_min,
+			     pdata->x_max, 0, 0);
+	input_set_abs_params(input_dev, ABS_MT_POSITION_Y, pdata->y_min,
+			     pdata->y_max, 0, 0);
+
+	err = input_register_device(input_dev);
+	if (err) {
+		dev_err(&client->dev, "Input device registration failed\n");
+		goto free_inputdev;
+	}
+
+	if (pdata->power_init) {
+		err = pdata->power_init(true);
+		if (err) {
+			dev_err(&client->dev, "power init failed");
+			goto unreg_inputdev;
+		}
+	} else {
+		err = ft5x06_power_init(data, true);
+		if (err) {
+			dev_err(&client->dev, "power init failed");
+			goto unreg_inputdev;
+		}
+	}
+
+	if (pdata->power_on) {
+		err = pdata->power_on(true);
+		if (err) {
+			dev_err(&client->dev, "power on failed");
+			goto pwr_deinit;
+		}
+	} else {
+		err = ft5x06_power_on(data, true);
+		if (err) {
+			dev_err(&client->dev, "power on failed");
+			goto pwr_deinit;
+		}
+	}
+
+	err = ft5x06_ts_pinctrl_init(data);
+	if (!err && data->ts_pinctrl) {
+		/*
+		 * Pinctrl handle is optional. If pinctrl handle is found
+		 * let pins to be configured in active state. If not
+		 * found continue further without error.
+		 */
+		err = pinctrl_select_state(data->ts_pinctrl,
+					data->pinctrl_state_active);
+		if (err < 0) {
+			dev_err(&client->dev,
+				"failed to select pin to active state");
+		}
+	}
+
+	err = ft5x06_gpio_configure(data, true);
+	if (err < 0) {
+		dev_err(&client->dev,
+			"Failed to configure the gpios\n");
+		goto err_gpio_req;
+	}
+
+	/* make sure CTP already finish startup process */
+	msleep(data->pdata->soft_rst_dly);
+
+	/* check the controller id */
+	reg_addr = FT_REG_ID;
+	err = ft5x06_i2c_read(client, &reg_addr, 1, &reg_value, 1);
+	if (err < 0) {
+		dev_err(&client->dev, "version read failed");
+		goto free_gpio;
+	}
+
+	dev_info(&client->dev, "Device ID = 0x%x\n", reg_value);
+
+	if ((pdata->family_id != reg_value) && (!pdata->ignore_id_check)) {
+		dev_err(&client->dev, "%s:Unsupported controller\n", __func__);
+		goto free_gpio;
+	}
+
+	data->family_id = pdata->family_id;
+
+	fts_i2c_client = client;
+
+	focaltech_get_upgrade_array(client);
+
+	INIT_WORK(&data->touch_event_work, fts_touch_irq_work);
+	data->ts_workqueue = create_workqueue(FTS_NAME);
+	if (!data->ts_workqueue)
+	{
+		err = -ESRCH;
+		goto exit_create_singlethread;
+	}
+
+	err = request_threaded_irq(client->irq, NULL,
+				ft5x06_ts_interrupt,
+				pdata->irqflags | IRQF_ONESHOT | IRQF_TRIGGER_FALLING,
+				client->dev.driver->name, data);
+	if (err) {
+		dev_err(&client->dev, "request irq failed\n");
+		goto free_gpio;
+	}
+
+	disable_irq(client->irq);
+	
+	err = device_create_file(&client->dev, &dev_attr_fw_name);
+	if (err) {
+		dev_err(&client->dev, "sys file creation failed\n");
+		goto irq_free;
+	}
+
+	err = device_create_file(&client->dev, &dev_attr_update_fw);
+	if (err) {
+		dev_err(&client->dev, "sys file creation failed\n");
+		goto free_fw_name_sys;
+	}
+
+	err = device_create_file(&client->dev, &dev_attr_force_update_fw);
+	if (err) {
+		dev_err(&client->dev, "sys file creation failed\n");
+		goto free_update_fw_sys;
+	}
+
+	data->dir = debugfs_create_dir(FT_DEBUG_DIR_NAME, NULL);
+	if (data->dir == NULL || IS_ERR(data->dir)) {
+		pr_err("debugfs_create_dir failed(%ld)\n", PTR_ERR(data->dir));
+		err = PTR_ERR(data->dir);
+		goto free_force_update_fw_sys;
+	}
+
+	temp = debugfs_create_file("addr", S_IRUSR | S_IWUSR, data->dir, data,
+				   &debug_addr_fops);
+	if (temp == NULL || IS_ERR(temp)) {
+		pr_err("debugfs_create_file failed: rc=%ld\n", PTR_ERR(temp));
+		err = PTR_ERR(temp);
+		goto free_debug_dir;
+	}
+
+	temp = debugfs_create_file("data", S_IRUSR | S_IWUSR, data->dir, data,
+				   &debug_data_fops);
+	if (temp == NULL || IS_ERR(temp)) {
+		pr_err("debugfs_create_file failed: rc=%ld\n", PTR_ERR(temp));
+		err = PTR_ERR(temp);
+		goto free_debug_dir;
+	}
+
+	temp = debugfs_create_file("suspend", S_IRUSR | S_IWUSR, data->dir,
+					data, &debug_suspend_fops);
+	if (temp == NULL || IS_ERR(temp)) {
+		pr_err("debugfs_create_file failed: rc=%ld\n", PTR_ERR(temp));
+		err = PTR_ERR(temp);
+		goto free_debug_dir;
+	}
+
+	temp = debugfs_create_file("dump_info", S_IRUSR | S_IWUSR, data->dir,
+					data, &debug_dump_info_fops);
+	if (temp == NULL || IS_ERR(temp)) {
+		pr_err("debugfs_create_file failed: rc=%ld\n", PTR_ERR(temp));
+		err = PTR_ERR(temp);
+		goto free_debug_dir;
+	}
+
+	data->ts_info = devm_kzalloc(&client->dev,
+				FT_INFO_MAX_LEN, GFP_KERNEL);
+	if (!data->ts_info) {
+		dev_err(&client->dev, "Not enough memory\n");
+		goto free_debug_dir;
+	}
+
+	/*get some register information */
+	reg_addr = FT_REG_POINT_RATE;
+	ft5x06_i2c_read(client, &reg_addr, 1, &reg_value, 1);
+	if (err < 0)
+		dev_err(&client->dev, "report rate read failed");
+
+	dev_info(&client->dev, "report rate = %dHz\n", reg_value * 10);
+
+	reg_addr = FT_REG_THGROUP;
+	err = ft5x06_i2c_read(client, &reg_addr, 1, &reg_value, 1);
+	if (err < 0)
+		dev_err(&client->dev, "threshold read failed");
+
+	dev_dbg(&client->dev, "touch threshold = %d\n", reg_value * 4);
+
+	ft5x06_update_fw_ver(data);
+	ft5x06_update_fw_vendor_id(data);
+
+	FT_STORE_TS_INFO(data->ts_info, data->family_id, data->pdata->name,
+			data->pdata->num_max_touches, data->pdata->group_id,
+			data->pdata->fw_vkey_support ? "yes" : "no",
+			data->pdata->fw_name, data->fw_ver[0],
+			data->fw_ver[1], data->fw_ver[2]);
+
+	#ifdef FTS_APK_DEBUG
+		fts_create_apk_debug_channel(client);
+	#endif
+
+	#ifdef FTS_GESTRUE
+	input_set_capability(tpd->dev, EV_KEY, KEY_POWER);
+	input_set_capability(tpd->dev, EV_KEY, KEY_GESTURE_U); 
+	input_set_capability(tpd->dev, EV_KEY, KEY_GESTURE_UP); 
+	input_set_capability(tpd->dev, EV_KEY, KEY_GESTURE_DOWN);
+	input_set_capability(tpd->dev, EV_KEY, KEY_GESTURE_LEFT); 
+	input_set_capability(tpd->dev, EV_KEY, KEY_GESTURE_RIGHT); 
+	input_set_capability(tpd->dev, EV_KEY, KEY_GESTURE_O);
+	input_set_capability(tpd->dev, EV_KEY, KEY_GESTURE_E); 
+	input_set_capability(tpd->dev, EV_KEY, KEY_GESTURE_M); 
+	input_set_capability(tpd->dev, EV_KEY, KEY_GESTURE_L);
+	input_set_capability(tpd->dev, EV_KEY, KEY_GESTURE_W);
+	input_set_capability(tpd->dev, EV_KEY, KEY_GESTURE_S); 
+	input_set_capability(tpd->dev, EV_KEY, KEY_GESTURE_V);
+	input_set_capability(tpd->dev, EV_KEY, KEY_GESTURE_Z);
+		
+	__set_bit(KEY_GESTURE_RIGHT, tpd->dev->keybit);
+	__set_bit(KEY_GESTURE_LEFT, tpd->dev->keybit);
+	__set_bit(KEY_GESTURE_UP, tpd->dev->keybit);
+	__set_bit(KEY_GESTURE_DOWN, tpd->dev->keybit);
+	__set_bit(KEY_GESTURE_U, tpd->dev->keybit);
+	__set_bit(KEY_GESTURE_O, tpd->dev->keybit);
+	__set_bit(KEY_GESTURE_E, tpd->dev->keybit);
+	__set_bit(KEY_GESTURE_M, tpd->dev->keybit);
+	__set_bit(KEY_GESTURE_W, tpd->dev->keybit);
+	__set_bit(KEY_GESTURE_L, tpd->dev->keybit);
+	__set_bit(KEY_GESTURE_S, tpd->dev->keybit);
+	__set_bit(KEY_GESTURE_V, tpd->dev->keybit);
+	__set_bit(KEY_GESTURE_Z, tpd->dev->keybit);
+	#endif
+
+	#ifdef CONFIG_TOUCHPANEL_PROXIMITY_SENSOR
+	i2c_prox_client = client;
+	#ifdef SENSOR_PROX_TP_USE_WAKELOCK
+	wake_lock_init(&sensor_prox_tp_wake_lock, WAKE_LOCK_SUSPEND, "prox_tp");
+	#endif
+
+	err = sysfs_create_group(&client->dev.kobj, &tp_prox_attribute_group);
+	if (err) {
+		DBG( "sysfs create failed: %d\n", err);
+	}
+
+	tp_prox_setup_polled_device(ft5x0x_ts);
+	#endif
+	
+#if defined(CONFIG_FB)
+	data->fb_notif.notifier_call = fb_notifier_callback;
+
+	err = fb_register_client(&data->fb_notif);
+
+	if (err)
+		dev_err(&client->dev, "Unable to register fb_notifier: %d\n",
+			err);
+#elif defined(CONFIG_HAS_EARLYSUSPEND)
+	data->early_suspend.level = EARLY_SUSPEND_LEVEL_BLANK_SCREEN +
+						    FT_SUSPEND_LEVEL;
+	data->early_suspend.suspend = ft5x06_ts_early_suspend;
+	data->early_suspend.resume = ft5x06_ts_late_resume;
+	register_early_suspend(&data->early_suspend);
+#endif
+
+	fts_wq_data = data;
+	enable_irq(client->irq);
+
+	return 0;
+
+free_debug_dir:
+	debugfs_remove_recursive(data->dir);
+free_force_update_fw_sys:
+	device_remove_file(&client->dev, &dev_attr_force_update_fw);
+free_update_fw_sys:
+	device_remove_file(&client->dev, &dev_attr_update_fw);
+free_fw_name_sys:
+	device_remove_file(&client->dev, &dev_attr_fw_name);
+irq_free:
+	free_irq(client->irq, data);
+free_gpio:
+	if (gpio_is_valid(pdata->reset_gpio))
+		gpio_free(pdata->reset_gpio);
+	if (gpio_is_valid(pdata->irq_gpio))
+		gpio_free(pdata->irq_gpio);
+	return err;
+exit_create_singlethread:
+	printk("==singlethread error =\n");
+	i2c_set_clientdata(client, NULL);
+	kfree(data);
+err_gpio_req:
+	if (data->ts_pinctrl) {
+		if (IS_ERR_OR_NULL(data->pinctrl_state_release)) {
+			devm_pinctrl_put(data->ts_pinctrl);
+			data->ts_pinctrl = NULL;
+		} else {
+			err = pinctrl_select_state(data->ts_pinctrl,
+					data->pinctrl_state_release);
+			if (err)
+				pr_err("failed to select relase pinctrl state\n");
+		}
+	}
+	if (pdata->power_on)
+		pdata->power_on(false);
+	else
+		ft5x06_power_on(data, false);
+pwr_deinit:
+	if (pdata->power_init)
+		pdata->power_init(false);
+	else
+		ft5x06_power_init(data, false);
+unreg_inputdev:
+	input_unregister_device(input_dev);
+	input_dev = NULL;
+free_inputdev:
+	input_free_device(input_dev);
+	return err;
+}
+
+static int ft5x06_ts_remove(struct i2c_client *client)
+{
+	struct ft5x06_ts_data *data = i2c_get_clientdata(client);
+	int retval;
+
+	cancel_work_sync(&data->touch_event_work);
+	destroy_workqueue(data->ts_workqueue);
+
+	debugfs_remove_recursive(data->dir);
+	device_remove_file(&client->dev, &dev_attr_force_update_fw);
+	device_remove_file(&client->dev, &dev_attr_update_fw);
+	device_remove_file(&client->dev, &dev_attr_fw_name);
+
+#ifdef CONFIG_TOUCHPANEL_PROXIMITY_SENSOR
+	sysfs_remove_group(&client->dev.kobj, &tp_prox_attribute_group);
+	tp_prox_teardown_polled_device(ft5x0x_ts);
+	#ifdef SENSOR_PROX_TP_USE_WAKELOCK
+	wake_lock_destroy(&sensor_prox_tp_wake_lock);
+	#endif
+#endif
+
+	#ifdef FTS_APK_DEBUG
+		fts_release_apk_debug_channel();
+	#endif
+	
+#if defined(CONFIG_FB)
+	if (fb_unregister_client(&data->fb_notif))
+		dev_err(&client->dev, "Error occurred while unregistering fb_notifier.\n");
+#elif defined(CONFIG_HAS_EARLYSUSPEND)
+	unregister_early_suspend(&data->early_suspend);
+#endif
+	free_irq(client->irq, data);
+
+	if (gpio_is_valid(data->pdata->reset_gpio))
+		gpio_free(data->pdata->reset_gpio);
+
+	if (gpio_is_valid(data->pdata->irq_gpio))
+		gpio_free(data->pdata->irq_gpio);
+
+	if (data->ts_pinctrl) {
+		if (IS_ERR_OR_NULL(data->pinctrl_state_release)) {
+			devm_pinctrl_put(data->ts_pinctrl);
+			data->ts_pinctrl = NULL;
+		} else {
+			retval = pinctrl_select_state(data->ts_pinctrl,
+					data->pinctrl_state_release);
+			if (retval < 0)
+				pr_err("failed to select release pinctrl state\n");
+		}
+	}
+
+	if (data->pdata->power_on)
+		data->pdata->power_on(false);
+	else
+		ft5x06_power_on(data, false);
+
+	if (data->pdata->power_init)
+		data->pdata->power_init(false);
+	else
+		ft5x06_power_init(data, false);
+
+	input_unregister_device(data->input_dev);
+
+	return 0;
+}
+
+static const struct i2c_device_id ft5x06_ts_id[] = {
+	{"ft5x06_ts", 0},
+	{},
+};
+
+MODULE_DEVICE_TABLE(i2c, ft5x06_ts_id);
+
+#ifdef CONFIG_OF
+static struct of_device_id ft5x06_match_table[] = {
+	{ .compatible = "focaltech,5x06",},
+	{ },
+};
+#else
+#define ft5x06_match_table NULL
+#endif
+
+static struct i2c_driver ft5x06_ts_driver = {
+	.probe = ft5x06_ts_probe,
+	.remove = ft5x06_ts_remove,
+	.driver = {
+		   .name = "ft5x06_ts",
+		   .owner = THIS_MODULE,
+		.of_match_table = ft5x06_match_table,
+#ifdef CONFIG_PM
+		   .pm = &ft5x06_ts_pm_ops,
+#endif
+		   },
+	.id_table = ft5x06_ts_id,
+};
+
+static int __init ft5x06_ts_init(void)
+{
+	return i2c_add_driver(&ft5x06_ts_driver);
+}
+module_init(ft5x06_ts_init);
+
+static void __exit ft5x06_ts_exit(void)
+{
+	i2c_del_driver(&ft5x06_ts_driver);
+}
+module_exit(ft5x06_ts_exit);
+
+MODULE_DESCRIPTION("FocalTech ft5x06 TouchScreen driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/media/platform/exynos/fimc-is-w1/Makefile b/drivers/media/platform/exynos/fimc-is-w1/Makefile
index 2309e72..5224d05 100644
--- a/drivers/media/platform/exynos/fimc-is-w1/Makefile
+++ b/drivers/media/platform/exynos/fimc-is-w1/Makefile
@@ -35,6 +35,7 @@ fimc-is-objs	:= fimc-is-core.o \
 		sensor/fimc-is-device-6a3.o \
 		sensor/fimc-is-device-imx175.o \
 		sensor/fimc-is-device-4h5.o \
-		sensor/fimc-is-device-5ea.o
+		sensor/fimc-is-device-5ea.o \
+		sensor/fimc-is-device-ov5640.o
 
 obj-$(CONFIG_VIDEO_EXYNOS_FIMC_IS) += fimc-is.o
diff --git a/drivers/media/platform/exynos/fimc-is-w1/fimc-is-config.h b/drivers/media/platform/exynos/fimc-is-w1/fimc-is-config.h
index 26fcb3a..cf6883f 100644
--- a/drivers/media/platform/exynos/fimc-is-w1/fimc-is-config.h
+++ b/drivers/media/platform/exynos/fimc-is-w1/fimc-is-config.h
@@ -78,15 +78,15 @@
  * -----------------------------------------------------------------------------
  */
 
-/* #define DEBUG */
+#define DEBUG
 #define DBG_VIDEO
 #define DBG_DEVICE
-/* #define DBG_STREAMING */
+//#define DBG_STREAMING
 #define DEBUG_INSTANCE 0xF
-/* #define BUG_ON_ENABLE */
-/* #define FIXED_FPS_DEBUG */
+#define BUG_ON_ENABLE
+#define FIXED_FPS_DEBUG
 #define FIXED_FPS_VALUE 10
-/* #define DBG_FLITEISR */
+#define DBG_FLITEISR
 #define FW_DEBUG
 #define RESERVED_MEM
 //#define SCALER_PARALLEL_MODE
diff --git a/drivers/media/platform/exynos/fimc-is-w1/fimc-is-device-csi.c b/drivers/media/platform/exynos/fimc-is-w1/fimc-is-device-csi.c
index 1ca38d1..deba9c4 100644
--- a/drivers/media/platform/exynos/fimc-is-w1/fimc-is-device-csi.c
+++ b/drivers/media/platform/exynos/fimc-is-w1/fimc-is-device-csi.c
@@ -24,6 +24,10 @@
 
 #include "fimc-is-core.h"
 #include "fimc-is-device-csi.h"
+#include <linux/interrupt.h>
+
+#include <linux/kthread.h>  // for threads
+
 
 /* PMU for FIMC-IS*/
 #define MIPICSI0_REG_BASE	(S5P_VA_MIPICSI0)   /* phy : 0x13c2_0000 */
@@ -200,7 +204,6 @@ static void s5pcsis_enable_interrupts(unsigned long __iomem *base_reg,
 			val &= ~S5PCSIS_INTMSK_FRAME_END_CH2;
 		}
 	}
-
 #if defined(CONFIG_SOC_EXYNOS5260)
 	/* FIXME: hard coded, only for rhea */
 	writel(0xFFF01037, base_reg + TO_WORD_OFFSET(S5PCSIS_INTMSK));
@@ -262,16 +265,21 @@ static void __s5pcsis_set_format(unsigned long __iomem *base_reg,
 
 	/* Color format */
 	val = readl(base_reg + TO_WORD_OFFSET(S5PCSIS_CONFIG));
+    pr_info(" - format 0x%x  (0x%x) \n",image->format.pixelformat,V4L2_PIX_FMT_YUYV);
+
 
 	if (image->format.pixelformat == V4L2_PIX_FMT_SGRBG8)
 		val = (val & ~S5PCSIS_CFG_FMT_MASK) | S5PCSIS_CFG_FMT_RAW8;
 	else if (image->format.pixelformat == V4L2_PIX_FMT_YUYV)
 		val = (val & ~S5PCSIS_CFG_FMT_MASK) | S5PCSIS_CFG_FMT_YCBCR422_8BIT;
+    else if(image->format.pixelformat == V4L2_PIX_FMT_RGB565)
+        val = (val & ~S5PCSIS_CFG_FMT_MASK) | 0x22;
 	else if (image->format.pixelformat == V4L2_PIX_FMT_MJPEG)
 		val = (val & ~S5PCSIS_CFG_FMT_MASK) | S5PCSIS_CFG_FMT_USER(1);
 	else
 		val = (val & ~S5PCSIS_CFG_FMT_MASK) | S5PCSIS_CFG_FMT_RAW10;
 
+
 #if defined(CONFIG_SOC_EXYNOS5430) || defined(CONFIG_SOC_EXYNOS5422)
 	val |= S5PCSIS_CFG_END_INTERVAL(1);
 #endif
@@ -281,7 +289,8 @@ static void __s5pcsis_set_format(unsigned long __iomem *base_reg,
 	val = (image->window.o_width << 16) | image->window.o_height;
 	writel(val, base_reg + TO_WORD_OFFSET(S5PCSIS_RESOL));
 
-	/* Output channel2 for DT */
+
+    /* Output channel2 for DT */
 	if (image->format.field == V4L2_FIELD_INTERLACED) {
 		val = readl(base_reg + TO_WORD_OFFSET(S5PCSIS_CONFIG_CH2));
 		val |= S5PCSIS_CFG_VIRTUAL_CH(2);
@@ -339,13 +348,14 @@ static void s5pcsis_set_params(unsigned long __iomem *base_reg,
 	}
 
 	/* Not using external clock. */
-	val &= ~S5PCSIS_CTRL_WCLK_EXTCLK;
+	//val &= ~S5PCSIS_CTRL_WCLK_EXTCLK;
 
 	writel(val, base_reg + TO_WORD_OFFSET(S5PCSIS_CTRL));
 
 	/* Update the shadow register. */
 	val = readl(base_reg + TO_WORD_OFFSET(S5PCSIS_CTRL));
-	writel(val | S5PCSIS_CTRL_UPDATE_SHADOW(0), base_reg + TO_WORD_OFFSET(S5PCSIS_CTRL));
+
+    writel(val | S5PCSIS_CTRL_UPDATE_SHADOW(0), base_reg + TO_WORD_OFFSET(S5PCSIS_CTRL));
 }
 
 int fimc_is_csi_open(struct v4l2_subdev *subdev)
@@ -409,7 +419,6 @@ static int csi_s_power(struct v4l2_subdev *subdev,
 	struct fimc_is_device_csi *csi;
 
 	BUG_ON(!subdev);
-
 	csi = (struct fimc_is_device_csi *)v4l2_get_subdevdata(subdev);
 	if (!csi) {
 		err("csi is NULL");
@@ -568,6 +577,48 @@ static const struct v4l2_subdev_ops subdev_ops = {
 	.video = &video_ops
 };
 
+ int csi_hw_g_interrupt(unsigned long __iomem *base_reg)
+ {
+     u32 val;
+
+     val = readl(base_reg + TO_WORD_OFFSET(S5PCSIS_INTSRC));
+     writel(val, base_reg + TO_WORD_OFFSET(S5PCSIS_INTSRC));
+
+     return val;
+ }
+
+ static irqreturn_t fimc_is_csi_isr(int irq, void *data)
+ {
+     u32 status;
+     struct fimc_is_device_csi *csi;
+
+     csi = data;
+
+     status = csi_hw_g_interrupt(csi->base_reg);
+     info("CSI%d : irq%d(%X)\n",csi->instance, irq, status);
+
+     return IRQ_HANDLED;
+ }
+
+
+int poll_irq(void *data) {
+    struct fimc_is_device_csi *csi;
+    csi = data;
+    u32 status;
+
+    /* until module unload */
+    while ( !kthread_should_stop() ) {
+
+        status = csi_hw_g_interrupt(csi->base_reg);
+        if(status != 0)
+            info("CSI%d : irqreq (%X)\n",csi->instance, status);
+        mdelay(100);
+    }
+
+    return 0;
+}
+
+
 int fimc_is_csi_probe(struct fimc_is_device_sensor *device,
 	u32 instance)
 {
@@ -596,7 +647,9 @@ int fimc_is_csi_probe(struct fimc_is_device_sensor *device,
 	switch (instance) {
 	case CSI_ID_A:
 		csi->base_reg = (unsigned long *)MIPICSI0_REG_BASE;
-		break;
+        //struct task_struct * kthread = kthread_create(poll_irq, csi, "poll_IRQ_test");
+        //wake_up_process(kthread);
+        break;
 	case CSI_ID_B:
 		csi->base_reg = (unsigned long *)MIPICSI1_REG_BASE;
 		break;
@@ -609,6 +662,7 @@ int fimc_is_csi_probe(struct fimc_is_device_sensor *device,
 		goto err_invalid_instance;
 	}
 
+
 	v4l2_subdev_init(subdev_csi, &subdev_ops);
 	v4l2_set_subdevdata(subdev_csi, csi);
 	v4l2_set_subdev_hostdata(subdev_csi, device);
diff --git a/drivers/media/platform/exynos/fimc-is-w1/fimc-is-device-sensor.c b/drivers/media/platform/exynos/fimc-is-w1/fimc-is-device-sensor.c
index 8e96623..a5e77b9 100644
--- a/drivers/media/platform/exynos/fimc-is-w1/fimc-is-device-sensor.c
+++ b/drivers/media/platform/exynos/fimc-is-w1/fimc-is-device-sensor.c
@@ -75,7 +75,7 @@ int fimc_is_sensor_read(struct i2c_client *client,
 	}
 
 	msg[0].addr = client->addr;
-	msg[0].flags = 0;
+	msg[0].flags = client->flags;
 	msg[0].len = 2;
 	msg[0].buf = wbuf;
 	wbuf[0] = array[1];
@@ -109,7 +109,7 @@ int fimc_is_sensor_write(struct i2c_client *client,
 	}
 
 	msg->addr = client->addr;
-	msg->flags = 0;
+	msg->flags = client->flags;
 	msg->len = 3;
 	msg->buf = wbuf;
 	wbuf[0] = array[1];
@@ -130,7 +130,7 @@ int fimc_is_sensor_write_burst(struct i2c_client *client,
 {
 	int ret = 0;
 	int retry_count = 5;
-	struct i2c_msg msg = {client->addr, 0, size, buf};
+	struct i2c_msg msg = {client->addr,  client->flags, size, buf};
 
 	do {
 		ret = i2c_transfer(client->adapter, &msg, 1);
@@ -161,7 +161,7 @@ int fimc_is_sensor_write16(struct i2c_client *client,
 	}
 
 	msg->addr = client->addr;
-	msg->flags = 0;
+	msg->flags = client->flags;
 	msg->len = 4;
 	msg->buf = wbuf;
 	wbuf[0] = (addr & 0xFF00) >> 8;
diff --git a/drivers/media/platform/exynos/fimc-is-w1/fimc-is-dt.c b/drivers/media/platform/exynos/fimc-is-w1/fimc-is-dt.c
index a94eeed..db389c5 100644
--- a/drivers/media/platform/exynos/fimc-is-w1/fimc-is-dt.c
+++ b/drivers/media/platform/exynos/fimc-is-w1/fimc-is-dt.c
@@ -450,7 +450,7 @@ int fimc_is_sensor_parse_dt(struct platform_device *pdev)
 	SET_PIN(pdata, SENSOR_SCENARIO_NORMAL, GPIO_SCENARIO_OFF, 1, gpio_reset, 0, NULL, PIN_INPUT);
 	SET_PIN(pdata, SENSOR_SCENARIO_NORMAL, GPIO_SCENARIO_OFF, 2, gpio_comp_rst, 0, NULL, PIN_RESET);
 	SET_PIN(pdata, SENSOR_SCENARIO_NORMAL, GPIO_SCENARIO_OFF, 3, gpio_comp_rst, 0, NULL, PIN_INPUT);
-	SET_PIN(pdata, SENSOR_SCENARIO_NORMAL, GPIO_SCENARIO_OFF, 4, gpio_comp_en, 0, NULL, PIN_INPUT);
+	SET_PIN(pdata, SENSOR_SCENARIO_NORMAL, GPIO_SCENARIO_OFF, 4, gpio_comp_en, 0, NULL, PIN_OUTPUT_HIGH);
 	SET_PIN(pdata, SENSOR_SCENARIO_NORMAL, GPIO_SCENARIO_OFF, 5, gpio_cam_en, 0, NULL, PIN_OUTPUT_LOW);
 	SET_PIN(pdata, SENSOR_SCENARIO_NORMAL, GPIO_SCENARIO_OFF, 6, gpio_none, 0, "cam_core", PIN_REGULATOR_OFF);
 	SET_PIN(pdata, SENSOR_SCENARIO_NORMAL, GPIO_SCENARIO_OFF, 7, gpio_none, 0, "cam_sensor", PIN_REGULATOR_OFF);
@@ -471,14 +471,19 @@ int fimc_is_sensor_parse_dt(struct platform_device *pdev)
 	SET_PIN(pdata, SENSOR_SCENARIO_VISION, GPIO_SCENARIO_OFF, 5, gpio_none, 0, "cam_sensor", PIN_REGULATOR_OFF);
 	SET_PIN(pdata, SENSOR_SCENARIO_VISION, GPIO_SCENARIO_OFF, 6, gpio_none, 0, NULL, PIN_END);
 
-	SET_PIN(pdata, SENSOR_SCENARIO_EXTERNAL, GPIO_SCENARIO_ON, 0, gpio_cam_en, 0, NULL, PIN_OUTPUT_HIGH);
-	SET_PIN(pdata, SENSOR_SCENARIO_EXTERNAL, GPIO_SCENARIO_ON, 1, gpio_reset, 0, NULL, PIN_RESET);
-	SET_PIN(pdata, SENSOR_SCENARIO_EXTERNAL, GPIO_SCENARIO_ON, 2, gpio_none, 0, "ch", PIN_FUNCTION);
-	SET_PIN(pdata, SENSOR_SCENARIO_EXTERNAL, GPIO_SCENARIO_ON, 3, gpio_none, 0, NULL, PIN_END);
-	SET_PIN(pdata, SENSOR_SCENARIO_EXTERNAL, GPIO_SCENARIO_OFF, 0, gpio_reset, 0, NULL, PIN_RESET);
-	SET_PIN(pdata, SENSOR_SCENARIO_EXTERNAL, GPIO_SCENARIO_OFF, 1, gpio_reset, 0, NULL, PIN_INPUT);
-	SET_PIN(pdata, SENSOR_SCENARIO_EXTERNAL, GPIO_SCENARIO_OFF, 2, gpio_cam_en, 0, NULL, PIN_OUTPUT_LOW);
+
+	SET_PIN(pdata, SENSOR_SCENARIO_EXTERNAL, GPIO_SCENARIO_ON, 2, gpio_cam_en, 0, NULL, PIN_OUTPUT_LOW);
+	SET_PIN(pdata, SENSOR_SCENARIO_EXTERNAL, GPIO_SCENARIO_ON, 0, gpio_reset, 1, NULL, PIN_RESET);
+	SET_PIN(pdata, SENSOR_SCENARIO_EXTERNAL, GPIO_SCENARIO_ON, 1, gpio_comp_en, 1, NULL, PIN_OUTPUT_HIGH);
+	SET_PIN(pdata, SENSOR_SCENARIO_EXTERNAL, GPIO_SCENARIO_ON, 3, gpio_none, 0, "ch", PIN_FUNCTION);
+	SET_PIN(pdata, SENSOR_SCENARIO_EXTERNAL, GPIO_SCENARIO_ON, 4, gpio_none, 0, NULL, PIN_END);
+
+	SET_PIN(pdata, SENSOR_SCENARIO_EXTERNAL, GPIO_SCENARIO_OFF, 0, gpio_reset, 1, NULL, PIN_OUTPUT_LOW);
+	//SET_PIN(pdata, SENSOR_SCENARIO_EXTERNAL, GPIO_SCENARIO_OFF, 1, gpio_reset, 0, NULL, PIN_INPUT);
+	SET_PIN(pdata, SENSOR_SCENARIO_EXTERNAL, GPIO_SCENARIO_OFF, 1, gpio_cam_en, 0, NULL, PIN_OUTPUT_HIGH);
+	SET_PIN(pdata, SENSOR_SCENARIO_EXTERNAL, GPIO_SCENARIO_OFF, 2, gpio_comp_en, 1, NULL, PIN_OUTPUT_LOW);
 	SET_PIN(pdata, SENSOR_SCENARIO_EXTERNAL, GPIO_SCENARIO_OFF, 3, gpio_none, 0, NULL, PIN_END);
+
 	/* Xyref5430 board revision config */
 	if ((id == SENSOR_POSITION_FRONT) && board_rev) {
 		pdata->mclk_ch = 2;
diff --git a/drivers/media/platform/exynos/fimc-is-w1/fimc-is-video-sensor.c b/drivers/media/platform/exynos/fimc-is-w1/fimc-is-video-sensor.c
index e486d35..cc3a01f5f 100644
--- a/drivers/media/platform/exynos/fimc-is-w1/fimc-is-video-sensor.c
+++ b/drivers/media/platform/exynos/fimc-is-w1/fimc-is-video-sensor.c
@@ -420,7 +420,7 @@ static int fimc_is_sen_video_qbuf(struct file *file, void *priv,
 	struct fimc_is_video_ctx *vctx = file->private_data;
 
 #ifdef DBG_STREAMING
-	/*dbg_sensor("%s\n", __func__);*/
+    mdbgv_sensor("%s\n", vctx, __func__);
 #endif
 
 	ret = fimc_is_video_qbuf(file, vctx, buf);
diff --git a/drivers/media/platform/exynos/fimc-is-w1/sensor/fimc-is-device-5ea.c b/drivers/media/platform/exynos/fimc-is-w1/sensor/fimc-is-device-5ea.c
index a0b4b2f..fe1b513 100644
--- a/drivers/media/platform/exynos/fimc-is-w1/sensor/fimc-is-device-5ea.c
+++ b/drivers/media/platform/exynos/fimc-is-w1/sensor/fimc-is-device-5ea.c
@@ -1722,7 +1722,7 @@ int sensor_5ea_probe(struct i2c_client *client,
 	ext->sensor_con.product_name = SENSOR_NAME_S5K5EA;
 	ext->sensor_con.peri_type = SE_I2C;
 	ext->sensor_con.peri_setting.i2c.channel = SENSOR_CONTROL_I2C1;
-	ext->sensor_con.peri_setting.i2c.slave_address = 0x2D;
+	ext->sensor_con.peri_setting.i2c.slave_address = 0x3D;
 	ext->sensor_con.peri_setting.i2c.speed = 400000;
 
 	ext->from_con.product_name = FROMDRV_NAME_NOTHING;
diff --git a/drivers/media/platform/exynos/fimc-is-w1/sensor/fimc-is-device-ov5640.c b/drivers/media/platform/exynos/fimc-is-w1/sensor/fimc-is-device-ov5640.c
new file mode 100644
index 0000000..4a8829b
--- /dev/null
+++ b/drivers/media/platform/exynos/fimc-is-w1/sensor/fimc-is-device-ov5640.c
@@ -0,0 +1,1368 @@
+#include <linux/i2c.h>
+#include <linux/slab.h>
+#include <linux/irq.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <linux/version.h>
+#include <linux/gpio.h>
+#include <linux/clk.h>
+#include <linux/regulator/consumer.h>
+#include <linux/videodev2.h>
+#include <linux/videodev2_exynos_camera.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/vmalloc.h>
+#include <linux/platform_device.h>
+#include <mach/regs-gpio.h>
+#include <mach/regs-clock.h>
+#include <plat/clock.h>
+#include <plat/gpio-cfg.h>
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-subdev.h>
+#include <mach/exynos-fimc-is-sensor.h>
+
+#include "../fimc-is-core.h"
+#include "../fimc-is-device-sensor.h"
+#include "../fimc-is-resourcemgr.h"
+#include "fimc-is-device-ov5640.h"
+
+static struct i2c_client *g_ov5640_i2c_client;
+
+
+/**
+ * ov5640_reg_read - Read a value from a register in an ov5640 sensor device
+ * @client: i2c driver client structure
+ * @reg: register address / offset
+ * @val: stores the value that gets read
+ *
+ * Read a value from a register in an ov5640 sensor device.
+ * The value is returned in 'val'.
+ * Returns zero if successful, or non-zero otherwise.
+ */
+static int ov5640_reg_read(struct i2c_client *client,  u16 reg, u8 *val)
+{
+    int ret;
+    u8 data[2] = {0};
+    struct i2c_msg msg = {
+            .addr	= client->addr,
+            .flags	= 0,
+            .len	= 2,
+            .buf	= data,
+    };
+
+    data[0] = (u8)(reg >> 8);
+    data[1] = (u8)(reg & 0xff);
+
+    ret = i2c_transfer(client->adapter, &msg, 1);
+    if (ret < 0)
+        goto err;
+
+    msg.flags = I2C_M_RD|I2C_CLIENT_SCCB;
+    msg.len = 1;
+    ret = i2c_transfer(client->adapter, &msg, 1);
+    if (ret < 0)
+        goto err;
+
+    *val = data[0];
+    return 0;
+
+    err:
+    dev_err(&client->dev, "Failed reading register 0x%02x!\n", reg);
+    return ret;
+}
+
+static int ov5640_i2c_read_twobyte(struct i2c_client *client,
+                                   u16 subaddr, u16 *data)
+{
+    int err;
+    unsigned char buf[2];
+    struct i2c_msg msg[2];
+    buf[0]=0;
+    buf[1]=0;
+
+    cpu_to_be16s(&subaddr);
+
+    msg[0].addr = client->addr;
+    msg[0].flags = I2C_CLIENT_SCCB;
+    msg[0].len = 2;
+    msg[0].buf = (u8 *)&subaddr;
+
+    msg[1].addr = client->addr;
+    msg[1].flags = I2C_M_RD|I2C_CLIENT_SCCB;
+    msg[1].len = 2;
+    msg[1].buf = buf;
+
+    err = i2c_transfer(client->adapter, msg, 2);
+    if (unlikely(err != 2)) {
+        dev_err(&client->dev,
+                "%s: register read fail (%d)\n", __func__,err);
+        return -EIO;
+    }
+
+    *data = ((buf[0] << 8) | buf[1]);
+
+    return 0;
+}
+
+
+/**
+ * Write a value to a register in ov5640 sensor device.
+ * @client: i2c driver client structure.
+ * @reg: Address of the register to read value from.
+ * @val: Value to be written to a specific register.
+ * Returns zero if successful, or non-zero otherwise.
+ */
+static int ov5640_reg_write(struct i2c_client *client, u16 reg, u8 val)
+{
+
+
+    return fimc_is_sensor_write(client,reg,val);
+}
+
+/**
+ * Initialize a list of ov5640 registers.
+ * The list of registers is terminated by the pair of values
+ * @client: i2c driver client structure.
+ * @reglist[]: List of address of the registers to write data.
+ * Returns zero if successful, or non-zero otherwise.
+ */
+static int ov5640_reg_writes(struct i2c_client *client,
+                             const struct ov5640_reg reglist[],
+                             int size)
+{
+    int err = 0, i;
+
+    for (i = 0; i < size; i++) {
+        if(reglist[i].reg == 0xFFFF){
+            if(reglist[i].val != 0xFF){
+                mdelay(reglist[i].val);
+            }else{
+                break;
+            }
+        }else{
+        err = ov5640_reg_write(client, reglist[i].reg,
+                         reglist[i].val);
+        }
+        if (err)
+            return err;
+    }
+    return 0;
+}
+
+static int ov5640_reg_set(struct i2c_client *client, u16 reg, u8 val)
+{
+    int ret;
+    u8 tmpval = 0;
+
+    ret = ov5640_reg_read(client, reg, &tmpval);
+    if (ret)
+        return ret;
+
+    return ov5640_reg_write(client, reg, tmpval | val);
+}
+
+static int ov5640_reg_clr(struct i2c_client *client, u16 reg, u8 val)
+{
+    int ret;
+    u8 tmpval = 0;
+
+    ret = ov5640_reg_read(client, reg, &tmpval);
+    if (ret)
+        return ret;
+
+    return ov5640_reg_write(client, reg, tmpval & ~val);
+}
+
+static unsigned long ov5640_get_pclk(struct v4l2_subdev *sd)
+{
+    struct ov5640_s *ov5640 = to_ov5640(sd);
+    unsigned long xvclk, vco, mipi_pclk;
+
+    xvclk = ov5640->xvclk;
+
+    vco = (xvclk / ov5640->clk_cfg.sc_pll_prediv) *
+          ov5640->clk_cfg.sc_pll_mult;
+
+    mipi_pclk = vco /
+                ov5640->clk_cfg.sysclk_div /
+                ov5640->clk_cfg.mipi_div;
+
+    return mipi_pclk;
+}
+
+static void ov5640_set_brightness(struct v4l2_subdev *sd, int value)
+{
+
+}
+
+static void ov5640_set_contrast(struct v4l2_subdev *sd, int value)
+{
+
+}
+
+static void ov5640_set_sharpness(struct v4l2_subdev *sd, int value)
+{
+
+}
+
+static void ov5640_set_saturation(struct v4l2_subdev *sd, int value)
+{
+
+}
+
+static void ov5640_set_iso(struct v4l2_subdev *sd, int value)
+{
+
+}
+
+static void ov5640_set_scenemode(struct v4l2_subdev *sd, int value)
+{
+
+}
+
+static void ov5640_set_white_balance(struct v4l2_subdev *sd, int value)
+{
+
+}
+
+
+static void ov5640_set_effect(struct v4l2_subdev *sd, int value)
+{
+    cam_info("%s\n", __func__);
+
+}
+
+
+
+static void ov5640_set_window(struct v4l2_subdev *sd)
+{
+
+}
+
+static void ov5640_set_af(struct v4l2_subdev *sd)
+{
+    struct i2c_client *client = g_ov5640_i2c_client;
+
+    cam_info("%s\n", __func__);
+
+}
+
+static void ov5640_cancel_af(struct v4l2_subdev *sd)
+{
+    struct i2c_client *client = g_ov5640_i2c_client;
+
+    cam_info("%s\n", __func__);
+
+}
+
+
+
+static int ov5640_s_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
+{
+
+    struct ov5640_s *ov5640  = to_ov5640(sd);
+    int value = ctrl->value;
+
+    cam_info("%s\n", __func__);
+
+    switch (ctrl->id) {
+        case V4L2_CID_SCENEMODE:
+
+            break;
+        case V4L2_CID_CAM_BRIGHTNESS:
+
+            break;
+        case V4L2_CID_WHITE_BALANCE_PRESET:
+
+            break;
+        case V4L2_CID_CAMERA_EFFECT:
+
+            break;
+        case V4L2_CID_CAM_CONTRAST:
+
+            break;
+        case V4L2_CID_CAM_SATURATION:
+
+            break;
+        case V4L2_CID_CAM_SHARPNESS:
+
+            break;
+        case V4L2_CID_CAM_ISO:
+
+            break;
+        case V4L2_CID_CAPTURE:
+
+            break;
+        case V4L2_CID_CAM_OBJECT_POSITION_X:
+
+            break;
+        case V4L2_CID_CAM_OBJECT_POSITION_Y:
+
+            break;
+        case V4L2_CID_CAM_SINGLE_AUTO_FOCUS:
+        case V4L2_CID_CAM_SET_AUTO_FOCUS:
+
+            break;
+        case V4L2_CID_FOCUS_MODE:
+        case V4L2_CID_JPEG_QUALITY:
+        case V4L2_CID_CAM_FLASH_MODE:
+            break;
+        default:
+            cam_err("[%s] Unidentified ID (%X)\n", __func__, ctrl->id);
+            break;
+    }
+
+    return 0;
+}
+
+static int ov5640_get_af(struct v4l2_subdev *sd)
+{
+
+    return 0;
+}
+
+static int ov5640_g_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
+{
+    struct ov5640_s *ov5640 = to_ov5640(sd);
+    int err = 0;
+
+    cam_info("%s\n", __func__);
+
+    switch (ctrl->id) {
+        case V4L2_CID_CAMERA_WHITE_BALANCE:
+            break;
+        case V4L2_CID_CAMERA_CONTRAST:
+            break;
+        case V4L2_CID_CAMERA_SATURATION:
+            break;
+        case V4L2_CID_CAMERA_SHARPNESS:
+            break;
+        case V4L2_CID_CAM_AUTO_FOCUS_RESULT:
+            break;
+        case V4L2_CID_CAM_DATE_INFO_YEAR:
+        case V4L2_CID_CAM_DATE_INFO_MONTH:
+        case V4L2_CID_CAM_DATE_INFO_DATE:
+        case V4L2_CID_CAM_SENSOR_VER:
+        default:
+            break;
+    }
+
+    return err;
+}
+
+static void ov5640_init_setting(struct v4l2_subdev *sd)
+{
+    struct ov5640_s *ov5640 = to_ov5640(sd);
+    int value;
+
+    cam_info("%s\n", __func__);
+
+
+}
+
+
+
+
+static int ov5640_s_power(struct v4l2_subdev *sd, int on)
+{
+    int ret= 0;
+
+    return ret;
+}
+
+
+
+
+static int ov5640_init(struct v4l2_subdev *sd, u32 val)
+{
+    struct i2c_client *client = g_ov5640_i2c_client;
+    struct ov5640_s *ov5640 = to_ov5640(sd);
+    cam_info("%s\n", __func__);
+
+    int ret = 0;
+    u8 revision = 0;
+    u8 msb;
+    u8 lsb;
+
+    ret = ov5640_s_power(sd, 1);
+    if (ret < 0) {
+        dev_err(&client->dev, "OV5640 power up failed\n");
+        return ret;
+    }
+
+    ret = ov5640_reg_read(client, 0x302A, &revision);
+    if (ret) {
+        dev_err(&client->dev, "Failure to detect OV5640 chip\n");
+        goto out;
+    }
+
+    revision &= 0xF;
+
+    dev_info(&client->dev, "Detected a OV5640 chip, revision %x\n",
+             revision);
+
+    /* SW Reset */
+    ret = ov5640_reg_set(client, 0x3008, 0x80);
+    if (ret)
+        goto out;
+
+    msleep(2);
+
+    ret = ov5640_reg_clr(client, 0x3008, 0x80);
+    if (ret)
+        goto out;
+
+    /* SW Powerdown */
+    ret = ov5640_reg_set(client, 0x3008, 0x40);
+    if (ret)
+        goto out;
+
+    /* Check chip id */
+    ret = ov5640_reg_read(client, 0x300A, &msb);
+    if (!ret)
+        ret = ov5640_reg_read(client, 0x300B, &lsb);
+    if (!ret) {
+        ov5640->id = (msb << 8) | lsb;
+        if (ov5640->id == 0x5640)
+            dev_info(&client->dev, "Sensor ID: %04X\n", ov5640->id);
+        else
+            dev_err(&client->dev, "Sensor detection failed (%04X, %d)\n",
+                    ov5640->id, ret);
+    }
+
+   ret = ov5640_reg_writes(client, configscript_common1,
+                            ARRAY_SIZE(configscript_common1));
+    if (ret)
+        goto out;
+
+    ret = ov5640_reg_writes(client, configscript_common2,
+                        ARRAY_SIZE(configscript_common2));
+    if (ret)
+      goto out;
+
+    //ret = ov5640_reg_writes(client, configscript_common_XXX,
+    //                        ARRAY_SIZE(configscript_common_XXX));
+    //if (ret)
+    //    goto out;
+
+    cam_info("%s\n",__func__);
+    /* Init controls */
+    /*
+    ret = v4l2_ctrl_handler_init(&ov5640->ctrl_handler, 1);
+    if (ret)
+        goto out;
+
+    ov5640->pixel_rate = v4l2_ctrl_new_std(
+            &ov5640->ctrl_handler, NULL,
+            V4L2_CID_PIXEL_RATE,
+            0, 0, 1, 0);
+
+    sd->ctrl_handler = &ov5640->ctrl_handler;
+    */
+    out:
+    ov5640_s_power(sd, 0);
+    return ret;
+}
+
+static int ov5640_s_ext_ctrls(struct v4l2_subdev *sd,
+                              struct v4l2_ext_controls *ctrls)
+{
+    cam_info("%s\n", __func__);
+
+    return 0;
+}
+
+
+
+
+static int ov5640_queryctrl(struct v4l2_subdev *sd, struct v4l2_queryctrl *qc)
+{
+    cam_info("%s\n", __func__);
+
+    return 0;
+}
+
+static int ov5640_querymenu(struct v4l2_subdev *sd, struct v4l2_querymenu *qm)
+{
+    cam_info("%s\n", __func__);
+
+    return 0;
+}
+
+static int ov5640_g_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *fmt)
+{
+    cam_info("%s\n", __func__);
+
+    return 0;
+}
+
+static int ov5640_s_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *fmt)
+{
+
+    return 0;
+}
+
+
+static int ov5640_config_timing(struct v4l2_subdev *sd)
+{
+    struct i2c_client *client = g_ov5640_i2c_client;;
+    struct ov5640_s *ov5640 = to_ov5640(sd);
+    int ret, i;
+    u8 val;
+
+    i = ov5640_find_framesize(ov5640->format.width, ov5640->format.height);
+
+    ret = ov5640_reg_write(client,
+                           0x3800,
+                           (timing_cfg[i].x_addr_start & 0xFF00) >> 8);
+    if (ret)
+        return ret;
+
+    ret = ov5640_reg_write(client,
+                           0x3801,
+                           timing_cfg[i].x_addr_start & 0xFF);
+    if (ret)
+        return ret;
+
+    ret = ov5640_reg_write(client,
+                           0x3802,
+                           (timing_cfg[i].y_addr_start & 0xFF00) >> 8);
+    if (ret)
+        return ret;
+
+    ret = ov5640_reg_write(client,
+                           0x3803,
+                           timing_cfg[i].y_addr_start & 0xFF);
+    if (ret)
+        return ret;
+
+    ret = ov5640_reg_write(client,
+                           0x3804,
+                           (timing_cfg[i].x_addr_end & 0xFF00) >> 8);
+    if (ret)
+        return ret;
+
+    ret = ov5640_reg_write(client,
+                           0x3805,
+                           timing_cfg[i].x_addr_end & 0xFF);
+    if (ret)
+        return ret;
+
+    ret = ov5640_reg_write(client,
+                           0x3806,
+                           (timing_cfg[i].y_addr_end & 0xFF00) >> 8);
+    if (ret)
+        return ret;
+
+    ret = ov5640_reg_write(client,
+                           0x3807,
+                           timing_cfg[i].y_addr_end & 0xFF);
+    if (ret)
+        return ret;
+
+    ret = ov5640_reg_write(client,
+                           0x3808,
+                           (timing_cfg[i].h_output_size & 0xFF00) >> 8);
+    if (ret)
+        return ret;
+
+    ret = ov5640_reg_write(client,
+                           0x3809,
+                           timing_cfg[i].h_output_size & 0xFF);
+    if (ret)
+        return ret;
+
+    ret = ov5640_reg_write(client,
+                           0x380A,
+                           (timing_cfg[i].v_output_size & 0xFF00) >> 8);
+    if (ret)
+        return ret;
+
+    ret = ov5640_reg_write(client,
+                           0x380B,
+                           timing_cfg[i].v_output_size & 0xFF);
+    if (ret)
+        return ret;
+
+    ret = ov5640_reg_write(client,
+                           0x380C,
+                           (timing_cfg[i].h_total_size & 0xFF00) >> 8);
+    if (ret)
+        return ret;
+
+    ret = ov5640_reg_write(client,
+                           0x380D,
+                           timing_cfg[i].h_total_size & 0xFF);
+    if (ret)
+        return ret;
+
+    ret = ov5640_reg_write(client,
+                           0x380E,
+                           (timing_cfg[i].v_total_size & 0xFF00) >> 8);
+    if (ret)
+        return ret;
+
+    ret = ov5640_reg_write(client,
+                           0x380F,
+                           timing_cfg[i].v_total_size & 0xFF);
+    if (ret)
+        return ret;
+
+    ret = ov5640_reg_write(client,
+                           0x3810,
+                           (timing_cfg[i].isp_h_offset & 0xFF00) >> 8);
+    if (ret)
+        return ret;
+
+    ret = ov5640_reg_write(client,
+                           0x3811,
+                           timing_cfg[i].isp_h_offset & 0xFF);
+    if (ret)
+        return ret;
+
+    ret = ov5640_reg_write(client,
+                           0x3812,
+                           (timing_cfg[i].isp_v_offset & 0xFF00) >> 8);
+    if (ret)
+        return ret;
+
+    ret = ov5640_reg_write(client,
+                           0x3813,
+                           timing_cfg[i].isp_v_offset & 0xFF);
+    if (ret)
+        return ret;
+
+    ret = ov5640_reg_write(client,
+                           0x3814,
+                           ((timing_cfg[i].h_odd_ss_inc & 0xF) << 4) |
+                           (timing_cfg[i].h_even_ss_inc & 0xF));
+    if (ret)
+        return ret;
+
+    ret = ov5640_reg_write(client,
+                           0x3815,
+                           ((timing_cfg[i].v_odd_ss_inc & 0xF) << 4) |
+                           (timing_cfg[i].v_even_ss_inc & 0xF));
+
+    ov5640_reg_read(client, OV5640_TIMING_REG21, &val);
+    if (timing_cfg[i].out_mode_sel & OV5640_BINNING_MASK)
+        val |= OV5640_BINNING_MASK;
+    else
+        val &= ~(OV5640_BINNING_MASK);
+
+    if (0)
+        val |= OV5640_HFLIP_MASK;
+    else
+        val &= ~(OV5640_HFLIP_MASK);
+
+    ret = ov5640_reg_write(client, OV5640_TIMING_REG21, val);
+    if (ret)
+        return ret;
+
+
+    ret = ov5640_reg_write(client,
+                           0x3108, timing_cfg[i].sclk_dividers & 0xFF);
+    if (ret)
+        return ret;
+
+    ret = ov5640_reg_write(client, 0x3035, timing_cfg[i].sys_mipi_clk & 0xFF);
+    if (ret)
+        return ret;
+
+/*
+    ov5640_reg_writes(client, ov5640_fps_30,
+                      ARRAY_SIZE(ov5640_fps_30));
+*/
+    return ret;
+}
+
+
+static int ov5640_s_stream(struct v4l2_subdev *sd, int enable)
+{
+    struct ov5640_s *ov5640 = to_ov5640(sd);
+    struct i2c_client *client = g_ov5640_i2c_client;
+    int ret = 0;
+
+    if (enable) {
+        ov5640_s_power(&ov5640->sd, 1);
+        u8 fmtreg = 0, fmtmuxreg = 0;
+        int i;
+        cam_info("%s: 0x%x\n", __func__,ov5640->format.code);
+        switch ((u32)ov5640->format.code) {
+            case V4L2_MBUS_FMT_UYVY8_2X8:
+                fmtreg = 0x32;
+                fmtmuxreg = 0;
+                break;
+            case V4L2_MBUS_FMT_YUYV8_2X8:
+                fmtreg = 0x30;
+                fmtmuxreg = 0;
+                break;
+            case V4L2_PIX_FMT_RGB565:
+                fmtreg = 0x60;
+                fmtmuxreg = 1;
+            default:
+                /* This shouldn't happen */
+                ret = -EINVAL;
+                return ret;
+        }
+
+        ret = ov5640_reg_write(client, 0x4300, fmtreg);
+        if (ret)
+            return ret;
+
+        ret = ov5640_reg_write(client, 0x501F, fmtmuxreg);
+        if (ret)
+            return ret;
+
+        ret = ov5640_config_timing(sd);
+        if (ret)
+            return ret;
+       // ov5640_reg_write(client, 0x4202, 0x00);
+
+
+        i = ov5640_find_framesize(ov5640->format.width, ov5640->format.height);
+
+        if ((i == OV5640_SIZE_QVGA) ||
+            (i == OV5640_SIZE_VGA) ||
+            (i == OV5640_SIZE_720P)) {
+            //ret = ov5640_reg_write(client, 0x3108,
+            //                       (i == OV5640_SIZE_720P) ? 0x1 : 0);
+            if (ret)
+                return ret;
+            //ret = ov5640_reg_set(client, 0x5001, 0x20);
+        } else {
+            //ret = ov5640_reg_clr(client, 0x5001, 0x20);
+            if (ret)
+                return ret;
+            //ret = ov5640_reg_write(client, 0x3108, 0x2);
+        }
+
+        ret = ov5640_reg_clr(client, 0x3008, 0x40);
+        if (ret)
+            goto out;
+
+    } else {
+
+        u8 tmpreg = 0;
+
+        ret = ov5640_reg_read(client, 0x3008, &tmpreg);
+        if (ret)
+            goto out;
+
+        ret = ov5640_reg_write(client, 0x3008, tmpreg | 0x40);
+        if (ret)
+            goto out;
+
+        //ov5640_reg_write(client, 0x4202, 0x0f);
+
+        ov5640_s_power(&ov5640->sd, 0);
+    }
+
+    out:
+    return ret;
+}
+
+static int ov5640_g_parm(struct v4l2_subdev *sd,
+                         struct v4l2_streamparm *param)
+{
+    cam_info("%s\n", __func__);
+
+    return 0;
+}
+
+static int ov5640_s_parm(struct v4l2_subdev *sd,
+                         struct v4l2_streamparm *param)
+{
+    int ret = 0;
+    cam_info("%s\n", __func__);
+    struct fimc_is_module_enum *module;
+    struct v4l2_captureparm *cp;
+    struct v4l2_fract *tpf;
+    u64 framerate;
+
+    BUG_ON(!sd);
+    BUG_ON(!param);
+
+    cp = &param->parm.capture;
+    tpf = &cp->timeperframe;
+
+    if (!tpf->numerator) {
+        err("numerator is 0");
+        ret = -EINVAL;
+        goto p_err;
+    }
+
+    framerate = tpf->denominator;
+
+    module = (struct fimc_is_module_enum *)v4l2_get_subdevdata(sd);
+    if (!module) {
+        err("module is NULL");
+        ret = -EINVAL;
+        goto p_err;
+    }
+
+    ret = CALL_MOPS(module, s_duration, sd, framerate);
+    if (ret) {
+        err("s_duration is fail(%d)", ret);
+        goto p_err;
+    }
+    p_err:
+
+    return ret;
+}
+
+static int ov5640_enum_framesizes(struct v4l2_subdev *subdev,
+                                  struct v4l2_subdev_fh *fh,
+                                  struct v4l2_subdev_frame_size_enum *fse)
+{
+    cam_info("%s %d %d\n", __func__,fse->index,fse->code);
+    if ((fse->index >= OV5640_SIZE_LAST) ||
+        (fse->code != V4L2_MBUS_FMT_UYVY8_2X8 &&
+         fse->code != V4L2_MBUS_FMT_YUYV8_2X8))
+        return -EINVAL;
+    cam_info("%s\n", __func__);
+    fse->min_width = ov5640_frmsizes[fse->index].width;
+    fse->max_width = fse->min_width;
+    fse->min_height = ov5640_frmsizes[fse->index].height;
+    fse->max_height = fse->min_height;
+
+    return 0;
+}
+
+/*
+ * Clock configuration
+ * Configure expected MCLK from host and return EINVAL if not supported clock
+ * frequency is expected
+ *  freq : in Hz
+ *  flag : not supported for now
+ */
+static int ov5640_s_crystal_freq(struct v4l2_subdev *sd,
+                                 u32  freq, u32 flags)
+{
+    cam_info("%s\n", __func__);
+
+    return 0;
+}
+
+
+static int ov5640_enum_frameintervals(struct v4l2_subdev *sd,
+                                      struct v4l2_frmivalenum *interval)
+{
+    int size;
+
+    if (interval->index >= 1)
+        return -EINVAL;
+
+    interval->type = V4L2_FRMIVAL_TYPE_DISCRETE;
+
+    size = ov5640_find_framesize(interval->width, interval->height);
+
+    switch (size) {
+        case OV5640_SIZE_5MP:
+            interval->discrete.numerator	= 2;
+            interval->discrete.denominator	= 15;
+            break;
+        case OV5640_SIZE_720P:
+            interval->discrete.numerator	= 1;
+            interval->discrete.denominator	= 0;
+            break;
+        case OV5640_SIZE_VGA:
+        case OV5640_SIZE_QVGA:
+        default:
+            interval->discrete.numerator	= 1;
+            interval->discrete.denominator	= 24;
+            break;
+    }
+    return 0;
+}
+
+
+/* get format by flite video device command */
+static struct v4l2_mbus_framefmt *
+__ov5640_get_pad_format(struct ov5640_s *ov5640, struct v4l2_subdev_fh *fh,
+                        unsigned int pad, enum v4l2_subdev_format_whence which)
+{
+    switch (which) {
+        case V4L2_SUBDEV_FORMAT_TRY:
+            return v4l2_subdev_get_try_format(fh, pad);
+        case V4L2_SUBDEV_FORMAT_ACTIVE:
+            return &ov5640->format;
+        default:
+            return NULL;
+    }
+}
+
+static int ov5640_get_fmt(struct v4l2_subdev *sd,
+                        struct v4l2_subdev_fh *fh,
+                        struct v4l2_subdev_format *format)
+{
+    struct ov5640_s *ov5640 = to_ov5640(sd);
+    cam_info("%s\n", __func__);
+
+    format->format = *__ov5640_get_pad_format(ov5640, fh, format->pad,
+                                              format->which);
+
+    return 0;
+}
+
+
+/* set format by flite video device command */
+
+static int ov5640_set_fmt(struct v4l2_subdev *sd,
+                        struct v4l2_subdev_fh *fh,
+                        struct v4l2_subdev_format *format)
+{
+    struct ov5640_s *ov5640 = to_ov5640(sd);
+    struct v4l2_mbus_framefmt *__format;
+
+    __format = __ov5640_get_pad_format(ov5640, fh, format->pad,
+                                       format->which);
+
+    ov5640->pixel_rate->cur.val64 = ov5640_get_pclk(sd) / 16;
+
+    return 0;
+}
+
+
+static int ov5640_enum_mbus_code(struct v4l2_subdev *sd,
+                                 struct v4l2_subdev_fh *fh,
+                                 struct v4l2_subdev_mbus_code_enum *code)
+{
+    cam_info("%s\n", __func__);
+    if (code->index >= 2)
+        return -EINVAL;
+
+    switch (code->index) {
+        case 0:
+            code->code = V4L2_MBUS_FMT_UYVY8_2X8;
+            break;
+        case 1:
+            code->code = V4L2_MBUS_FMT_YUYV8_2X8;
+            break;
+    }
+
+    return 0;
+}
+
+
+static int ov5640_g_skip_frames(struct v4l2_subdev *sd, u32 *frames)
+{
+    /* Quantity of initial bad frames to skip. Revisit. */
+    *frames = 3;
+
+    return 0;
+}
+
+static const struct v4l2_subdev_video_ops ov5640_video_ops = {
+        .g_mbus_fmt         = ov5640_g_fmt,
+        .s_mbus_fmt         = ov5640_s_fmt,
+        .g_parm             = ov5640_g_parm,
+        .s_parm             = ov5640_s_parm,
+        .s_stream           = ov5640_s_stream,
+        .enum_framesizes    = ov5640_enum_framesizes,
+        .s_crystal_freq     = ov5640_s_crystal_freq,
+        .enum_frameintervals = ov5640_enum_frameintervals,
+};
+
+static const struct v4l2_subdev_core_ops ov5640_core_ops = {
+        .g_ctrl         = ov5640_g_ctrl,
+        .s_ctrl         = ov5640_s_ctrl,
+        .init           = ov5640_init,  /* initializing API */
+        .s_ext_ctrls    = ov5640_s_ext_ctrls,
+        .s_power        = ov5640_s_power,
+        .queryctrl      = ov5640_queryctrl,
+        .querymenu      = ov5640_querymenu,
+};
+
+
+static struct v4l2_subdev_pad_ops ov5640_pad_ops = {
+        .enum_mbus_code = ov5640_enum_mbus_code,
+        .enum_frame_size = ov5640_enum_framesizes,
+        .get_fmt        = ov5640_get_fmt,
+        .set_fmt        = ov5640_set_fmt,
+};
+
+static struct v4l2_subdev_sensor_ops ov5640_sensor_ops = {
+        .g_skip_frames	= ov5640_g_skip_frames,
+};
+
+static const struct v4l2_subdev_ops ov5640_ops = {
+        .core   = &ov5640_core_ops,
+        .pad    = &ov5640_pad_ops,
+        .video  = &ov5640_video_ops,
+        //.sensor	= &ov5640_sensor_ops,
+};
+
+
+
+/*
+ * @ brief
+ * frame duration time
+ * @ unit
+ * nano second
+ * @ remarks
+ */
+int sensor_ov5640_s_duration(struct v4l2_subdev *subdev, u64 framerate)
+{
+    int ret = 0;
+    u32 frametime;
+    struct i2c_client *client = g_ov5640_i2c_client;
+    struct ov5640_s *ov5640 = to_ov5640(subdev);
+    cam_info("%s\n", __func__);
+
+
+
+p_err:
+    return ret;
+}
+
+int sensor_ov5640_g_min_duration(struct v4l2_subdev *subdev)
+{
+    int ret = 0;
+
+    cam_info("%s\n", __func__);
+
+    return ret;
+}
+
+int sensor_ov5640_g_max_duration(struct v4l2_subdev *subdev)
+{
+    int ret = 0;
+
+    cam_info("%s\n", __func__);
+
+    return ret;
+}
+
+int sensor_ov5640_s_exposure(struct v4l2_subdev *subdev, u64 exposure)
+{
+    int ret = 0;
+
+    return ret;
+}
+
+int sensor_ov5640_g_min_exposure(struct v4l2_subdev *subdev)
+{
+    int ret = 0;
+
+    cam_info("%s\n", __func__);
+
+    return ret;
+}
+
+int sensor_ov5640_g_max_exposure(struct v4l2_subdev *subdev)
+{
+    int ret = 0;
+
+    cam_info("%s\n", __func__);
+
+    return ret;
+}
+
+int sensor_ov5640_s_again(struct v4l2_subdev *subdev, u64 sensitivity)
+{
+    int ret = 0;
+
+    cam_info("%s\n", __func__);
+
+    return ret;
+}
+
+int sensor_ov5640_g_min_again(struct v4l2_subdev *subdev)
+{
+    int ret = 0;
+
+    cam_info("%s\n", __func__);
+
+    return ret;
+}
+
+int sensor_ov5640_g_max_again(struct v4l2_subdev *subdev)
+{
+    int ret = 0;
+
+    cam_info("%s\n", __func__);
+
+    return ret;
+}
+
+int sensor_ov5640_s_dgain(struct v4l2_subdev *subdev)
+{
+    int ret = 0;
+
+    cam_info("%s\n", __func__);
+
+    return ret;
+}
+
+int sensor_ov5640_g_min_dgain(struct v4l2_subdev *subdev)
+{
+    int ret = 0;
+
+    cam_info("%s\n", __func__);
+
+    return ret;
+}
+
+int sensor_ov5640_g_max_dgain(struct v4l2_subdev *subdev)
+{
+    int ret = 0;
+
+    cam_info("%s\n", __func__);
+
+    return ret;
+}
+
+
+
+struct fimc_is_sensor_ops module_ov5640_ops = {
+/*    	.stream_on		= sensor_ov5640_stream_on,
+	    .stream_off		= sensor_ov5640_stream_off,
+	    */
+        .s_duration		= sensor_ov5640_s_duration,
+        .g_min_duration	= sensor_ov5640_g_min_duration,
+        .g_max_duration	= sensor_ov5640_g_max_duration,
+        .s_exposure		= sensor_ov5640_s_exposure,
+        .g_min_exposure	= sensor_ov5640_g_min_exposure,
+        .g_max_exposure	= sensor_ov5640_g_max_exposure,
+        .s_again		= sensor_ov5640_s_again,
+        .g_min_again	= sensor_ov5640_g_min_again,
+        .g_max_again	= sensor_ov5640_g_max_again,
+        .s_dgain		= sensor_ov5640_s_dgain,
+        .g_min_dgain	= sensor_ov5640_g_min_dgain,
+        .g_max_dgain	= sensor_ov5640_g_max_dgain
+};
+
+static int ov5640_link_setup(struct media_entity *entity,
+                             const struct media_pad *local,
+                             const struct media_pad *remote, u32 flags)
+{
+    cam_info("%s\n", __func__);
+
+    return 0;
+}
+
+
+static const struct media_entity_operations ov5640_media_ops = {
+        .link_setup = ov5640_link_setup,
+};
+
+static int ov5640_open(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)
+{
+    cam_info("%s\n", __func__);
+    struct v4l2_mbus_framefmt *format;
+
+    format = v4l2_subdev_get_try_format(fh, 0);
+    format->code = V4L2_MBUS_FMT_UYVY8_2X8; //V4L2_MBUS_FMT_YUYV8_2X8;/*V4L2_MBUS_FMT_UYVY8_2X8;*/
+    format->width = ov5640_frmsizes[OV5640_SIZE_VGA].width;
+    format->height = ov5640_frmsizes[OV5640_SIZE_VGA].height;
+    format->field = V4L2_FIELD_NONE;
+    format->colorspace = V4L2_COLORSPACE_JPEG;
+
+    return 0;
+}
+
+static int ov5640_close(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)
+{
+    cam_info("%s\n", __func__);
+
+    return 0;
+}
+
+static int ov5640_registered(struct v4l2_subdev *sd)
+{
+    cam_info("%s\n", __func__);
+
+    return 0;
+}
+
+static void ov5640_unregistered(struct v4l2_subdev *sd)
+{
+    cam_info("%s\n", __func__);
+}
+
+
+static const struct v4l2_subdev_internal_ops ov5640_subdev_internal_ops = {
+        .open           = ov5640_open,
+        .close          = ov5640_close,
+        .registered     = ov5640_registered,
+        .unregistered   = ov5640_unregistered,
+};
+
+
+int sensor_ov5640_probe(struct i2c_client *client,
+                        const struct i2c_device_id *id)
+{
+    int ret = 0;
+    struct fimc_is_core *core;
+    struct fimc_is_module_enum *module;
+    struct fimc_is_device_sensor *device;
+    struct sensor_open_extended *ext;
+    struct v4l2_subdev *sd;
+
+    struct ov5640_s *ov5640;
+
+    cam_info("%s\n", __func__);
+
+    BUG_ON(!fimc_is_dev);
+
+    core = (struct fimc_is_core *)dev_get_drvdata(fimc_is_dev);
+    if (!core) {
+        err("core device is not yet probed");
+        return -EPROBE_DEFER;
+    }
+
+    device = &core->sensor[SENSOR_OV5640_INSTANCE];
+
+    ov5640 = kzalloc(sizeof(struct ov5640_s), GFP_KERNEL);
+    if (ov5640 == NULL) {
+        dev_err(&client->dev, "OV5640 probe error : kzalloc\n");
+        return -ENOMEM;
+    }
+
+    /*
+    ret = ov5640_get_resources(ov5640, &client->dev);
+    if (ret) {
+        kfree(ov5640);
+        return ret;
+    }
+    */
+    ov5640->xvclk= 24000000;
+    ov5640->format.code = V4L2_MBUS_FMT_UYVY8_2X8;/*V4L2_MBUS_FMT_YUYV8_2X8;*/
+    ov5640->format.width = ov5640_frmsizes[OV5640_SIZE_5MP].width;
+    ov5640->format.height = ov5640_frmsizes[OV5640_SIZE_5MP].height;
+    ov5640->format.field = V4L2_FIELD_NONE;
+    ov5640->format.colorspace = V4L2_COLORSPACE_JPEG;
+
+    ov5640->clk_cfg.sc_pll_prediv = 2;
+    ov5640->clk_cfg.sc_pll_rdiv = 1;
+    ov5640->clk_cfg.sc_pll_mult = 0x40 ;
+    ov5640->clk_cfg.sysclk_div = 1;
+    ov5640->clk_cfg.mipi_div = 1;
+
+    sd = &ov5640->sd;
+    g_ov5640_i2c_client = client;
+    g_ov5640_i2c_client->flags |= I2C_CLIENT_SCCB;
+
+
+    /* OV5640 */
+    module = &device->module_enum[atomic_read
+            (&core->resourcemgr.rsccount_module)];
+    atomic_inc(&core->resourcemgr.rsccount_module);
+    module->id = SENSOR_OV5640_NAME;
+    module->subdev = sd;
+    module->device = SENSOR_OV5640_INSTANCE;
+    module->ops = &module_ov5640_ops;
+    module->client = client;
+    module->active_width = OV5640_SENSOR_SIZE_X;
+    module->active_height = OV5640_SENSOR_SIZE_Y;
+    module->pixel_width = module->active_width + BLANKING_EXTRA_WIDTH;
+    module->pixel_height = BLANKING_MIN_HEIGHT;
+
+    module->max_framerate = 120;
+
+    module->position = SENSOR_POSITION_FRONT;
+
+    module->setfile_name = "setfile_ov5640.bin";
+    module->cfgs = ARRAY_SIZE(config_ov5640);
+    module->cfg = config_ov5640;
+    module->private_data = kzalloc(sizeof(struct fimc_is_module_ov5640),
+                                   GFP_KERNEL);
+    if (!module->private_data) {
+        err("private_data is NULL");
+        ret = -ENOMEM;
+        goto p_err;
+    }
+
+    ext = &module->ext;
+    ext->mipi_lane_num = 2;
+    ext->I2CSclk = I2C_L1;
+    ext->sensor_con.product_name = SENSOR_NAME_OV5640;
+    ext->sensor_con.peri_type = SE_I2C;
+    ext->sensor_con.peri_setting.i2c.channel = SENSOR_CONTROL_I2C1;
+    ext->sensor_con.peri_setting.i2c.slave_address = 0x3c;
+    ext->sensor_con.peri_setting.i2c.speed = 400000;
+
+    ext->from_con.product_name = FROMDRV_NAME_NOTHING;
+    ext->companion_con.product_name = COMPANION_NAME_NOTHING;
+
+    v4l2_i2c_subdev_init(sd, client, &ov5640_ops);
+
+    /* Registering subdev */
+    ret = media_entity_init(&sd->entity, 1, &ov5640->pad, 0);
+    if (ret) {
+        dev_err(&client->dev, "OV5640 probe error : media entity\n");
+        return ret;
+    }
+    sd->entity.type = MEDIA_ENT_T_V4L2_SUBDEV_SENSOR;
+    sd->entity.ops = &ov5640_media_ops;
+    sd->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
+    sd->internal_ops = &ov5640_subdev_internal_ops;
+
+
+    v4l2_set_subdevdata(sd, module);
+    v4l2_set_subdev_hostdata(sd, device);
+
+
+    snprintf(sd->name, V4L2_SUBDEV_NAME_SIZE,
+             "sensor-subdev.%d", module->id);
+
+    p_err:
+    info("%s(%d)\n", __func__, ret);
+    return ret;
+}
+
+static int sensor_ov5640_remove(struct i2c_client *client)
+{
+    int ret = 0;
+
+    cam_info("%s\n", __func__);
+
+    return ret;
+}
+
+#ifdef CONFIG_OF
+static const struct of_device_id exynos_fimc_is_sensor_ov5640_match[] = {
+	{
+		.compatible = "samsung,exynos5-fimc-is-sensor-ov5640",
+	},
+	{},
+};
+#endif
+
+static const struct i2c_device_id sensor_ov5640_idt[] = {
+        { SENSOR_NAME, 0 },
+};
+
+static struct i2c_driver sensor_ov5640_driver = {
+        .driver = {
+                .name	= SENSOR_NAME,
+                .owner	= THIS_MODULE,
+#ifdef CONFIG_OF
+                .of_match_table = exynos_fimc_is_sensor_ov5640_match
+#endif
+        },
+        .probe	= sensor_ov5640_probe,
+        .remove	= sensor_ov5640_remove,
+        .id_table = sensor_ov5640_idt
+};
+
+static int __init sensor_ov5640_load(void)
+{
+    cam_info("%s\n", __func__);
+    return i2c_add_driver(&sensor_ov5640_driver);
+}
+
+static void __exit sensor_ov5640_unload(void)
+{
+    cam_info("%s\n", __func__);
+    i2c_del_driver(&sensor_ov5640_driver);
+}
+
+module_init(sensor_ov5640_load);
+module_exit(sensor_ov5640_unload);
+
+MODULE_AUTHOR("Danilo Sia");
+MODULE_DESCRIPTION("Sensor LI-OV5640 driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/media/platform/exynos/fimc-is-w1/sensor/fimc-is-device-ov5640.h b/drivers/media/platform/exynos/fimc-is-w1/sensor/fimc-is-device-ov5640.h
new file mode 100644
index 0000000..4635651
--- /dev/null
+++ b/drivers/media/platform/exynos/fimc-is-w1/sensor/fimc-is-device-ov5640.h
@@ -0,0 +1,995 @@
+#ifndef FIMC_IS_DEVICE_OV5640_H
+#define FIMC_IS_DEVICE_OV5640_H
+
+#define SENSOR_OV5640_INSTANCE	0
+#define SENSOR_NAME_OV5640      SENSOR_NAME_SR261 + 1
+#define SENSOR_OV5640_NAME		SENSOR_NAME_OV5640
+#define SENSOR_OV5640_DRIVING
+
+#define TAG_NAME	"[OV5640] "
+#define cam_err(fmt, ...)	\
+	pr_err(TAG_NAME fmt, ##__VA_ARGS__)
+#define cam_warn(fmt, ...)	\
+	pr_warn(TAG_NAME fmt, ##__VA_ARGS__)
+#define cam_info(fmt, ...)	\
+	pr_info(TAG_NAME fmt, ##__VA_ARGS__)
+#if defined(CONFIG_CAM_DEBUG)
+#define cam_dbg(fmt, ...)	\
+	pr_debug(TAG_NAME fmt, ##__VA_ARGS__)
+#else
+#define cam_dbg(fmt, ...)
+#endif
+
+#define SENSOR_NAME "OV5640"
+
+/* active pixel array size */
+#define OV5640_SENSOR_SIZE_X	2592
+#define OV5640_SENSOR_SIZE_Y	1944
+
+#define OV5640_MAX_WIDTH	OV5640_SENSOR_SIZE_X
+#define OV5640_MAX_HEIGHT	720
+
+/* default sizes */
+#define OV5640_DEFAULT_WIDTH	1280
+#define OV5640_DEFAULT_HEIGHT	OV5640_MAX_HEIGHT
+
+/* minimum extra blanking */
+#define BLANKING_EXTRA_WIDTH		500
+#define BLANKING_EXTRA_HEIGHT		20
+
+/*
+ * the sensor's autoexposure is buggy when setting total_height low.
+ * It tries to expose longer than 1 frame period without taking care of it
+ * and this leads to weird output. So we set 1000 lines as minimum.
+ */
+#define BLANKING_MIN_HEIGHT		1000
+
+
+#define DEFAULT_SENSOR_WIDTH						1280
+#define DEFAULT_SENSOR_HEIGHT						OV5640_MAX_HEIGHT
+
+#define DEFAULT_SENSOR_CODE		MEDIA_BUS_FMT_YUYV8_2X8
+#define SENSOR_MEMSIZE	(DEFAULT_SENSOR_WIDTH * DEFAULT_SENSOR_HEIGHT)
+
+
+/* OV5642 registers */
+#define REG_CHIP_ID_HIGH		0x300a
+#define REG_CHIP_ID_LOW			0x300b
+
+#define REG_WINDOW_START_X_HIGH		0x3800
+#define REG_WINDOW_START_X_LOW		0x3801
+#define REG_WINDOW_START_Y_HIGH		0x3802
+#define REG_WINDOW_START_Y_LOW		0x3803
+#define REG_WINDOW_WIDTH_HIGH		0x3804
+#define REG_WINDOW_WIDTH_LOW		0x3805
+#define REG_WINDOW_HEIGHT_HIGH		0x3806
+#define REG_WINDOW_HEIGHT_LOW		0x3807
+#define REG_OUT_WIDTH_HIGH		0x3808
+#define REG_OUT_WIDTH_LOW		0x3809
+#define REG_OUT_HEIGHT_HIGH		0x380a
+#define REG_OUT_HEIGHT_LOW		0x380b
+#define REG_OUT_TOTAL_WIDTH_HIGH	0x380c
+#define REG_OUT_TOTAL_WIDTH_LOW		0x380d
+#define REG_OUT_TOTAL_HEIGHT_HIGH	0x380e
+#define REG_OUT_TOTAL_HEIGHT_LOW	0x380f
+#define REG_OUTPUT_FORMAT		0x4300
+#define REG_ISP_CTRL_01			0x5001
+#define REG_AVG_WINDOW_END_X_HIGH	0x5682
+#define REG_AVG_WINDOW_END_X_LOW	0x5683
+#define REG_AVG_WINDOW_END_Y_HIGH	0x5686
+#define REG_AVG_WINDOW_END_Y_LOW	0x5687
+
+#define REG_DLY 0xffff
+
+#define OV5640_BINNING_MASK		0x01
+#define OV5640_TIMING_REG20		0x3820
+#define OV5640_TIMING_REG21		0x3821
+#define OV5640_HFLIP_MASK		0x06
+#define OV5640_VFLIP_MASK		0x06
+
+
+int sensor_ov5640_probe(struct i2c_client *client,
+						const struct i2c_device_id *id);
+
+
+
+/* OV5640 has only one fixed colorspace per pixelcode */
+struct ov5640_datafmt {
+    enum v4l2_mbus_pixelcode	code;
+    enum v4l2_colorspace		colorspace;
+};
+
+
+
+
+struct ov5640_timing_cfg {
+    u16 x_addr_start;
+    u16 y_addr_start;
+    u16 x_addr_end;
+    u16 y_addr_end;
+    u16 h_output_size;
+    u16 v_output_size;
+    u16 h_total_size;
+    u16 v_total_size;
+    u16 isp_h_offset;
+    u16 isp_v_offset;
+    u8 h_odd_ss_inc;
+    u8 h_even_ss_inc;
+    u8 v_odd_ss_inc;
+    u8 v_even_ss_inc;
+    u8 out_mode_sel;
+    u8 sclk_dividers;
+    u8 sys_mipi_clk;
+};
+
+struct ov5640_clk_cfg {
+    u8 sc_pll_prediv;
+    u8 sc_pll_rdiv;
+    u8 sc_pll_mult;
+    u8 sysclk_div;
+    u8 mipi_div;
+};
+
+enum ov5640_size {
+    OV5640_SIZE_QVGA,
+    OV5640_SIZE_VGA,
+    OV5640_SIZE_720P,
+    OV5640_SIZE_1280x960,
+    OV5640_SIZE_1080P,
+    OV5640_SIZE_UXGA,
+    OV5640_SIZE_QXGA,
+    OV5640_SIZE_5MP,
+    OV5640_SIZE_LAST,
+};
+
+static const struct v4l2_frmsize_discrete ov5640_frmsizes[OV5640_SIZE_LAST] = {
+        {320, 240},
+        {640, 480},
+        {1280, 720},
+        {1280, 960},
+        {1600, 1200},
+        {2048, 1536},
+        {2560, 1920},
+};
+
+
+struct fimc_is_sensor_cfg config_ov5640[] = {
+        FIMC_IS_SENSOR_CFG(320, 240, 120, 3, 0),
+        FIMC_IS_SENSOR_CFG(640, 480, 90, 3, 1),
+        FIMC_IS_SENSOR_CFG(1280, 720, 60, 3, 2),
+        FIMC_IS_SENSOR_CFG(2560, 1920, 15, 2, 3),
+
+};
+
+/* Find a frame size in an array */
+static int ov5640_find_framesize(u32 width, u32 height)
+{
+    int i;
+
+    for (i = 0; i < OV5640_SIZE_LAST; i++) {
+        if ((ov5640_frmsizes[i].width >= width) &&
+            (ov5640_frmsizes[i].height >= height))
+            break;
+    }
+
+    /* If not found, select biggest */
+    if (i >= OV5640_SIZE_LAST)
+        i = OV5640_SIZE_LAST - 1;
+
+    return i;
+}
+
+struct fimc_is_module_ov5640 {
+    u16		vis_duration;
+    u16		frame_length_line;
+    u32		line_length_pck;
+    u32		system_clock;
+};
+
+struct ov5640_s {
+    unsigned short id;
+    struct v4l2_subdev *sd;
+    struct media_pad pad;
+    struct v4l2_mbus_framefmt format;
+    struct v4l2_ctrl_handler ctrl_handler;
+    struct v4l2_ctrl *pixel_rate;
+    /* HW control */
+    unsigned long xvclk;
+
+    /* System Clock config */
+    struct ov5640_clk_cfg clk_cfg;
+};
+
+static inline struct ov5640_s *to_ov5640(struct v4l2_subdev *sd)
+{
+    return container_of(sd, struct ov5640_s, sd);
+}
+
+/**
+ * struct ov5640_reg - ov5640 register format
+ * @reg: 16-bit offset to register
+ * @val: 8/16/32-bit register value
+ * @length: length of the register
+ *
+ * Define a structure for OV5640 register initialization values
+ */
+struct ov5640_reg {
+    u16	reg;
+    u8	val;
+};
+
+
+//#define ENABLE_COLOR_PATTERN
+static const struct ov5640_reg configscript_common1[] = {
+/* System Control */
+        {0x3103, 0x11},
+        {0x3008, 0x82},               /* Reset [7] PowerDn [6] */
+        {0xFFFF, 3},          /* Sleep 3ms */
+        {0x3103, 0x03},		/* PLL Clock Select */
+
+        /* IO Config */
+        {0x3017, 0x00},		/* IO [3:0] D9-D6 (MIPI MD1-D9:D8 MC-D7:D6) */
+        {0x3018, 0x00},		/* IO [7:2] D5-D0 (MIPI MD0-D5:D4)
+				   [1]GPIO1 [0]GPIO0 (MIPI MD2/MC/MD1) */
+
+        /* MIPI Control */
+        {0x4800, 0x20},
+        {0x3034, 0x18},
+        {0x300e, 0x45},		/* MIPI Control  Dual Lane */
+        /* CLKS = Src=13Mhz:  676Mbps 8-bit */
+        {0x3037, 0x12},		/* PLL Pre-Div [0:3], /2=6.5Mhz
+				   PLL Root Div [4] /1=676Mhz */
+        {0x3036, 0x38},		/* PLL Mult 4~252 0:7  0x68=104=676Mhz */
+        /* PLL ADCLK */
+        {0x303d, 0x30},		/*PreDivSp [5:4] /2=6.5Mhz */
+        {0x303b, 0x21},		/*DivCntsb [4:0] *30=195Mhz */
+        /*???? */
+        {0x302e, 0x08},		/*undocumented */
+        /*Format control */
+        {0x501f, 0x00},		/*ISP Format */
+        {0x3821, 0x00},
+        /*JPG Control */
+        //{0x4713, 0x02},		/*JPG Mode Select */
+        /*JPG Quality? */
+
+        {0x4407, 0x04},
+        {0x440e, 0x00},
+        /*VFIFO Control */
+        {0x460b, 0x35},		/*???? */
+        {0x460c, 0x22},		/*PCLK Divider Manual */
+        /*???? */
+        {0x3630, 0x2e},
+        {0x3632, 0xe2},
+        {0x3633, 0x23},
+        /*???? */
+        {0x3704, 0xa0},
+        {0x3703, 0x5a},
+        {0x3715, 0x78},
+        {0x3717, 0x01},
+        {0x370b, 0x60},
+        {0x3705, 0x1a},
+        {0x3905, 0x02},
+        {0x3906, 0x10},
+        {0x3901, 0x0a},
+        {0x3731, 0x12},
+        /*VCM Control */
+        /*
+        {0x3600, 0x08},
+        {0x3601, 0x33},
+        {0x3604, 0x02},
+        {0x3605, 0x8a},
+        */
+         /*???? */
+        //{0x302d, 0x60},
+        //{0x3620, 0x52},
+        //{0x371b, 0x20},
+        //{0x471c, 0x50},
+        /*AEC Controls */
+        {0x3a13, 0x43},
+        {0x3a18, 0x00},
+        {0x3a19, 0xf8},
+        /*???? */
+        {0x3635, 0x1c},
+        {0x3634, 0x40},
+        {0x3622, 0x01},
+        /*50/60Hz Detector */
+        {0x3c01, 0x34},
+        {0x3c04, 0x28},
+        {0x3c05, 0x98},
+        {0x3c06, 0x00},
+
+        {0x3c07, 0x08},
+        {0x3c08, 0x00},
+        {0x3c09, 0x1c},
+        {0x3c0a, 0x9c},
+        {0x3c0b, 0x40},
+
+        {0x3814, 0x11},		/*X incr */
+        {0x3815, 0x11},		/*Y incr */
+        /* Sensor Timing control  2624 x 1952 --> 2560 x 1920 */
+        {0x3800, 0x00},		/*X start */
+        {0x3801, 0x20},
+        {0x3802, 0x00},		/*Y start */
+        {0x3803, 0x10},
+        {0x3804, 0x0a},		/*X end */
+        {0x3805, 0x1f},
+        {0x3806, 0x07},		/*Y end */
+        {0x3807, 0x8f},
+        /* Output size */
+        {0x3808, 0x0a},		/*output X  2592 */
+        {0x3809, 0x20},
+        {0x380a, 0x07},		/*output Y  1944 */
+        {0x380b, 0x98},
+        /* Total size (+blanking) */
+        {0x380c, 0x08},		/*Total X  2844 */
+        {0x380d, 0x98},
+        {0x380e, 0x05},		/*Total Y  1968 */
+        {0x380f, 0x00},
+        /* ISP Windowing size  2560 x 1920 --> 2560 x 1920 */
+        {0x3810, 0x00},		/*ISP X offset = 0 */
+        {0x3811, 0x00},
+        {0x3812, 0x00},		/*ISP Y offset = 0 */
+        {0x3813, 0x00},
+        /*???? */
+        {0x3618, 0x00},
+        {0x3612, 0x29},
+        {0x3708, 0x62},
+        {0x3709, 0x52},
+        {0x370c, 0x03},
+        /*AEC/AGC */
+        {0x3a02, 0x03},
+        {0x3a03, 0xd8},
+        {0x3a08, 0x01},
+        {0x3a09, 0x27},
+        {0x3a0a, 0x00},
+        {0x3a0b, 0xf6},
+        {0x3a0e, 0x03},
+        {0x3a0d, 0x04},
+        {0x3a14, 0x03},
+        {0x3a15, 0xd8},
+        /*BLC Control */
+        {0x4001, 0x01},
+        {0x4004, 0x02},
+
+        /*ISP Control */
+        {0x5000, 0x27},
+        {0x5001, 0x23},		/*isp scale down  Special Effects */
+        /*AWB Control */
+        {0x5180, 0xff},
+        {0x5181, 0x56},
+        {0x5182, 0x00},
+        {0x5183, 0x14},
+        {0x5184, 0x25},
+        {0x5185, 0x24},
+        {0x5186, 0x10},
+        {0x5187, 0x14},
+        {0x5188, 0x10},
+        {0x5189, 0x81},
+        {0x518a, 0x5a},
+        {0x518b, 0xb6},
+        {0x518c, 0xa9},
+        {0x518d, 0x4c},
+        {0x518e, 0x34},
+        {0x518f, 0x60},
+        {0x5190, 0x48},
+        {0x5191, 0xf8},
+        {0x5192, 0x04},
+        {0x5193, 0x70},
+        {0x5194, 0xf0},
+        {0x5195, 0xf0},
+        {0x5196, 0x03},
+        {0x5197, 0x01},
+        {0x5198, 0x04},
+        {0x5199, 0x9b},
+        {0x519a, 0x04},
+        {0x519b, 0x00},
+        {0x519c, 0x09},
+        {0x519d, 0x1e},
+        {0x519e, 0x38},
+        /*CCM Control */
+#if 0
+        {0x5381, 0x26},
+        {0x5382, 0x4e},
+        {0x5383, 0x0c},
+        {0x5384, 0x12},
+        {0x5385, 0x70},
+        {0x5386, 0x82},
+        {0x5387, 0x6e},
+        {0x5388, 0x58},
+        {0x5389, 0x14},
+        {0x538b, 0x98},
+        {0x538a, 0x01},
+#else
+        {0x5381, 0x20},
+        {0x5382, 0x64},
+        {0x5383, 0x08},
+        {0x5384, 0x30},
+        {0x5385, 0x90},
+        {0x5386, 0xc0},
+        {0x5387, 0xa0},
+        {0x5388, 0x98},
+        {0x5389, 0x08},
+        {0x538b, 0x98},
+        {0x538a, 0x01},
+#endif
+        /*CIP Control */
+
+        {0x5300, 0x08},
+        {0x5301, 0x30},
+        {0x5302, 0x10},
+        {0x5303, 0x00},
+        {0x5304, 0x08},
+        {0x5305, 0x30},
+        {0x5306, 0x08},
+        {0x5307, 0x16},
+        {0x5309, 0x08},
+        {0x530a, 0x30},
+        {0x530b, 0x04},
+        {0x530c, 0x06},
+
+        /*Gamma Control */
+
+        {0x5480, 0x01},
+        {0x5481, 0x08},
+        {0x5482, 0x14},
+        {0x5483, 0x28},
+        {0x5484, 0x51},
+        {0x5485, 0x65},
+        {0x5486, 0x71},
+        {0x5487, 0x7d},
+        {0x5488, 0x87},
+        {0x5489, 0x91},
+        {0x548a, 0x9a},
+        {0x548b, 0xaa},
+        {0x548c, 0xb8},
+        {0x548d, 0xcd},
+        {0x548e, 0xdd},
+        {0x548f, 0xea},
+        {0x5490, 0x1d},
+
+        /*SDE Control */
+        /*
+        {0x5580, 0x02},
+        {0x5583, 0x40},
+        {0x5584, 0x10},
+        {0x5589, 0x10},
+        {0x558a, 0x00},
+        {0x558b, 0xf8},
+         */
+        /* LSC OV5640LENCsetting */
+        /*
+        {0x5800, 0x32},
+        {0x5801, 0x1d},
+        {0x5802, 0x19},
+        {0x5803, 0x18},
+        {0x5804, 0x1d},
+        {0x5805, 0x38},
+        {0x5806, 0x12},
+        {0x5807, 0x0a},
+        {0x5808, 0x07},
+        {0x5809, 0x07},
+        {0x580a, 0x0b},
+        {0x580b, 0x0f},
+        {0x580c, 0x0e},
+        {0x580d, 0x05},
+        {0x580e, 0x01},
+        {0x580f, 0x00},
+        {0x5810, 0x03},
+        {0x5811, 0x0a},
+        {0x5812, 0x0c},
+        {0x5813, 0x04},
+        {0x5814, 0x00},
+        {0x5815, 0x00},
+        {0x5816, 0x03},
+        {0x5817, 0x0a},
+        {0x5818, 0x12},
+        {0x5819, 0x09},
+        {0x581a, 0x06},
+        {0x581b, 0x05},
+        {0x581c, 0x09},
+        {0x581d, 0x12},
+        {0x581e, 0x32},
+        {0x581f, 0x18},
+        {0x5820, 0x14},
+        {0x5821, 0x13},
+        {0x5822, 0x17},
+        {0x5823, 0x2d},
+        {0x5824, 0x28},
+        {0x5825, 0x2a},
+        {0x5826, 0x28},
+        {0x5827, 0x28},
+        {0x5828, 0x2a},
+        {0x5829, 0x28},
+        {0x582a, 0x25},
+        {0x582b, 0x24},
+        {0x582c, 0x24},
+        {0x582d, 0x08},
+        {0x582e, 0x26},
+        {0x582f, 0x42},
+        {0x5830, 0x40},
+        {0x5831, 0x42},
+        {0x5832, 0x06},
+        {0x5833, 0x26},
+        {0x5834, 0x26},
+        {0x5835, 0x44},
+        {0x5836, 0x24},
+        {0x5837, 0x2a},
+        {0x5838, 0x4a},
+        {0x5839, 0x2a},
+        {0x583a, 0x0c},
+        {0x583b, 0x2c},
+        {0x583c, 0x28},
+        {0x583d, 0xce},
+
+        {0x5025, 0x00},
+         */
+        /*AEC Controls */
+
+        {0x3a0f, 0x30},
+        {0x3a10, 0x28},
+        {0x3a1b, 0x30},
+        {0x3a1e, 0x26},
+        {0x3a11, 0x60},
+        {0x3a1f, 0x14},
+
+#ifdef ENABLE_COLOR_PATTERN
+{0x503d, 0x80},		/* Solid Colour Bars */
+#if 0
+	{0x503d, 0x80},		/* Solid Colour Bars */
+	{0x503d, 0x81},		/* Gradual change @ vertical mode 1 */
+	{0x503d, 0x82},		/* Gradual change horizontal */
+	{0x503d, 0x83},		/* Gradual change @ vertical mode 2 */
+#endif
+#endif
+
+        {0xFFFF, 0x00},
+};
+
+static const struct ov5640_reg configscript_common2[] = {
+        /* System Clock Div */
+
+        {0x3035, 0x11},		/*SystemClkDiv 7:4, /1=728Mhz
+				   MIPI Sclk Div 3:0, /1=728Mhz */
+        /*System/IO pad Control */
+        {0x3000, 0x00},		/*Resets */
+        {0x3002, 0x1c},
+        {0x3004, 0xff},		/*Clocks */
+        {0x3006, 0xc3},
+        {0x3007, 0xff},		/*Clocks */
+
+        /*Format control */
+        {0x4300, 0x32},		/*Output Format[7:4] Sequence[3:0] (UVYV) */
+        /*MIPI Control */
+        {0x4837, 0x11},
+        /*PCLK Divider */
+        {0x3824, 0x00},		/*Scale Divider [4:0] */
+        {0x3008, 0x42},		/*stop sensor streaming */
+
+        {0xFFFF, 0x00}
+};
+
+
+static const struct ov5640_timing_cfg timing_cfg[OV5640_SIZE_LAST] = {
+        [OV5640_SIZE_QVGA] = {
+                /* Timing control  2624 x 1952 --> 2592 x 1944 */
+                .x_addr_start	= 16,
+                .y_addr_start	= 4,
+                .x_addr_end	= 2607,
+                .y_addr_end	= 1947,
+                /* Output image size */
+                .h_output_size	= 320,
+                .v_output_size	= 240,
+                /* ISP Windowing size 1296 x 972 --> 1280 x 960 */
+                .isp_h_offset	= 8,
+                .isp_v_offset	= 6,
+                /* Total size (+blanking) */
+                .h_total_size	= 2200,
+                .v_total_size	= 1280,
+                /* Sensor Read Binning Enabled */
+                .h_odd_ss_inc	= 3,
+                .h_even_ss_inc	= 1,
+                .v_odd_ss_inc	= 3,
+                .v_even_ss_inc	= 1,
+                .out_mode_sel	= 0x01,
+                .sclk_dividers	= 0x01,
+                .sys_mipi_clk	= 0x11,
+        },
+        [OV5640_SIZE_VGA] = {
+                /* Timing control  2624 x 1952 --> 2592 x 1944 */
+                .x_addr_start	= 16,
+                .y_addr_start	= 4,
+                .x_addr_end	= 2607,
+                .y_addr_end	= 1947,
+                /* Output image size */
+                .h_output_size	= 640,
+                .v_output_size	= 480,
+                /* ISP Windowing size  1296 x 972 --> 1280 x 960 */
+                .isp_h_offset	= 8,
+                .isp_v_offset	= 6,
+                /* Total size (+blanking) */
+                .h_total_size	= 2200,
+                .v_total_size	= 1280,
+                /* Sensor Read Binning Enabled */
+                .h_odd_ss_inc	= 3,
+                .h_even_ss_inc	= 1,
+                .v_odd_ss_inc	= 3,
+                .v_even_ss_inc	= 1,
+                .out_mode_sel	= 0x01,
+                .sclk_dividers	= 0x01,
+                .sys_mipi_clk	= 0x11,
+        },
+        [OV5640_SIZE_720P] = {
+                /* Timing control  2624 x 1952 --> 2592 x 1944 */
+                .x_addr_start	= 16,
+                .y_addr_start	= 4,
+                .x_addr_end	= 2607,
+                .y_addr_end	= 1947,
+                /* Output image size */
+                .h_output_size	= 1280,
+                .v_output_size	= 720,
+                /* ISP Windowing size 1296 x 972 --> 1280 x 960 */
+                .isp_h_offset	= 8,
+                .isp_v_offset	= 6,
+                /* Total size (+blanking) */
+                .h_total_size	= 2200,
+                .v_total_size	= 1280,
+                /* Sensor Read Binning Enabled */
+                .h_odd_ss_inc	= 3,
+                .h_even_ss_inc	= 1,
+                .v_odd_ss_inc	= 3,
+                .v_even_ss_inc	= 1,
+                .out_mode_sel	= 0x01,
+                .sclk_dividers	= 0x01,
+                .sys_mipi_clk	= 0x11,
+        },
+        [OV5640_SIZE_1280x960] = {
+                /* Timing control 2624x1952 --> 2592x1944 */
+                .x_addr_start	= 16,
+                .y_addr_start	= 4,
+                .x_addr_end	= 2607,
+                .y_addr_end	= 1947,
+                /* Output image size */
+                .h_output_size	= 1280,
+                .v_output_size	= 960,
+                /* ISP Windowing size 1296x972 --> 1280x960 */
+                .isp_h_offset	= 8,
+                .isp_v_offset	= 6,
+                /* Total size (+blanking) */
+                .h_total_size	= 2200,
+                .v_total_size	= 1280,
+                /* Sensor Read Binning Enabled */
+                .h_odd_ss_inc	= 3,
+                .h_even_ss_inc	= 1,
+                .v_odd_ss_inc	= 3,
+                .v_even_ss_inc	= 1,
+                .out_mode_sel	= 0x01,
+                .sclk_dividers	= 0x01,
+                .sys_mipi_clk	= 0x11,
+        },
+        [OV5640_SIZE_UXGA] = {
+                /* Timing control  2624 x 1952 --> 2592 x 1944 */
+                .x_addr_start	= 16,
+                .y_addr_start	= 4,
+                .x_addr_end	= 2607,
+                .y_addr_end	= 1947,
+                /* Output image size */
+                .h_output_size	= 1600,
+                .v_output_size	= 1200,
+                /* ISP Windowing size 2592x1944 --> 2560x1920 */
+                .isp_h_offset	= 16,
+                .isp_v_offset	= 12,
+                /* Total size (+blanking) */
+                .h_total_size	= 2844,
+                .v_total_size	= 1968,
+                /* Sensor Read Binning Disabled */
+                .h_odd_ss_inc	= 1,
+                .h_even_ss_inc	= 1,
+                .v_odd_ss_inc	= 1,
+                .v_even_ss_inc	= 1,
+                .out_mode_sel	= 0x00,
+                .sclk_dividers	= 0x02,
+                .sys_mipi_clk	= 0x12,
+        },
+        [OV5640_SIZE_QXGA] = {
+                /* Timing control  2624 x 1952 --> 2592 x 1944 */
+                .x_addr_start	= 16,
+                .y_addr_start	= 4,
+                .x_addr_end	= 2607,
+                .y_addr_end	= 1947,
+                /* Output image size */
+                .h_output_size	= 2048,
+                .v_output_size	= 1536,
+                /* ISP Windowing size 2592x1944 --> 2560x1920 */
+                .isp_h_offset	= 16,
+                .isp_v_offset	= 12,
+                /* Total size (+blanking) */
+                .h_total_size	= 2844,
+                .v_total_size	= 1968,
+                /* Sensor Read Binning Enabled */
+                .h_odd_ss_inc	= 1,
+                .h_even_ss_inc	= 1,
+                .v_odd_ss_inc	= 1,
+                .v_even_ss_inc	= 1,
+                .out_mode_sel	= 0x00,
+                .sclk_dividers	= 0x02,
+                .sys_mipi_clk	= 0x12,
+        },
+        [OV5640_SIZE_5MP] = {
+                /* Timing control  2624 x 1952 --> 2592 x 1944 */
+                .x_addr_start	= 16,
+                .y_addr_start	= 4,
+                .x_addr_end	= 2607,
+                .y_addr_end	= 1947,
+                /* Output image size */
+                .h_output_size	= 2560,
+                .v_output_size	= 1920,
+                /* ISP Windowing size 2592x1944 --> 2560x1920 */
+                .isp_h_offset	= 16,
+                .isp_v_offset	= 12,
+                /* Total size (+blanking) */
+                .h_total_size	= 2844,
+                .v_total_size	= 1968,
+                /* Sensor Read Binning Enabled */
+                .h_odd_ss_inc	= 1,
+                .h_even_ss_inc	= 1,
+                .v_odd_ss_inc	= 1,
+                .v_even_ss_inc	= 1,
+                .out_mode_sel	= 0x00,
+                .sclk_dividers	= 0x02,
+                .sys_mipi_clk	= 0x12,
+        },
+};
+
+
+
+#if 0
+static const struct ov5640_timing_cfg timing_cfg[OV5640_SIZE_LAST] = {
+        [OV5640_SIZE_QVGA] = {
+                /* Timing control  2624 x 1952 --> 2592 x 1944 */
+                .x_addr_start	= 16,
+                .y_addr_start	= 4,
+                .x_addr_end	= 2607,
+                .y_addr_end	= 1947,
+                /* Output image size */
+                .h_output_size	= 320,
+                .v_output_size	= 240,
+                /* ISP Windowing size 1296 x 972 --> 1280 x 960 */
+                .isp_h_offset	= 8,
+                .isp_v_offset	= 6,
+                /* Total size (+blanking) */
+                .h_total_size	= 2200,
+                .v_total_size	= 1280,
+                /* Sensor Read Binning Enabled */
+                .h_odd_ss_inc	= 3,
+                .h_even_ss_inc	= 1,
+                .v_odd_ss_inc	= 3,
+                .v_even_ss_inc	= 1,
+                .out_mode_sel	= 0x01,
+                .sclk_dividers	= 0x01,
+                .sys_mipi_clk	= 0x11,
+        },
+        [OV5640_SIZE_VGA] = {
+                /* Timing control  2624 x 1952 --> 2592 x 1944 */
+                .x_addr_start	= 16,
+                .y_addr_start	= 4,
+                .x_addr_end	= 2607,
+                .y_addr_end	= 1947,
+                /* Output image size */
+                .h_output_size	= 640,
+                .v_output_size	= 480,
+                /* ISP Windowing size  1296 x 972 --> 1280 x 960 */
+                .isp_h_offset	= 8,
+                .isp_v_offset	= 6,
+                /* Total size (+blanking) */
+                .h_total_size	= 2200,
+                .v_total_size	= 1280,
+                /* Sensor Read Binning Enabled */
+                .h_odd_ss_inc	= 3,
+                .h_even_ss_inc	= 1,
+                .v_odd_ss_inc	= 3,
+                .v_even_ss_inc	= 1,
+                .out_mode_sel	= 0x01,
+                .sclk_dividers	= 0x01,
+                .sys_mipi_clk	= 0x11,
+        },
+#if 1
+        [OV5640_SIZE_720P] = {
+                .x_addr_start = 336,
+                .y_addr_start = 434,
+                .x_addr_end = 2287,
+                .y_addr_end = 1522,
+                .h_output_size = 1280,
+                .v_output_size = 720,
+                .h_total_size = 2500,
+                .v_total_size = 1120,
+                .isp_h_offset = 16,
+                .isp_v_offset = 4,
+                .h_odd_ss_inc = 1,
+                .h_even_ss_inc = 1,
+                .v_odd_ss_inc = 1,
+                .v_even_ss_inc = 1,
+                .out_mode_sel	= 0x01,
+                .sclk_dividers	= 0x01,
+                .sys_mipi_clk	= 0x10,
+        },
+#else
+        [OV5640_SIZE_720P] = {
+                /* Timing control  2624 x 1952 --> 2592 x 1944 */
+                .x_addr_start	= 16,
+                .y_addr_start	= 4,
+                .x_addr_end	= 2607,
+                .y_addr_end	= 1947,
+                /* Output image size */
+                .h_output_size	= 1280,
+                .v_output_size	= 720,
+                /* ISP Windowing size 1296 x 972 --> 1280 x 960 */
+                .isp_h_offset	= 8,
+                .isp_v_offset	= 6,
+                /* Total size (+blanking) */
+                .h_total_size	= 2200,
+                .v_total_size	= 1280,
+                /* Sensor Read Binning Enabled */
+                .h_odd_ss_inc	= 3,
+                .h_even_ss_inc	= 1,
+                .v_odd_ss_inc	= 3,
+                .v_even_ss_inc	= 1,
+                .out_mode_sel	= 0x01,
+                .sclk_dividers	= 0x01,
+                .sys_mipi_clk	= 0x11,
+        },
+#endif
+#if 1
+        [OV5640_SIZE_5MP] = {
+                /* Timing control  2624 x 1952 --> 2592 x 1944 */
+                .x_addr_start	= 16,
+                .y_addr_start	= 4,
+                .x_addr_end	= 2607,
+                .y_addr_end	= 1947,
+                /* Output image size */
+                .h_output_size	= 2560,
+                .v_output_size	= 1920,
+                /* ISP Windowing size 2592x1944 --> 2560x1920 */
+                .isp_h_offset	= 16,
+                .isp_v_offset	= 12,
+                /* Total size (+blanking) */
+                .h_total_size	= 2844,
+                .v_total_size	= 1968,
+                /* Sensor Read Binning Enabled */
+                .h_odd_ss_inc	= 1,
+                .h_even_ss_inc	= 1,
+                .v_odd_ss_inc	= 1,
+                .v_even_ss_inc	= 1,
+                .out_mode_sel	= 0x00,
+                .sclk_dividers	= 0x02,
+                .sys_mipi_clk	= 0x12,
+        },
+#else
+        [OV5640_SIZE_5MP] = {
+
+                .x_addr_start = 0,
+                .y_addr_start = 0,
+                .x_addr_end = 2623,
+                .y_addr_end = 1951,
+                .h_output_size = 2592,
+                .v_output_size = 1944,
+                .h_total_size = 2844,
+                .v_total_size = 1968,
+                .isp_h_offset = 16,
+                .isp_v_offset = 6,
+                .h_odd_ss_inc = 1,
+                .h_even_ss_inc = 1,
+                .v_odd_ss_inc = 1,
+                .v_even_ss_inc = 1,
+                .out_mode_sel	= 0x00,
+                .sclk_dividers	= 0x02,
+                .sys_mipi_clk	= 0x12,
+        },
+#endif
+};
+
+#endif
+
+
+
+
+#define V4L2_CID_CAM_CONTRAST           (V4L2_CID_CAMERA_CLASS_BASE+42)
+enum v4l2_contrast {
+    V4L2_CONTRAST_AUTO,
+    V4L2_CONTRAST_MINUS_4,
+    V4L2_CONTRAST_MINUS_3,
+    V4L2_CONTRAST_MINUS_2,
+    V4L2_CONTRAST_MINUS_1,
+    V4L2_CONTRAST_DEFAULT,
+    V4L2_CONTRAST_PLUS_1,
+    V4L2_CONTRAST_PLUS_2,
+    V4L2_CONTRAST_PLUS_3,
+    V4L2_CONTRAST_PLUS_4,
+    V4L2_CONTRAST_MAX
+};
+
+#define V4L2_CID_CAM_SATURATION         (V4L2_CID_CAMERA_CLASS_BASE+43)
+enum v4l2_saturation {
+    V4L2_SATURATION_MINUS_3,
+    V4L2_SATURATION_MINUS_2,
+    V4L2_SATURATION_MINUS_1,
+    V4L2_SATURATION_DEFAULT,
+    V4L2_SATURATION_PLUS_1,
+    V4L2_SATURATION_PLUS_2,
+    V4L2_SATURATION_PLUS_3,
+    V4L2_SATURATION_MAX
+};
+
+#define V4L2_CID_CAM_SHARPNESS          (V4L2_CID_CAMERA_CLASS_BASE+44)
+enum v4l2_sharpness {
+    V4L2_SHARPNESS_MINUS_2,
+    V4L2_SHARPNESS_MINUS_1,
+    V4L2_SHARPNESS_DEFAULT,
+    V4L2_SHARPNESS_PLUS_1,
+    V4L2_SHARPNESS_PLUS_2,
+    V4L2_SHARPNESS_MAX,
+};
+
+#define V4L2_CID_CAM_ISO    (V4L2_CID_CAMERA_CLASS_BASE+22)
+enum v4l2_iso {
+    V4L2_ISO_AUTO,
+    V4L2_ISO_50,
+    V4L2_ISO_100,
+    V4L2_ISO_200,
+    V4L2_ISO_400,
+    V4L2_ISO_800,
+    V4L2_ISO_1600,
+    V4L2_ISO_MAX
+};
+
+#define V4L2_CID_CAPTURE			(V4L2_CID_CAMERA_CLASS_BASE+46)
+
+#define V4L2_CID_CAM_FLASH_MODE			(V4L2_CID_CAMERA_CLASS_BASE+62)
+enum v4l2_cam_flash_mode {
+    V4L2_FLASH_MODE_BASE,
+    V4L2_FLASH_MODE_OFF,
+    V4L2_FLASH_MODE_AUTO,
+    V4L2_FLASH_MODE_ON,
+    V4L2_FLASH_MODE_TORCH,
+    V4L2_FLASH_MODE_MAX,
+};
+
+#define V4L2_CID_JPEG_QUALITY			(V4L2_CID_CAMERA_CLASS_BASE+55)
+
+#define V4L2_CID_CAM_OBJECT_POSITION_X		(V4L2_CID_CAMERA_CLASS_BASE+50)
+#define V4L2_CID_CAM_OBJECT_POSITION_Y		(V4L2_CID_CAMERA_CLASS_BASE+51)
+
+#define V4L2_CID_CAM_SET_AUTO_FOCUS		(V4L2_CID_CAMERA_CLASS_BASE+48)
+enum v4l2_cam_auto_focus {
+    V4L2_AUTO_FOCUS_OFF = 0,
+    V4L2_AUTO_FOCUS_ON,
+    V4L2_AUTO_FOCUS_MAX,
+};
+
+#define V4L2_CID_CAM_SINGLE_AUTO_FOCUS		(V4L2_CID_CAMERA_CLASS_BASE+63)
+
+#define V4L2_CID_CAM_AUTO_FOCUS_RESULT		(V4L2_CID_CAMERA_CLASS_BASE+54)
+enum v4l2_cam_af_status {
+    V4L2_CAMERA_AF_STATUS_IN_PROGRESS = 0,
+    V4L2_CAMERA_AF_STATUS_SUCCESS,
+    V4L2_CAMERA_AF_STATUS_FAIL,
+    V4L2_CAMERA_AF_STATUS_1ST_SUCCESS,
+    V4L2_CAMERA_AF_STATUS_MAX,
+};
+
+#define V4L2_CID_CAM_BRIGHTNESS			(V4L2_CID_CAMERA_CLASS_BASE+45)
+enum v4l2_brightness {
+    V4L2_BRIGHTNESS_MINUS_2,
+    V4L2_BRIGHTNESS_MINUS_1,
+    V4L2_BRIGHTNESS_DEFAULT,
+    V4L2_BRIGHTNESS_PLUS_1,
+    V4L2_BRIGHTNESS_PLUS_2,
+    V4L2_BRIGHTNESS_MAX,
+};
+
+
+
+
+
+
+
+#endif
diff --git a/drivers/media/platform/exynos4-is/media-dev.c b/drivers/media/platform/exynos4-is/media-dev.c
index 753c338..0ec1f4b 100644
--- a/drivers/media/platform/exynos4-is/media-dev.c
+++ b/drivers/media/platform/exynos4-is/media-dev.c
@@ -18,6 +18,7 @@
 #include <linux/list.h>
 #include <linux/module.h>
 #include <linux/of.h>
+#include <linux/of_i2c.h>
 #include <linux/of_platform.h>
 #include <linux/of_device.h>
 #include <linux/of_graph.h>
diff --git a/include/linux/input/ft5x06_ts.h b/include/linux/input/ft5x06_ts.h
new file mode 100644
index 0000000..88200a5
--- /dev/null
+++ b/include/linux/input/ft5x06_ts.h
@@ -0,0 +1,79 @@
+/*
+ *
+ * FocalTech ft5x06 TouchScreen driver header file.
+ *
+ * Copyright (c) 2010  Focal tech Ltd.
+ * Copyright (c) 2012-2014, The Linux Foundation. All rights reserved.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+#ifndef __LINUX_FT5X06_TS_H__
+#define __LINUX_FT5X06_TS_H__
+
+#define FT5X06_ID		0x55
+#define FT5X16_ID		0x0A
+#define FT5X36_ID		0x14
+#define FT6X06_ID		0x06
+#define FT6X36_ID       0x36
+
+//#define FTS_APK_DEBUG
+//#define CONFIG_TOUCHPANEL_PROXIMITY_SENSOR
+
+#define TPD_MAX_POINTS_2                        2
+#define TPD_MAX_POINTS_5                        5
+#define TPD_MAX_POINTS_10                        10
+
+#define FTS_NAME "fts_wq"
+
+#define AUTO_CLB_NEED 1
+#define AUTO_CLB_NONEED 0
+
+struct fw_upgrade_info {
+	u8 auto_cal;
+	u16 delay_aa;
+	u16 delay_55;
+	u8 upgrade_id_1;
+	u8 upgrade_id_2;
+	u16 delay_readid;
+	u16 delay_erase_flash;
+};
+
+struct ft5x06_ts_platform_data {
+	struct fw_upgrade_info info;
+	const char *name;
+	const char *fw_name;
+	u32 irqflags;
+	u32 irq_gpio;
+	u32 irq_gpio_flags;
+	u32 reset_gpio;
+	u32 reset_gpio_flags;
+	u32 family_id;
+	u32 x_max;
+	u32 y_max;
+	u32 x_min;
+	u32 y_min;
+	u32 panel_minx;
+	u32 panel_miny;
+	u32 panel_maxx;
+	u32 panel_maxy;
+	u32 group_id;
+	u32 hard_rst_dly;
+	u32 soft_rst_dly;
+	u32 num_max_touches;
+	bool fw_vkey_support;
+	bool no_force_update;
+	bool i2c_pull_up;
+	bool ignore_id_check;
+	int (*power_init) (bool);
+	int (*power_on) (bool);
+};
+
+#endif
diff --git a/include/uapi/linux/v4l2-mediabus.h b/include/uapi/linux/v4l2-mediabus.h
index 02a719a..0059140 100644
--- a/include/uapi/linux/v4l2-mediabus.h
+++ b/include/uapi/linux/v4l2-mediabus.h
@@ -32,7 +32,7 @@ struct v4l2_mbus_framefmt {
 	__u32			reserved[7];
 };
 
-#ifndef __KERNEL__
+//#ifndef __KERNEL__
 /*
  * enum v4l2_mbus_pixelcode and its definitions are now deprecated, and
  * MEDIA_BUS_FMT_ definitions (defined in media-bus-format.h) should be
@@ -131,6 +131,6 @@ enum v4l2_mbus_pixelcode {
 
 	V4L2_MBUS_FROM_MEDIA_BUS_FMT(AHSV8888_1X32),
 };
-#endif /* __KERNEL__ */
+//#endif /* __KERNEL__ */
 
 #endif
diff --git a/sound/soc/codecs/sgtl5000.c b/sound/soc/codecs/sgtl5000.c
index 665e0dd..f935e19 100644
--- a/sound/soc/codecs/sgtl5000.c
+++ b/sound/soc/codecs/sgtl5000.c
@@ -7,7 +7,7 @@
  * it under the terms of the GNU General Public License version 2 as
  * published by the Free Software Foundation.
  */
-
+ #define DEBUG
 #include <linux/module.h>
 #include <linux/moduleparam.h>
 #include <linux/init.h>
@@ -16,6 +16,7 @@
 #include <linux/pm.h>
 #include <linux/i2c.h>
 #include <linux/clk.h>
+#include <linux/regmap.h>
 #include <linux/regulator/driver.h>
 #include <linux/regulator/machine.h>
 #include <linux/regulator/consumer.h>
@@ -27,37 +28,105 @@
 #include <sound/soc.h>
 #include <sound/soc-dapm.h>
 #include <sound/initval.h>
+#include <linux/gpio.h>                 // Required for the GPIO functions
 
 #include "sgtl5000.h"
 
+
+static unsigned int gpioSPK_R =121;
+static unsigned int gpioSPK_L =122;
+
+static unsigned int gpioSPKAmp1 =123;
+static unsigned int gpioSPKAmp2 =124;
+static unsigned int ampVal = 0;
+
+static unsigned int boot_cnt = 7;
+
+
+
 #define SGTL5000_DAP_REG_OFFSET	0x0100
 #define SGTL5000_MAX_REG_OFFSET	0x013A
 
 /* default value of sgtl5000 registers */
+static const struct reg_default sgtl5000_reg_defaults[] = {
+        { SGTL5000_CHIP_DIG_POWER,              0x0000 },
+        { SGTL5000_CHIP_CLK_CTRL,               0x0008 },
+        { SGTL5000_CHIP_I2S_CTRL,               0x0010 },
+        { SGTL5000_CHIP_SSS_CTRL,               0x0010 },
+        { SGTL5000_CHIP_ADCDAC_CTRL,            0x020c },
+        { SGTL5000_CHIP_DAC_VOL,                0x3c3c },
+        { SGTL5000_CHIP_PAD_STRENGTH,           0x015f },
+        { SGTL5000_CHIP_ANA_ADC_CTRL,           0x0000 },
+        { SGTL5000_CHIP_ANA_HP_CTRL,            0x1818 },
+        { SGTL5000_CHIP_ANA_CTRL,               0x0111 },
+        { SGTL5000_CHIP_LINREG_CTRL,            0x0000 },
+        { SGTL5000_CHIP_REF_CTRL,               0x0000 },
+        { SGTL5000_CHIP_MIC_CTRL,               0x0000 },
+        { SGTL5000_CHIP_LINE_OUT_CTRL,          0x0000 },
+        { SGTL5000_CHIP_LINE_OUT_VOL,           0x0404 },
+        { SGTL5000_CHIP_ANA_POWER,              0x7060 },
+        { SGTL5000_CHIP_PLL_CTRL,               0x5000 },
+        { SGTL5000_CHIP_CLK_TOP_CTRL,           0x0000 },
+        { SGTL5000_CHIP_ANA_STATUS,             0x0000 },
+        { SGTL5000_CHIP_SHORT_CTRL,             0x0000 },
+        { SGTL5000_CHIP_ANA_TEST2,              0x0000 },
+        { SGTL5000_DAP_CTRL,                    0x0000 },
+        { SGTL5000_DAP_PEQ,                     0x0000 },
+        { SGTL5000_DAP_BASS_ENHANCE,            0x0040 },
+        { SGTL5000_DAP_BASS_ENHANCE_CTRL,       0x051f },
+        { SGTL5000_DAP_AUDIO_EQ,                0x0000 },
+        { SGTL5000_DAP_SURROUND,                0x0040 },
+        { SGTL5000_DAP_EQ_BASS_BAND0,           0x002f },
+        { SGTL5000_DAP_EQ_BASS_BAND1,           0x002f },
+        { SGTL5000_DAP_EQ_BASS_BAND2,           0x002f },
+        { SGTL5000_DAP_EQ_BASS_BAND3,           0x002f },
+        { SGTL5000_DAP_EQ_BASS_BAND4,           0x002f },
+        { SGTL5000_DAP_MAIN_CHAN,               0x8000 },
+        { SGTL5000_DAP_MIX_CHAN,                0x0000 },
+        { SGTL5000_DAP_AVC_CTRL,                0x0510 },
+        { SGTL5000_DAP_AVC_THRESHOLD,           0x1473 },
+        { SGTL5000_DAP_AVC_ATTACK,              0x0028 },
+        { SGTL5000_DAP_AVC_DECAY,               0x0050 },
+};
+
+/* default value of sgtl5000 registers */
 static const u16 sgtl5000_regs[SGTL5000_MAX_REG_OFFSET] =  {
-	[SGTL5000_CHIP_CLK_CTRL] = 0x0008,
-	[SGTL5000_CHIP_I2S_CTRL] = 0x0010,
-	[SGTL5000_CHIP_SSS_CTRL] = 0x0010,
-	[SGTL5000_CHIP_DAC_VOL] = 0x3c3c,
-	[SGTL5000_CHIP_PAD_STRENGTH] = 0x015f,
-	[SGTL5000_CHIP_ANA_HP_CTRL] = 0x1818,
-	[SGTL5000_CHIP_ANA_CTRL] = 0x0111,
-	[SGTL5000_CHIP_LINE_OUT_VOL] = 0x0404,
-	[SGTL5000_CHIP_ANA_POWER] = 0x7060,
-	[SGTL5000_CHIP_PLL_CTRL] = 0x5000,
-	[SGTL5000_DAP_BASS_ENHANCE] = 0x0040,
-	[SGTL5000_DAP_BASS_ENHANCE_CTRL] = 0x051f,
-	[SGTL5000_DAP_SURROUND] = 0x0040,
-	[SGTL5000_DAP_EQ_BASS_BAND0] = 0x002f,
-	[SGTL5000_DAP_EQ_BASS_BAND1] = 0x002f,
-	[SGTL5000_DAP_EQ_BASS_BAND2] = 0x002f,
-	[SGTL5000_DAP_EQ_BASS_BAND3] = 0x002f,
-	[SGTL5000_DAP_EQ_BASS_BAND4] = 0x002f,
-	[SGTL5000_DAP_MAIN_CHAN] = 0x8000,
-	[SGTL5000_DAP_AVC_CTRL] = 0x0510,
-	[SGTL5000_DAP_AVC_THRESHOLD] = 0x1473,
-	[SGTL5000_DAP_AVC_ATTACK] = 0x0028,
-	[SGTL5000_DAP_AVC_DECAY] = 0x0050,
+        [SGTL5000_CHIP_DIG_POWER] = 0x000,
+        [SGTL5000_CHIP_CLK_CTRL] = 0x0008,
+        [SGTL5000_CHIP_I2S_CTRL] = 0x0010,
+        [SGTL5000_CHIP_SSS_CTRL] = 0x0010,
+        [SGTL5000_CHIP_DAC_VOL] = 0x3c3c,
+        [SGTL5000_CHIP_PAD_STRENGTH] = 0x015f,
+        [SGTL5000_CHIP_ANA_HP_CTRL] = 0x1818,
+        [SGTL5000_CHIP_ANA_CTRL] = 0x0111,
+        [SGTL5000_CHIP_LINREG_CTRL] = 0x0000,
+        [SGTL5000_CHIP_REF_CTRL] = 0x0000,
+        [SGTL5000_CHIP_MIC_CTRL] = 0x0000,
+        [SGTL5000_CHIP_LINE_OUT_CTRL] = 0x0000,
+        [SGTL5000_CHIP_LINE_OUT_VOL] = 0x0404,
+        [SGTL5000_CHIP_ANA_POWER] = 0x7060,
+        [SGTL5000_CHIP_PLL_CTRL] = 0x5000,
+        [SGTL5000_CHIP_CLK_TOP_CTRL] = 0x0000,
+        [SGTL5000_CHIP_ANA_STATUS] = 0x0000,
+        [SGTL5000_CHIP_SHORT_CTRL] = 0x0000,
+        [SGTL5000_CHIP_ANA_TEST2] = 0x0000,
+        [SGTL5000_DAP_CTRL] = 0x0000,
+        [SGTL5000_DAP_PEQ] = 0x0000,
+        [SGTL5000_DAP_BASS_ENHANCE] = 0x0040,
+        [SGTL5000_DAP_BASS_ENHANCE_CTRL] = 0x051f,
+        [SGTL5000_DAP_AUDIO_EQ] = 0x0000,
+        [SGTL5000_DAP_SURROUND] = 0x0040,
+        [SGTL5000_DAP_EQ_BASS_BAND0] = 0x002f,
+        [SGTL5000_DAP_EQ_BASS_BAND1] = 0x002f,
+        [SGTL5000_DAP_EQ_BASS_BAND2] = 0x002f,
+        [SGTL5000_DAP_EQ_BASS_BAND3] = 0x002f,
+        [SGTL5000_DAP_EQ_BASS_BAND4] = 0x002f,
+        [SGTL5000_DAP_MAIN_CHAN] = 0x8000,
+        [SGTL5000_DAP_MIX_CHAN] = 0x0000,
+        [SGTL5000_DAP_AVC_CTRL] = 0x0510,
+        [SGTL5000_DAP_AVC_THRESHOLD] = 0x1473,
+        [SGTL5000_DAP_AVC_ATTACK] = 0x0028,
+        [SGTL5000_DAP_AVC_DECAY] = 0x0050,
 };
 
 /* regulator supplies for sgtl5000, VDDD is an optional external supply */
@@ -253,11 +322,22 @@ static int dac_info_volsw(struct snd_kcontrol *kcontrol,
 {
 	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
 	uinfo->count = 2;
-	uinfo->value.integer.min = 0;
-	uinfo->value.integer.max = 0xfc - 0x3c;
+	uinfo->value.integer.min = 0x3c;
+	uinfo->value.integer.max = 0xfc;
 	return 0;
 }
 
+
+static int info_amp(struct snd_kcontrol *kcontrol,
+                          struct snd_ctl_elem_info *uinfo)
+{
+    uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+    uinfo->count = 1;
+    uinfo->value.integer.min = 0;
+    uinfo->value.integer.max = 3;
+    return 0;
+}
+
 /*
  * custom function to get of PCM playback volume
  *
@@ -362,6 +442,35 @@ static int dac_put_volsw(struct snd_kcontrol *kcontrol,
 	return 0;
 }
 
+
+static int get_amp(struct snd_kcontrol *kcontrol,
+                         struct snd_ctl_elem_value *ucontrol)
+{
+    struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+
+    ucontrol->value.integer.value[0] = ampVal;
+
+    return 0;
+}
+
+
+static int put_amp(struct snd_kcontrol *kcontrol,
+                         struct snd_ctl_elem_value *ucontrol)
+{
+    struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+    int reg;
+    int l;
+
+
+    ampVal = ucontrol->value.integer.value[0];
+
+    gpio_set_value(gpioSPKAmp1, ampVal & 1);
+    gpio_set_value(gpioSPKAmp2, ampVal & 2);
+
+    return 0;
+}
+
+
 static const DECLARE_TLV_DB_SCALE(capture_6db_attenuate, -600, 600, 0);
 
 /* tlv for mic gain, 0db 20db 30db 40db */
@@ -386,6 +495,17 @@ static const struct snd_kcontrol_new sgtl5000_snd_controls[] = {
 		.put = dac_put_volsw,
 	},
 
+
+    {
+            .iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+            .name = "Playback AMP",
+            .access = SNDRV_CTL_ELEM_ACCESS_TLV_READ |
+                      SNDRV_CTL_ELEM_ACCESS_READWRITE,
+            .info = info_amp,
+            .get = get_amp,
+            .put = put_amp,
+    },
+
 	SOC_DOUBLE("Capture Volume", SGTL5000_CHIP_ANA_ADC_CTRL, 0, 4, 0xf, 0),
 	SOC_SINGLE_TLV("Capture Attenuate Switch (-6dB)",
 			SGTL5000_CHIP_ANA_ADC_CTRL,
@@ -409,10 +529,20 @@ static int sgtl5000_digital_mute(struct snd_soc_dai *codec_dai, int mute)
 {
 	struct snd_soc_codec *codec = codec_dai->codec;
 	u16 adcdac_ctrl = SGTL5000_DAC_MUTE_LEFT | SGTL5000_DAC_MUTE_RIGHT;
-
+    if(mute){
+        gpio_set_value(gpioSPK_R, 0);
+        gpio_set_value(gpioSPK_L, 0);
+    }else{
+        if(boot_cnt == 0 ){
+            gpio_set_value(gpioSPK_R, 1);
+            gpio_set_value(gpioSPK_L, 1);
+        }
+    }
 	snd_soc_update_bits(codec, SGTL5000_CHIP_ADCDAC_CTRL,
 			adcdac_ctrl, mute ? adcdac_ctrl : 0);
 
+
+
 	return 0;
 }
 
@@ -477,7 +607,7 @@ static int sgtl5000_set_dai_fmt(struct snd_soc_dai *codec_dai, unsigned int fmt)
 	default:
 		return -EINVAL;
 	}
-
+	//i2sctl |= SGTL5000_I2S_SCLK_INV;
 	snd_soc_write(codec, SGTL5000_CHIP_I2S_CTRL, i2sctl);
 
 	return 0;
@@ -495,7 +625,9 @@ static int sgtl5000_set_dai_sysclk(struct snd_soc_dai *codec_dai,
 		sgtl5000->sysclk = freq;
 		break;
 	default:
-		return -EINVAL;
+	    dev_err(codec->dev, "%s: setting clock_id (%d) invalid error default value setted.!\n", __func__,clk_id);
+        sgtl5000->sysclk = freq;
+        break;
 	}
 
 	return 0;
@@ -539,6 +671,7 @@ static int sgtl5000_set_clock(struct snd_soc_codec *codec, int frame_rate)
 		break;
 	}
 
+
 	/* set divided factor of frame clock */
 	switch (sys_fs / frame_rate) {
 	case 4:
@@ -578,7 +711,8 @@ static int sgtl5000_set_clock(struct snd_soc_codec *codec, int frame_rate)
 	 * calculate the divider of mclk/sample_freq,
 	 * factor of freq =96k can only be 256, since mclk in range (12m,27m)
 	 */
-	switch (sgtl5000->sysclk / sys_fs) {
+
+  switch ((sgtl5000->sysclk) / sys_fs) {
 	case 256:
 		clk_ctl |= SGTL5000_MCLK_FREQ_256FS <<
 			SGTL5000_MCLK_FREQ_SHIFT;
@@ -609,7 +743,6 @@ static int sgtl5000_set_clock(struct snd_soc_codec *codec, int frame_rate)
 		int div2;
 		int pll_ctl;
 		unsigned int in, int_div, frac_div;
-
 		if (sgtl5000->sysclk > 17000000) {
 			div2 = 1;
 			in = sgtl5000->sysclk / 2;
@@ -621,6 +754,7 @@ static int sgtl5000_set_clock(struct snd_soc_codec *codec, int frame_rate)
 			out = 180633600;
 		else
 			out = 196608000;
+
 		t = do_div(out, in);
 		int_div = out;
 		t *= 2048;
@@ -628,7 +762,7 @@ static int sgtl5000_set_clock(struct snd_soc_codec *codec, int frame_rate)
 		frac_div = t;
 		pll_ctl = int_div << SGTL5000_PLL_INT_DIV_SHIFT |
 		    frac_div << SGTL5000_PLL_FRAC_DIV_SHIFT;
-
+//	dev_err(codec->dev, "SGTL5000_CHIP_PLL_CTRL = 0x%X\n",pll_ctl);
 		snd_soc_write(codec, SGTL5000_CHIP_PLL_CTRL, pll_ctl);
 		if (div2)
 			snd_soc_update_bits(codec,
@@ -651,7 +785,7 @@ static int sgtl5000_set_clock(struct snd_soc_codec *codec, int frame_rate)
 			SGTL5000_PLL_POWERUP | SGTL5000_VCOAMP_POWERUP,
 			0);
 	}
-
+//	dev_err(codec->dev, "clk_ctrl = 0x%X\n",clk_ctl);
 	/* if using pll, clk_ctrl must be set after pll power up */
 	snd_soc_write(codec, SGTL5000_CHIP_CLK_CTRL, clk_ctl);
 
@@ -672,12 +806,42 @@ static int sgtl5000_pcm_hw_params(struct snd_pcm_substream *substream,
 	int i2s_ctl = 0;
 	int stereo;
 	int ret;
-
-	/* sysclk should already set */
-	if (!sgtl5000->sysclk) {
-		dev_err(codec->dev, "%s: set sysclk first!\n", __func__);
-		return -EFAULT;
+	unsigned int sys_fs;
+    unsigned int fs;
+
+    if (boot_cnt > 0){
+        boot_cnt--;
+    }else{
+        gpio_set_value(gpioSPK_R, 1);
+        gpio_set_value(gpioSPK_L, 1);
+    }
+
+    fs = params_rate(params);
+
+    switch (fs) {
+        case 8000:
+        case 16000:
+            sys_fs = 32000;
+            break;
+        case 11025:
+        case 22050:
+            sys_fs = 44100;
+            break;
+        default:
+            sys_fs = fs;
+            break;
+    }
+
+	/* sgtl5000 does not support 512*rate when in 96000 fs */
+	switch (fs) {
+	case 96000:
+		sgtl5000->sysclk =  256*sys_fs;
+		break;
+	default:
+		sgtl5000->sysclk =  512*sys_fs;
 	}
+    sgtl5000->sysclk = 24000000;
+
 
 	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
 		stereo = SGTL5000_DAC_STEREO;
@@ -723,10 +887,12 @@ static int sgtl5000_pcm_hw_params(struct snd_pcm_substream *substream,
 		return -EINVAL;
 	}
 
+
 	snd_soc_update_bits(codec, SGTL5000_CHIP_I2S_CTRL,
 			    SGTL5000_I2S_DLEN_MASK | SGTL5000_I2S_SCLKFREQ_MASK,
 			    i2s_ctl);
 
+  //dev_err(codec->dev, "%s: SGTL5000_CHIP_I2S_CTRL 0x%x!\n", __func__, i2s_ctl);
 	return 0;
 }
 
@@ -734,7 +900,7 @@ static int sgtl5000_pcm_hw_params(struct snd_pcm_substream *substream,
 static int ldo_regulator_is_enabled(struct regulator_dev *dev)
 {
 	struct ldo_regulator *ldo = rdev_get_drvdata(dev);
-
+    dev_err(dev, "%s\n", __func__);
 	return ldo->enabled;
 }
 
@@ -743,6 +909,7 @@ static int ldo_regulator_enable(struct regulator_dev *dev)
 	struct ldo_regulator *ldo = rdev_get_drvdata(dev);
 	struct snd_soc_codec *codec = (struct snd_soc_codec *)ldo->codec_data;
 	int reg;
+	return 0;
 
 	if (ldo_regulator_is_enabled(dev))
 		return 0;
@@ -766,7 +933,7 @@ static int ldo_regulator_enable(struct regulator_dev *dev)
 	snd_soc_update_bits(codec, SGTL5000_CHIP_ANA_POWER,
 				SGTL5000_LINREG_SIMPLE_POWERUP,
 				0);
-
+    dev_err(dev, "%s\n", __func__);
 	ldo->enabled = 1;
 	return 0;
 }
@@ -775,6 +942,7 @@ static int ldo_regulator_disable(struct regulator_dev *dev)
 {
 	struct ldo_regulator *ldo = rdev_get_drvdata(dev);
 	struct snd_soc_codec *codec = (struct snd_soc_codec *)ldo->codec_data;
+	return 0;
 
 	snd_soc_update_bits(codec, SGTL5000_CHIP_ANA_POWER,
 				SGTL5000_LINEREG_D_POWERUP,
@@ -785,7 +953,7 @@ static int ldo_regulator_disable(struct regulator_dev *dev)
 				SGTL5000_LINREG_VDDD_MASK, 0);
 
 	ldo->enabled = 0;
-
+  dev_err(dev, "%s\n", __func__);
 	return 0;
 }
 
@@ -810,6 +978,7 @@ static int ldo_regulator_register(struct snd_soc_codec *codec,
 	struct ldo_regulator *ldo;
 	struct sgtl5000_priv *sgtl5000 = snd_soc_codec_get_drvdata(codec);
 	struct regulator_config config = { };
+	return 0;
 
 	ldo = kzalloc(sizeof(struct ldo_regulator), GFP_KERNEL);
 
@@ -856,6 +1025,7 @@ static int ldo_regulator_remove(struct snd_soc_codec *codec)
 {
 	struct sgtl5000_priv *sgtl5000 = snd_soc_codec_get_drvdata(codec);
 	struct ldo_regulator *ldo = sgtl5000->ldo;
+	return 0;
 
 	if (!ldo)
 		return 0;
@@ -896,6 +1066,9 @@ static int sgtl5000_set_bias_level(struct snd_soc_codec *codec,
 {
 	int ret;
 	struct sgtl5000_priv *sgtl5000 = snd_soc_codec_get_drvdata(codec);
+  codec->dapm.bias_level = level;
+
+	return 0;
 
 	switch (level) {
 	case SND_SOC_BIAS_ON:
@@ -903,19 +1076,16 @@ static int sgtl5000_set_bias_level(struct snd_soc_codec *codec,
 		break;
 	case SND_SOC_BIAS_STANDBY:
 		if (codec->dapm.bias_level == SND_SOC_BIAS_OFF) {
-			ret = regulator_bulk_enable(
-						ARRAY_SIZE(sgtl5000->supplies),
-						sgtl5000->supplies);
+      ret = regulator_bulk_enable(ARRAY_SIZE(sgtl5000->supplies),sgtl5000->supplies);
 			if (ret)
 				return ret;
-			udelay(10);
+      udelay(10);
 		}
 
-		break;
+	break;
 	case SND_SOC_BIAS_OFF:
-		regulator_bulk_disable(ARRAY_SIZE(sgtl5000->supplies),
-					sgtl5000->supplies);
-		break;
+        regulator_bulk_disable(ARRAY_SIZE(sgtl5000->supplies),sgtl5000->supplies);
+  break;
 	}
 
 	codec->dapm.bias_level = level;
@@ -974,8 +1144,9 @@ static int sgtl5000_volatile_register(struct snd_soc_codec *codec,
 #ifdef CONFIG_SUSPEND
 static int sgtl5000_suspend(struct snd_soc_codec *codec)
 {
-	sgtl5000_set_bias_level(codec, SND_SOC_BIAS_OFF);
-
+	//sgtl5000_set_bias_level(codec, SND_SOC_BIAS_OFF);
+        gpio_set_value(gpioSPK_R, 0);
+        gpio_set_value(gpioSPK_L, 0);
 	return 0;
 }
 
@@ -988,7 +1159,7 @@ static int sgtl5000_restore_regs(struct snd_soc_codec *codec)
 {
 	u16 *cache = codec->reg_cache;
 	u16 reg;
-
+    return 0;
 	/* restore regular registers */
 	for (reg = 0; reg <= SGTL5000_CHIP_SHORT_CTRL; reg += 2) {
 
@@ -1051,6 +1222,7 @@ static int sgtl5000_resume(struct snd_soc_codec *codec)
 #define sgtl5000_resume  NULL
 #endif	/* CONFIG_SUSPEND */
 
+
 /*
  * sgtl5000 has 3 internal power supplies:
  * 1. VAG, normally set to vdda/2
@@ -1069,13 +1241,18 @@ static int sgtl5000_set_power_regs(struct snd_soc_codec *codec)
 	int vdda;
 	int vddio;
 	u16 ana_pwr;
+    u16 ana_off;
 	u16 lreg_ctrl;
 	int vag;
 	struct sgtl5000_priv *sgtl5000 = snd_soc_codec_get_drvdata(codec);
-
+  vdda = vddio = vddd = 1800000;
+  /*
 	vdda  = regulator_get_voltage(sgtl5000->supplies[VDDA].consumer);
 	vddio = regulator_get_voltage(sgtl5000->supplies[VDDIO].consumer);
 	vddd  = regulator_get_voltage(sgtl5000->supplies[VDDD].consumer);
+*/
+  //dev_err(codec->dev, "vdda = %d vddio=%d vddd=%d\n",vdda,vddio,vddd);
+
 
 	vdda  = vdda / 1000;
 	vddio = vddio / 1000;
@@ -1098,6 +1275,7 @@ static int sgtl5000_set_power_regs(struct snd_soc_codec *codec)
 
 	/* reset value */
 	ana_pwr = snd_soc_read(codec, SGTL5000_CHIP_ANA_POWER);
+
 	ana_pwr |= SGTL5000_DAC_STEREO |
 			SGTL5000_ADC_STEREO |
 			SGTL5000_REFTOP_POWERUP;
@@ -1182,7 +1360,7 @@ static int sgtl5000_replace_vddd_with_ldo(struct snd_soc_codec *codec)
 {
 	struct sgtl5000_priv *sgtl5000 = snd_soc_codec_get_drvdata(codec);
 	int ret;
-
+	return 0;
 	/* set internal ldo to 1.2v */
 	ret = ldo_regulator_register(codec, &ldo_init_data, LDO_VOLTAGE);
 	if (ret) {
@@ -1190,24 +1368,24 @@ static int sgtl5000_replace_vddd_with_ldo(struct snd_soc_codec *codec)
 			"Failed to register vddd internal supplies: %d\n", ret);
 		return ret;
 	}
-
 	sgtl5000->supplies[VDDD].supply = LDO_CONSUMER_NAME;
 
 	ret = regulator_bulk_get(codec->dev, ARRAY_SIZE(sgtl5000->supplies),
 			sgtl5000->supplies);
-
 	if (ret) {
 		ldo_regulator_remove(codec);
 		dev_err(codec->dev, "Failed to request supplies: %d\n", ret);
 		return ret;
 	}
 
+
 	dev_info(codec->dev, "Using internal LDO instead of VDDD\n");
 	return 0;
 }
 
 static int sgtl5000_enable_regulators(struct snd_soc_codec *codec)
 {
+    return 0;
 	u16 reg;
 	int ret;
 	int rev;
@@ -1215,12 +1393,16 @@ static int sgtl5000_enable_regulators(struct snd_soc_codec *codec)
 	int external_vddd = 0;
 	struct sgtl5000_priv *sgtl5000 = snd_soc_codec_get_drvdata(codec);
 
-	for (i = 0; i < ARRAY_SIZE(sgtl5000->supplies); i++)
+
+  for (i = 0; i < ARRAY_SIZE(sgtl5000->supplies); i++)
 		sgtl5000->supplies[i].supply = supply_names[i];
 
 	ret = regulator_bulk_get(codec->dev, ARRAY_SIZE(sgtl5000->supplies),
 				sgtl5000->supplies);
-	if (!ret)
+
+  //dev_err(codec->dev, "%s %d \n", ret);
+
+  if (!ret)
 		external_vddd = 1;
 	else {
 		ret = sgtl5000_replace_vddd_with_ldo(codec);
@@ -1228,9 +1410,13 @@ static int sgtl5000_enable_regulators(struct snd_soc_codec *codec)
 			return ret;
 	}
 
+  //dev_err(codec->dev, "%s %d \n", ret);
+
 	ret = regulator_bulk_enable(ARRAY_SIZE(sgtl5000->supplies),
 					sgtl5000->supplies);
-	if (ret)
+
+  //dev_err(codec->dev, "%s %d \n", ret);
+  if (ret)
 		goto err_regulator_free;
 
 	/* wait for all power rails bring up */
@@ -1239,6 +1425,8 @@ static int sgtl5000_enable_regulators(struct snd_soc_codec *codec)
 	/* Need 8 clocks before I2C accesses */
 	udelay(1);
 
+
+  return 0;
 	/* read chip information */
 	reg = snd_soc_read(codec, SGTL5000_CHIP_ID);
 	if (((reg & SGTL5000_PARTID_MASK) >> SGTL5000_PARTID_SHIFT) !=
@@ -1294,7 +1482,9 @@ err_regulator_free:
 static int sgtl5000_probe(struct snd_soc_codec *codec)
 {
 	int ret;
+  int tmp_select;
 	struct sgtl5000_priv *sgtl5000 = snd_soc_codec_get_drvdata(codec);
+    int i;
 
 	/* setup i2c data ops */
 	ret = snd_soc_codec_set_cache_io(codec, 16, 16, SND_SOC_I2C);
@@ -1303,6 +1493,10 @@ static int sgtl5000_probe(struct snd_soc_codec *codec)
 		return ret;
 	}
 
+    for (i = 0; i < ARRAY_SIZE(sgtl5000_reg_defaults); i++) {
+        ret = snd_soc_write(codec, sgtl5000_reg_defaults[i].reg, sgtl5000_reg_defaults[i].def);
+    }
+
 	ret = sgtl5000_enable_regulators(codec);
 	if (ret)
 		return ret;
@@ -1323,10 +1517,23 @@ static int sgtl5000_probe(struct snd_soc_codec *codec)
 	 * set i2s as default input of sound switch
 	 * TODO: add sound switch to control and dapm widge.
 	 */
-	snd_soc_write(codec, SGTL5000_CHIP_SSS_CTRL,
-			SGTL5000_DAC_SEL_I2S_IN << SGTL5000_DAC_SEL_SHIFT);
-	snd_soc_write(codec, SGTL5000_CHIP_DIG_POWER,
-			SGTL5000_ADC_EN | SGTL5000_DAC_EN);
+/*
+  tmp_select = (SGTL5000_DAP_MIX_SEL_I2S_IN << SGTL5000_DAP_MIX_SEL_SHIFT)
+              |(SGTL5000_DAP_SEL_I2S_IN << SGTL5000_DAP_SEL_SHIFT)
+              |(SGTL5000_DAC_SEL_DAP << SGTL5000_DAC_SEL_SHIFT);
+	snd_soc_write(codec, SGTL5000_CHIP_SSS_CTRL,tmp_select);
+
+    snd_soc_write(codec, SGTL5000_CHIP_DIG_POWER,SGTL5000_I2S_IN_POWERUP|SGTL5000_ADC_EN | SGTL5000_DAC_EN);
+*/
+
+    /*
+ * set i2s as default input of sound switch
+ * TODO: add sound switch to control and dapm widge.
+ */
+    snd_soc_write(codec, SGTL5000_CHIP_SSS_CTRL,
+                  SGTL5000_DAC_SEL_I2S_IN << SGTL5000_DAC_SEL_SHIFT);
+    snd_soc_write(codec, SGTL5000_CHIP_DIG_POWER,
+                  SGTL5000_ADC_EN | SGTL5000_DAC_EN);
 
 	/* enable dac volume ramp by default */
 	snd_soc_write(codec, SGTL5000_CHIP_ADCDAC_CTRL,
@@ -1334,24 +1541,47 @@ static int sgtl5000_probe(struct snd_soc_codec *codec)
 			SGTL5000_DAC_MUTE_RIGHT |
 			SGTL5000_DAC_MUTE_LEFT);
 
-	snd_soc_write(codec, SGTL5000_CHIP_PAD_STRENGTH, 0x015f);
+	snd_soc_write(codec, SGTL5000_CHIP_PAD_STRENGTH, 0x014f);
 
 	snd_soc_write(codec, SGTL5000_CHIP_ANA_CTRL,
 			SGTL5000_HP_ZCD_EN |
 			SGTL5000_ADC_ZCD_EN);
 
-	snd_soc_write(codec, SGTL5000_CHIP_MIC_CTRL, 2);
+	snd_soc_write(codec, SGTL5000_CHIP_MIC_CTRL, 0);
 
 	/*
 	 * disable DAP
 	 * TODO:
 	 * Enable DAP in kcontrol and dapm.
 	 */
-	snd_soc_write(codec, SGTL5000_DAP_CTRL, 0);
+  tmp_select =SGTL5000_DAP_EN | SGTL5000_DAP_MIX_EN;//(SGTL5000_DAP_EN);// | (SGTL5000_DAP_MIX_EN);
+	snd_soc_write(codec, SGTL5000_DAP_CTRL, tmp_select);
 
 	/* leading to standby state */
 	ret = sgtl5000_set_bias_level(codec, SND_SOC_BIAS_STANDBY);
-	if (ret)
+
+
+    gpio_request(gpioSPK_R, "sysfs");          // gpioLED is hardcoded to 49, request it
+    gpio_direction_output(gpioSPK_R, 0);   // Set the gpio to be in output mode and on
+// gpio_set_value(gpioLED, ledOn);          // Not required as set by line above (here for reference)
+    gpio_export(gpioSPK_R, false);             // Causes g
+
+
+    gpio_request(gpioSPK_L, "sysfs");          // gpioLED is hardcoded to 49, request it
+    gpio_direction_output(gpioSPK_L, 0);   // Set the gpio to be in output mode and on
+// gpio_set_value(gpioLED, ledOn);          // Not required as set by line above (here for reference)
+    gpio_export(gpioSPK_L, false);
+
+    gpio_request(gpioSPKAmp1, "sysfs");          // gpioLED is hardcoded to 49, request it
+    gpio_direction_output(gpioSPKAmp1, 0);   // Set the gpio to be in output mode and on
+// gpio_set_value(gpioLED, ledOn);          // Not required as set by line above (here for reference)
+    gpio_export(gpioSPKAmp1, false);             // Causes g
+    gpio_request(gpioSPKAmp2, "sysfs");          // gpioLED is hardcoded to 49, request it
+    gpio_direction_output(gpioSPKAmp2, 0);   // Set the gpio to be in output mode and on
+// gpio_set_value(gpioLED, ledOn);          // Not required as set by line above (here for reference)
+    gpio_export(gpioSPKAmp2, false);             // Causes g
+
+    if (ret)
 		goto err;
 
 	return 0;
@@ -1368,16 +1598,16 @@ err:
 
 static int sgtl5000_remove(struct snd_soc_codec *codec)
 {
+/*
 	struct sgtl5000_priv *sgtl5000 = snd_soc_codec_get_drvdata(codec);
 
 	sgtl5000_set_bias_level(codec, SND_SOC_BIAS_OFF);
-
 	regulator_bulk_disable(ARRAY_SIZE(sgtl5000->supplies),
 						sgtl5000->supplies);
 	regulator_bulk_free(ARRAY_SIZE(sgtl5000->supplies),
 				sgtl5000->supplies);
 	ldo_regulator_remove(codec);
-
+*/
 	return 0;
 }
 
@@ -1400,6 +1630,10 @@ static struct snd_soc_codec_driver sgtl5000_driver = {
 	.num_dapm_routes = ARRAY_SIZE(sgtl5000_dapm_routes),
 };
 
+
+
+
+
 static int sgtl5000_i2c_probe(struct i2c_client *client,
 			      const struct i2c_device_id *id)
 {
diff --git a/sound/soc/codecs/sgtl5000.h b/sound/soc/codecs/sgtl5000.h
index 0bd6e1c..a6bd529 100644
--- a/sound/soc/codecs/sgtl5000.h
+++ b/sound/soc/codecs/sgtl5000.h
@@ -397,4 +397,7 @@
 #define SGTL5000_SYSCLK				0x00
 #define SGTL5000_LRCLK				0x01
 
+
+
+
 #endif
diff --git a/sound/soc/samsung/Kconfig b/sound/soc/samsung/Kconfig
index cb97c3d..61bb9b5 100644
--- a/sound/soc/samsung/Kconfig
+++ b/sound/soc/samsung/Kconfig
@@ -283,6 +283,7 @@ config SND_SOC_SAMSUNG_ARTIK_AK4953
 	select SND_SAMSUNG_I2S
 	select SND_SAMSUNG_AUDSS if SOC_EXYNOS5422
 	select SND_SOC_AK4953
+    select SND_SOC_SGTL5000
 	help
 	  Say Y if you want to add support for SoC audio on the Artik board.
 
diff --git a/sound/soc/samsung/artik_ak4953.c b/sound/soc/samsung/artik_ak4953.c
index 8fcaf22..ca93688 100644
--- a/sound/soc/samsung/artik_ak4953.c
+++ b/sound/soc/samsung/artik_ak4953.c
@@ -11,6 +11,8 @@
  *  Free Software Foundation;  either version 2 of the  License, or (at your
  *  option) any later version.
  */
+#define DEBUG
+//#define CONFIG_SND_SAMSUNG_I2S_MASTER
 
 #include <linux/firmware.h>
 #include <linux/completion.h>
@@ -382,7 +384,6 @@ static int set_aud_sclk(struct snd_soc_card *card, unsigned long rate)
 		ret = -EINVAL;
 		goto out3;
 	}
-
 	clk_set_rate(sclk_i2s, rate);
 
 	clk_put(sclk_i2s);
@@ -475,7 +476,8 @@ static struct snd_soc_dai_link artik_dai[] = {
 	{
 		.name = "AK4953 HiFi",
 		.stream_name = "Playback",
-		.codec_dai_name = "ak4953-AIF1",
+		//.codec_dai_name = "ak4953-AIF1",
+		.codec_dai_name = "sgtl5000",
 		.init = artik_ak4953_init_paiftx,
 		.ops = &artik_ops,
 	},
-- 
2.7.4

